CCS PCM C Compiler, Version 5.007, 61971               30-Ara-25 09:01

               Filename:   C:\Users\Alihan\Desktop\Pic_Telegraph\src\main.lst

               ROM used:   3170 words (39%)
                           Largest free fragment is 2048
               RAM used:   126 (34%) at main() level
                           219 (60%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   038
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.0
0020:  GOTO   023
0021:  BTFSC  0C.0
0022:  GOTO   03B
0023:  BTFSS  0B.5
0024:  GOTO   027
0025:  BTFSC  0B.2
0026:  GOTO   03E
0027:  MOVF   22,W
0028:  MOVWF  04
0029:  MOVF   23,W
002A:  MOVWF  77
002B:  MOVF   24,W
002C:  MOVWF  78
002D:  MOVF   25,W
002E:  MOVWF  79
002F:  MOVF   26,W
0030:  MOVWF  7A
0031:  MOVF   20,W
0032:  MOVWF  0A
0033:  SWAPF  21,W
0034:  MOVWF  03
0035:  SWAPF  7F,F
0036:  SWAPF  7F,W
0037:  RETFIE
0038:  BCF    0A.3
0039:  BCF    0A.4
003A:  GOTO   0EF
003B:  BCF    0A.3
003C:  BCF    0A.4
003D:  GOTO   119
003E:  BCF    0A.3
003F:  BCF    0A.4
0040:  GOTO   18A
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
0041:  BCF    0A.0
0042:  BCF    0A.1
0043:  BCF    0A.2
0044:  ADDWF  02,F
0045:  RETLW  28
0046:  RETLW  0C
0047:  RETLW  01
0048:  RETLW  06
0049:  BCF    0A.0
004A:  BCF    0A.1
004B:  BCF    0A.2
004C:  ADDWF  02,F
004D:  RETLW  00
004E:  RETLW  00
004F:  RETLW  45
0050:  RETLW  54
0051:  RETLW  49
0052:  RETLW  41
0053:  RETLW  4E
0054:  RETLW  4D
0055:  RETLW  53
0056:  RETLW  55
0057:  RETLW  52
0058:  RETLW  57
0059:  RETLW  44
005A:  RETLW  4B
005B:  RETLW  47
005C:  RETLW  4F
005D:  RETLW  48
005E:  RETLW  56
005F:  RETLW  46
0060:  RETLW  00
0061:  RETLW  4C
0062:  RETLW  00
0063:  RETLW  50
0064:  RETLW  4A
0065:  RETLW  42
0066:  RETLW  58
0067:  RETLW  43
0068:  RETLW  59
0069:  RETLW  5A
006A:  RETLW  51
006B:  RETLW  00
006C:  RETLW  00
006D:  RETLW  35
006E:  RETLW  34
006F:  RETLW  00
0070:  RETLW  33
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  00
0074:  RETLW  32
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  00
007B:  RETLW  00
007C:  RETLW  31
007D:  RETLW  36
007E:  RETLW  00
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  00
0082:  RETLW  00
0083:  RETLW  00
0084:  RETLW  00
0085:  RETLW  37
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  00
0089:  RETLW  38
008A:  RETLW  00
008B:  RETLW  39
008C:  RETLW  30
008D:  BCF    0A.0
008E:  BCF    0A.1
008F:  BCF    0A.2
0090:  ADDWF  02,F
0091:  RETLW  54
0092:  RETLW  41
0093:  RETLW  4E
0094:  RETLW  49
0095:  RETLW  4D
0096:  RETLW  53
0097:  RETLW  49
0098:  RETLW  5A
0099:  RETLW  20
009A:  RETLW  4B
009B:  RETLW  4F
009C:  RETLW  4D
009D:  RETLW  55
009E:  RETLW  54
009F:  RETLW  00
00A0:  BCF    0A.0
00A1:  BCF    0A.1
00A2:  BCF    0A.2
00A3:  ADDWF  02,F
00A4:  RETLW  46
00A5:  RETLW  4F
00A6:  RETLW  52
00A7:  RETLW  4D
00A8:  RETLW  41
00A9:  RETLW  54
00AA:  RETLW  20
00AB:  RETLW  48
00AC:  RETLW  41
00AD:  RETLW  54
00AE:  RETLW  41
00AF:  RETLW  53
00B0:  RETLW  49
00B1:  RETLW  00
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,10
00BA:  DATA 20,10
00BB:  DATA 20,10
00BC:  DATA 00,00
00BD:  DATA CD,27
00BE:  DATA 44,1D
00BF:  DATA A0,26
00C0:  DATA C5,29
00C1:  DATA 41,25
00C2:  DATA 20,10
00C3:  DATA 20,10
00C4:  DATA 20,10
00C5:  DATA 20,10
00C6:  DATA 20,10
00C7:  DATA 00,01
00C8:  DATA CD,27
00C9:  DATA 44,1D
00CA:  DATA A0,25
00CB:  DATA CF,26
00CC:  DATA 55,2A
00CD:  DATA 20,10
00CE:  DATA 20,10
00CF:  DATA 20,10
00D0:  DATA 20,10
00D1:  DATA 20,10
00D2:  DATA 00,01
00D3:  DATA 20,10
00D4:  DATA 00,01
00D5:  DATA 20,10
00D6:  DATA 20,10
00D7:  DATA 20,10
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 20,10
00DB:  DATA 20,10
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 00,00
00E0:  DATA C8,22
00E1:  DATA D0,29
00E2:  DATA 49,10
00E3:  DATA D3,24
00E4:  DATA CC,24
00E5:  DATA CE,24
00E6:  DATA D9,27
00E7:  DATA 52,00
00E8:  DATA D5,2C
00E9:  DATA CB,2A
00EA:  DATA A0,26
00EB:  DATA 4F,22
00EC:  DATA 55,17
00ED:  DATA 2E,17
00EE:  DATA 00,00
*
0195:  DATA CD,37
0196:  DATA F2,39
0197:  DATA 20,2A
0198:  DATA 65,36
0199:  DATA 67,39
019A:  DATA 61,33
019B:  DATA 00,01
019C:  DATA D6,22
019D:  DATA D2,24
019E:  DATA A0,23
019F:  DATA 4F,27
01A0:  DATA C4,22
01A1:  DATA D2,24
01A2:  DATA 4C,22
01A3:  DATA 49,00
*
03D0:  MOVF   0B,W
03D1:  BSF    03.6
03D2:  MOVWF  29
03D3:  BCF    03.6
03D4:  BCF    0B.7
03D5:  BSF    03.5
03D6:  BSF    03.6
03D7:  BSF    0C.7
03D8:  BSF    0C.0
03D9:  NOP
03DA:  NOP
03DB:  BCF    03.5
03DC:  MOVF   0C,W
03DD:  ANDLW  7F
03DE:  BTFSC  03.2
03DF:  GOTO   40D
03E0:  MOVWF  2A
03E1:  MOVF   0D,W
03E2:  MOVWF  2B
03E3:  MOVF   0F,W
03E4:  MOVWF  2C
03E5:  MOVF   2A,W
03E6:  MOVWF  2D
03E7:  BCF    03.6
03E8:  CALL   396
03E9:  BSF    03.6
03EA:  MOVF   2B,W
03EB:  MOVWF  0D
03EC:  MOVF   2C,W
03ED:  MOVWF  0F
03EE:  BSF    03.5
03EF:  BSF    0C.7
03F0:  BSF    0C.0
03F1:  NOP
03F2:  NOP
03F3:  BCF    03.5
03F4:  RLF    0C,W
03F5:  RLF    0E,W
03F6:  ANDLW  7F
03F7:  BTFSC  03.2
03F8:  GOTO   40D
03F9:  MOVWF  2A
03FA:  MOVF   0D,W
03FB:  MOVWF  2B
03FC:  MOVF   0F,W
03FD:  MOVWF  2C
03FE:  MOVF   2A,W
03FF:  MOVWF  2D
0400:  BCF    03.6
0401:  CALL   396
0402:  BSF    03.6
0403:  MOVF   2B,W
0404:  MOVWF  0D
0405:  MOVF   2C,W
0406:  MOVWF  0F
0407:  INCF   0D,F
0408:  BTFSC  03.2
0409:  INCF   0F,F
040A:  BCF    03.6
040B:  GOTO   3D5
040C:  BSF    03.6
040D:  BTFSS  29.7
040E:  GOTO   412
040F:  BCF    03.6
0410:  BSF    0B.7
0411:  BSF    03.6
0412:  BCF    03.6
0413:  RETURN
0414:  MOVF   00,F
0415:  BTFSC  03.2
0416:  GOTO   430
0417:  BSF    03.6
0418:  CLRF   2A
0419:  MOVF   04,W
041A:  MOVWF  29
041B:  BCF    2A.0
041C:  BTFSC  03.7
041D:  BSF    2A.0
041E:  MOVF   00,W
041F:  MOVWF  2D
0420:  BCF    03.6
0421:  CALL   396
0422:  BSF    03.6
0423:  MOVF   29,W
0424:  MOVWF  04
0425:  BCF    03.7
0426:  BTFSC  2A.0
0427:  BSF    03.7
0428:  INCF   04,F
0429:  BTFSS  03.2
042A:  GOTO   42E
042B:  BCF    03.6
042C:  INCF   05,F
042D:  BSF    03.6
042E:  BCF    03.6
042F:  GOTO   414
0430:  RETURN
*
0562:  MOVF   48,W
0563:  CLRF   78
0564:  SUBWF  47,W
0565:  BTFSC  03.0
0566:  GOTO   56A
0567:  MOVF   47,W
0568:  MOVWF  77
0569:  GOTO   576
056A:  CLRF   77
056B:  MOVLW  08
056C:  MOVWF  49
056D:  RLF    47,F
056E:  RLF    77,F
056F:  MOVF   48,W
0570:  SUBWF  77,W
0571:  BTFSC  03.0
0572:  MOVWF  77
0573:  RLF    78,F
0574:  DECFSZ 49,F
0575:  GOTO   56D
*
0783:  BTFSC  47.7
0784:  GOTO   798
0785:  MOVLW  0F
0786:  MOVWF  77
0787:  SWAPF  46,W
0788:  ANDWF  77,F
0789:  MOVLW  0A
078A:  SUBWF  77,W
078B:  BTFSC  03.0
078C:  GOTO   790
078D:  MOVLW  30
078E:  ADDWF  77,F
078F:  GOTO   792
0790:  MOVF   47,W
0791:  ADDWF  77,F
0792:  MOVF   77,W
0793:  BCF    03.5
0794:  BTFSS  0C.4
0795:  GOTO   794
0796:  MOVWF  19
0797:  BSF    03.5
0798:  MOVLW  0F
0799:  ANDWF  46,F
079A:  MOVLW  0A
079B:  SUBWF  46,W
079C:  BTFSC  03.0
079D:  GOTO   7A0
079E:  MOVLW  30
079F:  GOTO   7A2
07A0:  BCF    47.7
07A1:  MOVF   47,W
07A2:  ADDWF  46,F
07A3:  MOVF   46,W
07A4:  BCF    03.5
07A5:  BTFSS  0C.4
07A6:  GOTO   7A5
07A7:  MOVWF  19
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOWDT, NOPROTECT, NOLVP, NOBROWNOUT, PUT, NOMCLR 
.................... #use delay(clock = 8000000) 
*
01A4:  MOVLW  2E
01A5:  MOVWF  04
01A6:  BSF    03.7
01A7:  MOVF   00,W
01A8:  BTFSC  03.2
01A9:  GOTO   1B7
01AA:  MOVLW  02
01AB:  MOVWF  78
01AC:  CLRF   77
01AD:  DECFSZ 77,F
01AE:  GOTO   1AD
01AF:  DECFSZ 78,F
01B0:  GOTO   1AC
01B1:  MOVLW  97
01B2:  MOVWF  77
01B3:  DECFSZ 77,F
01B4:  GOTO   1B3
01B5:  DECFSZ 00,F
01B6:  GOTO   1AA
01B7:  RETURN
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = BT_MODUL) 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0971:  MOVF   29,W
0972:  MOVWF  2F
0973:  MOVF   28,W
0974:  MOVWF  2E
0975:  MOVF   2C,F
0976:  BTFSS  03.2
0977:  GOTO   17B
0978:  MOVF   2D,F
0979:  BTFSC  03.2
097A:  GOTO   1A6
097B:  MOVF   2B,W
097C:  MOVWF  7A
097D:  MOVF   2A,W
097E:  MOVWF  04
097F:  BCF    03.7
0980:  BTFSC  7A.0
0981:  BSF    03.7
0982:  MOVF   00,F
0983:  BTFSC  03.2
0984:  GOTO   1A6
....................      *s++ = *s2++; 
0985:  MOVF   2F,W
0986:  MOVWF  7A
0987:  MOVF   2E,W
0988:  INCF   2E,F
0989:  BTFSC  03.2
098A:  INCF   2F,F
098B:  MOVWF  30
098C:  MOVF   7A,W
098D:  MOVWF  31
098E:  MOVF   2B,W
098F:  MOVWF  7A
0990:  MOVF   2A,W
0991:  INCF   2A,F
0992:  BTFSC  03.2
0993:  INCF   2B,F
0994:  MOVWF  04
0995:  BCF    03.7
0996:  BTFSC  7A.0
0997:  BSF    03.7
0998:  MOVF   00,W
0999:  MOVWF  32
099A:  MOVF   30,W
099B:  MOVWF  04
099C:  BCF    03.7
099D:  BTFSC  31.0
099E:  BSF    03.7
099F:  MOVF   32,W
09A0:  MOVWF  00
09A1:  MOVF   2C,W
09A2:  BTFSC  03.2
09A3:  DECF   2D,F
09A4:  DECF   2C,F
09A5:  GOTO   175
....................   for (; n > 0; n--) 
09A6:  MOVF   2C,F
09A7:  BTFSS  03.2
09A8:  GOTO   1AC
09A9:  MOVF   2D,F
09AA:  BTFSC  03.2
09AB:  GOTO   1BC
....................      *s++ = '\0'; 
09AC:  MOVF   2F,W
09AD:  MOVWF  7A
09AE:  MOVF   2E,W
09AF:  INCF   2E,F
09B0:  BTFSC  03.2
09B1:  INCF   2F,F
09B2:  MOVWF  04
09B3:  BCF    03.7
09B4:  BTFSC  7A.0
09B5:  BSF    03.7
09B6:  CLRF   00
09B7:  MOVF   2C,W
09B8:  BTFSC  03.2
09B9:  DECF   2D,F
09BA:  DECF   2C,F
09BB:  GOTO   1A6
....................  
....................   return(s1); 
09BC:  MOVF   28,W
09BD:  MOVWF  78
09BE:  MOVF   29,W
09BF:  MOVWF  79
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
05BA:  BSF    03.6
05BB:  MOVF   27,W
05BC:  MOVWF  7A
05BD:  MOVF   26,W
05BE:  MOVWF  04
05BF:  BCF    03.7
05C0:  BTFSC  7A.0
05C1:  BSF    03.7
05C2:  MOVF   00,W
05C3:  MOVWF  2A
05C4:  MOVF   29,W
05C5:  MOVWF  7A
05C6:  MOVF   28,W
05C7:  MOVWF  04
05C8:  BCF    03.7
05C9:  BTFSC  7A.0
05CA:  BSF    03.7
05CB:  MOVF   00,W
05CC:  SUBWF  2A,W
05CD:  BTFSS  03.2
05CE:  GOTO   5E6
....................       if (*s1 == '\0') 
05CF:  MOVF   27,W
05D0:  MOVWF  7A
05D1:  MOVF   26,W
05D2:  MOVWF  04
05D3:  BCF    03.7
05D4:  BTFSC  7A.0
05D5:  BSF    03.7
05D6:  MOVF   00,F
05D7:  BTFSS  03.2
05D8:  GOTO   5DC
....................          return(0); 
05D9:  MOVLW  00
05DA:  MOVWF  78
05DB:  GOTO   5FE
05DC:  MOVF   27,W
05DD:  MOVWF  7A
05DE:  MOVF   26,W
05DF:  INCF   26,F
05E0:  BTFSC  03.2
05E1:  INCF   27,F
05E2:  INCF   28,F
05E3:  BTFSC  03.2
05E4:  INCF   29,F
05E5:  GOTO   5BB
....................    return((*s1 < *s2) ? -1: 1); 
05E6:  MOVF   27,W
05E7:  MOVWF  7A
05E8:  MOVF   26,W
05E9:  MOVWF  04
05EA:  BCF    03.7
05EB:  BTFSC  27.0
05EC:  BSF    03.7
05ED:  MOVF   00,W
05EE:  MOVWF  2A
05EF:  MOVF   29,W
05F0:  MOVWF  7A
05F1:  MOVF   28,W
05F2:  MOVWF  04
05F3:  BCF    03.7
05F4:  BTFSC  29.0
05F5:  BSF    03.7
05F6:  MOVF   00,W
05F7:  SUBWF  2A,W
05F8:  BTFSC  03.0
05F9:  GOTO   5FC
05FA:  MOVLW  FF
05FB:  GOTO   5FD
05FC:  MOVLW  01
05FD:  MOVWF  78
05FE:  BCF    03.6
05FF:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0596:  BSF    03.6
0597:  MOVF   27,W
0598:  MOVWF  7A
0599:  MOVF   26,W
059A:  MOVWF  04
059B:  BCF    03.7
059C:  BTFSC  7A.0
059D:  BSF    03.7
059E:  MOVF   28,W
059F:  SUBWF  00,W
05A0:  BTFSC  03.2
05A1:  GOTO   5B4
....................       if (*s == '\0') 
05A2:  MOVF   27,W
05A3:  MOVWF  7A
05A4:  MOVF   26,W
05A5:  MOVWF  04
05A6:  BCF    03.7
05A7:  BTFSC  7A.0
05A8:  BSF    03.7
05A9:  MOVF   00,F
05AA:  BTFSS  03.2
05AB:  GOTO   5B0
....................          return(0); 
05AC:  MOVLW  00
05AD:  MOVWF  78
05AE:  MOVWF  79
05AF:  GOTO   5B8
05B0:  INCF   26,F
05B1:  BTFSC  03.2
05B2:  INCF   27,F
05B3:  GOTO   597
....................    return(s); 
05B4:  MOVF   26,W
05B5:  MOVWF  78
05B6:  MOVF   27,W
05B7:  MOVWF  79
05B8:  BCF    03.6
05B9:  RETURN
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
082E:  BCF    03.6
082F:  CLRF   27
0830:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0431:  BSF    03.6
0432:  MOVF   2F,W
0433:  MOVWF  31
0434:  MOVF   2E,W
0435:  MOVWF  30
0436:  MOVF   31,W
0437:  MOVWF  7A
0438:  MOVF   30,W
0439:  MOVWF  04
043A:  BCF    03.7
043B:  BTFSC  7A.0
043C:  BSF    03.7
043D:  MOVF   00,F
043E:  BTFSC  03.2
043F:  GOTO   444
0440:  INCF   30,F
0441:  BTFSC  03.2
0442:  INCF   31,F
0443:  GOTO   436
....................    return(sc - s); 
0444:  MOVF   2E,W
0445:  SUBWF  30,W
0446:  MOVWF  77
0447:  MOVF   31,W
0448:  MOVWF  7A
0449:  MOVF   2F,W
044A:  BTFSS  03.0
044B:  INCFSZ 2F,W
044C:  SUBWF  7A,F
044D:  MOVF   77,W
044E:  MOVWF  78
044F:  BCF    03.6
0450:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LCD_RS_PIN PIN_D1 
.................... #define LCD_RW_PIN PIN_D2 
.................... #define LCD_ENABLE_PIN PIN_D3 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... #include <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0237:  BSF    08.4
....................    output_float(LCD_DATA5); 
0238:  BSF    08.5
....................    output_float(LCD_DATA6); 
0239:  BSF    08.6
....................    output_float(LCD_DATA7); 
023A:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
023B:  BCF    03.5
023C:  BSF    08.2
023D:  BSF    03.5
023E:  BCF    08.2
....................    delay_cycles(1); 
023F:  NOP
....................    lcd_output_enable(1); 
0240:  BCF    03.5
0241:  BSF    08.3
0242:  BSF    03.5
0243:  BCF    08.3
....................    delay_cycles(1); 
0244:  NOP
....................    high = lcd_read_nibble(); 
0245:  BCF    03.5
0246:  CALL   1F4
0247:  MOVF   78,W
0248:  BSF    03.6
0249:  MOVWF  35
....................        
....................    lcd_output_enable(0); 
024A:  BCF    03.6
024B:  BCF    08.3
024C:  BSF    03.5
024D:  BCF    08.3
....................    delay_cycles(1); 
024E:  NOP
....................    lcd_output_enable(1); 
024F:  BCF    03.5
0250:  BSF    08.3
0251:  BSF    03.5
0252:  BCF    08.3
....................    delay_us(1); 
0253:  GOTO   254
....................    low = lcd_read_nibble(); 
0254:  BCF    03.5
0255:  CALL   1F4
0256:  MOVF   78,W
0257:  BSF    03.6
0258:  MOVWF  34
....................        
....................    lcd_output_enable(0); 
0259:  BCF    03.6
025A:  BCF    08.3
025B:  BSF    03.5
025C:  BCF    08.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
025D:  BCF    08.4
....................    output_drive(LCD_DATA5); 
025E:  BCF    08.5
....................    output_drive(LCD_DATA6); 
025F:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0260:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0261:  BCF    03.5
0262:  BSF    03.6
0263:  SWAPF  35,W
0264:  MOVWF  77
0265:  MOVLW  F0
0266:  ANDWF  77,F
0267:  MOVF   77,W
0268:  IORWF  34,W
0269:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01F4:  BSF    03.6
01F5:  CLRF   36
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01F6:  BSF    03.5
01F7:  BCF    03.6
01F8:  BSF    08.4
01F9:  MOVLW  00
01FA:  BCF    03.5
01FB:  BTFSC  08.4
01FC:  MOVLW  01
01FD:  BSF    03.6
01FE:  IORWF  36,F
....................    n |= input(LCD_DATA5) << 1; 
01FF:  BSF    03.5
0200:  BCF    03.6
0201:  BSF    08.5
0202:  MOVLW  00
0203:  BCF    03.5
0204:  BTFSC  08.5
0205:  MOVLW  01
0206:  MOVWF  77
0207:  BCF    03.0
0208:  RLF    77,F
0209:  MOVF   77,W
020A:  BSF    03.6
020B:  IORWF  36,F
....................    n |= input(LCD_DATA6) << 2; 
020C:  BSF    03.5
020D:  BCF    03.6
020E:  BSF    08.6
020F:  MOVLW  00
0210:  BCF    03.5
0211:  BTFSC  08.6
0212:  MOVLW  01
0213:  MOVWF  77
0214:  RLF    77,F
0215:  RLF    77,F
0216:  MOVLW  FC
0217:  ANDWF  77,F
0218:  MOVF   77,W
0219:  BSF    03.6
021A:  IORWF  36,F
....................    n |= input(LCD_DATA7) << 3; 
021B:  BSF    03.5
021C:  BCF    03.6
021D:  BSF    08.7
021E:  MOVLW  00
021F:  BCF    03.5
0220:  BTFSC  08.7
0221:  MOVLW  01
0222:  MOVWF  77
0223:  RLF    77,F
0224:  RLF    77,F
0225:  RLF    77,F
0226:  MOVLW  F8
0227:  ANDWF  77,F
0228:  MOVF   77,W
0229:  BSF    03.6
022A:  IORWF  36,F
....................     
....................    return(n); 
022B:  MOVF   36,W
022C:  MOVWF  78
....................   #else 
022D:  BCF    03.6
022E:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
01B8:  BSF    03.6
01B9:  BTFSC  35.0
01BA:  GOTO   1BF
01BB:  BCF    03.6
01BC:  BCF    08.4
01BD:  GOTO   1C1
01BE:  BSF    03.6
01BF:  BCF    03.6
01C0:  BSF    08.4
01C1:  BSF    03.5
01C2:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
01C3:  BCF    03.5
01C4:  BSF    03.6
01C5:  BTFSC  35.1
01C6:  GOTO   1CB
01C7:  BCF    03.6
01C8:  BCF    08.5
01C9:  GOTO   1CD
01CA:  BSF    03.6
01CB:  BCF    03.6
01CC:  BSF    08.5
01CD:  BSF    03.5
01CE:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
01CF:  BCF    03.5
01D0:  BSF    03.6
01D1:  BTFSC  35.2
01D2:  GOTO   1D7
01D3:  BCF    03.6
01D4:  BCF    08.6
01D5:  GOTO   1D9
01D6:  BSF    03.6
01D7:  BCF    03.6
01D8:  BSF    08.6
01D9:  BSF    03.5
01DA:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01DB:  BCF    03.5
01DC:  BSF    03.6
01DD:  BTFSC  35.3
01DE:  GOTO   1E3
01DF:  BCF    03.6
01E0:  BCF    08.7
01E1:  GOTO   1E5
01E2:  BSF    03.6
01E3:  BCF    03.6
01E4:  BSF    08.7
01E5:  BSF    03.5
01E6:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01E7:  NOP
....................    lcd_output_enable(1); 
01E8:  BCF    03.5
01E9:  BSF    08.3
01EA:  BSF    03.5
01EB:  BCF    08.3
....................    delay_us(2); 
01EC:  GOTO   1ED
01ED:  GOTO   1EE
....................    lcd_output_enable(0); 
01EE:  BCF    03.5
01EF:  BCF    08.3
01F0:  BSF    03.5
01F1:  BCF    08.3
01F2:  BCF    03.5
01F3:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
022F:  BSF    03.5
0230:  BCF    08.3
....................    lcd_rs_tris(); 
0231:  BCF    08.1
....................    lcd_rw_tris(); 
0232:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0233:  BCF    03.5
0234:  BCF    08.1
0235:  BSF    03.5
0236:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
026A:  MOVF   78,W
026B:  MOVWF  34
026C:  BTFSS  34.7
026D:  GOTO   271
026E:  BSF    03.5
026F:  BCF    03.6
0270:  GOTO   237
....................    lcd_output_rs(address); 
0271:  MOVF   32,F
0272:  BTFSS  03.2
0273:  GOTO   278
0274:  BCF    03.6
0275:  BCF    08.1
0276:  GOTO   27A
0277:  BSF    03.6
0278:  BCF    03.6
0279:  BSF    08.1
027A:  BSF    03.5
027B:  BCF    08.1
....................    delay_cycles(1); 
027C:  NOP
....................    lcd_output_rw(0); 
027D:  BCF    03.5
027E:  BCF    08.2
027F:  BSF    03.5
0280:  BCF    08.2
....................    delay_cycles(1); 
0281:  NOP
....................    lcd_output_enable(0); 
0282:  BCF    03.5
0283:  BCF    08.3
0284:  BSF    03.5
0285:  BCF    08.3
....................    lcd_send_nibble(n >> 4); 
0286:  BCF    03.5
0287:  BSF    03.6
0288:  SWAPF  33,W
0289:  MOVWF  34
028A:  MOVLW  0F
028B:  ANDWF  34,F
028C:  MOVF   34,W
028D:  MOVWF  35
028E:  BCF    03.6
028F:  CALL   1B8
....................    lcd_send_nibble(n & 0xf); 
0290:  BSF    03.6
0291:  MOVF   33,W
0292:  ANDLW  0F
0293:  MOVWF  34
0294:  MOVWF  35
0295:  BCF    03.6
0296:  CALL   1B8
0297:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0298:  BSF    03.5
0299:  BCF    08.4
....................    output_drive(LCD_DATA5); 
029A:  BCF    08.5
....................    output_drive(LCD_DATA6); 
029B:  BCF    08.6
....................    output_drive(LCD_DATA7); 
029C:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
029D:  BCF    08.3
....................    lcd_rs_tris(); 
029E:  BCF    08.1
....................    lcd_rw_tris(); 
029F:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
02A0:  BCF    03.5
02A1:  BCF    08.1
02A2:  BSF    03.5
02A3:  BCF    08.1
....................    lcd_output_rw(0); 
02A4:  BCF    03.5
02A5:  BCF    08.2
02A6:  BSF    03.5
02A7:  BCF    08.2
....................    lcd_output_enable(0); 
02A8:  BCF    03.5
02A9:  BCF    08.3
02AA:  BSF    03.5
02AB:  BCF    08.3
....................      
....................    delay_ms(15); 
02AC:  MOVLW  0F
02AD:  BCF    03.5
02AE:  BSF    03.6
02AF:  MOVWF  2E
02B0:  BCF    03.6
02B1:  CALL   1A4
....................    for(i=1;i<=3;++i) 
02B2:  MOVLW  01
02B3:  BSF    03.5
02B4:  MOVWF  41
02B5:  MOVF   41,W
02B6:  SUBLW  03
02B7:  BTFSS  03.0
02B8:  GOTO   2C7
....................    { 
....................        lcd_send_nibble(3); 
02B9:  MOVLW  03
02BA:  BCF    03.5
02BB:  BSF    03.6
02BC:  MOVWF  35
02BD:  BCF    03.6
02BE:  CALL   1B8
....................        delay_ms(5); 
02BF:  MOVLW  05
02C0:  BSF    03.6
02C1:  MOVWF  2E
02C2:  BCF    03.6
02C3:  CALL   1A4
02C4:  BSF    03.5
02C5:  INCF   41,F
02C6:  GOTO   2B5
....................    } 
....................     
....................    lcd_send_nibble(2); 
02C7:  MOVLW  02
02C8:  BCF    03.5
02C9:  BSF    03.6
02CA:  MOVWF  35
02CB:  BCF    03.6
02CC:  CALL   1B8
....................    delay_ms(5); 
02CD:  MOVLW  05
02CE:  BSF    03.6
02CF:  MOVWF  2E
02D0:  BCF    03.6
02D1:  CALL   1A4
....................    for(i=0;i<=3;++i) 
02D2:  BSF    03.5
02D3:  CLRF   41
02D4:  MOVF   41,W
02D5:  SUBLW  03
02D6:  BTFSS  03.0
02D7:  GOTO   2EB
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02D8:  MOVF   41,W
02D9:  BCF    03.5
02DA:  CALL   041
02DB:  BSF    03.5
02DC:  MOVWF  42
02DD:  BCF    03.5
02DE:  BSF    03.6
02DF:  CLRF   32
02E0:  BSF    03.5
02E1:  BCF    03.6
02E2:  MOVF   42,W
02E3:  BCF    03.5
02E4:  BSF    03.6
02E5:  MOVWF  33
02E6:  BCF    03.6
02E7:  CALL   22F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02E8:  BSF    03.5
02E9:  INCF   41,F
02EA:  GOTO   2D4
02EB:  BCF    03.5
02EC:  RETURN
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0382:  BSF    03.6
0383:  DECFSZ 2F,W
0384:  GOTO   386
0385:  GOTO   389
....................       address=LCD_LINE_TWO; 
0386:  MOVLW  40
0387:  MOVWF  30
0388:  GOTO   38A
....................    else 
....................       address=0; 
0389:  CLRF   30
....................       
....................    address+=x-1; 
038A:  MOVLW  01
038B:  SUBWF  2E,W
038C:  ADDWF  30,F
....................    lcd_send_byte(0,0x80|address); 
038D:  MOVF   30,W
038E:  IORLW  80
038F:  MOVWF  31
0390:  CLRF   32
0391:  MOVF   31,W
0392:  MOVWF  33
0393:  BCF    03.6
0394:  CALL   22F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0395:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0396:  BSF    03.6
0397:  MOVF   2D,W
0398:  XORLW  07
0399:  BCF    03.6
039A:  BTFSC  03.2
039B:  GOTO   3A6
039C:  XORLW  0B
039D:  BTFSC  03.2
039E:  GOTO   3AD
039F:  XORLW  06
03A0:  BTFSC  03.2
03A1:  GOTO   3B9
03A2:  XORLW  02
03A3:  BTFSC  03.2
03A4:  GOTO   3C1
03A5:  GOTO   3C8
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03A6:  MOVLW  01
03A7:  BSF    03.6
03A8:  MOVWF  2E
03A9:  MOVWF  2F
03AA:  BCF    03.6
03AB:  CALL   382
03AC:  GOTO   3CF
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
03AD:  BSF    03.6
03AE:  CLRF   32
03AF:  MOVLW  01
03B0:  MOVWF  33
03B1:  BCF    03.6
03B2:  CALL   22F
....................                      delay_ms(2); 
03B3:  MOVLW  02
03B4:  BSF    03.6
03B5:  MOVWF  2E
03B6:  BCF    03.6
03B7:  CALL   1A4
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03B8:  GOTO   3CF
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03B9:  MOVLW  01
03BA:  BSF    03.6
03BB:  MOVWF  2E
03BC:  MOVLW  02
03BD:  MOVWF  2F
03BE:  BCF    03.6
03BF:  CALL   382
03C0:  GOTO   3CF
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03C1:  BSF    03.6
03C2:  CLRF   32
03C3:  MOVLW  10
03C4:  MOVWF  33
03C5:  BCF    03.6
03C6:  CALL   22F
03C7:  GOTO   3CF
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03C8:  MOVLW  01
03C9:  BSF    03.6
03CA:  MOVWF  32
03CB:  MOVF   2D,W
03CC:  MOVWF  33
03CD:  BCF    03.6
03CE:  CALL   22F
....................      #endif 
....................    } 
03CF:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define LED_PIN PIN_A0 
.................... #define BUZZER_PIN PIN_A1 
....................  
.................... #define BTN_SIGNAL PIN_B0 
.................... #define BTN_UPLOAD PIN_B1 
.................... #define BTN_DELETE PIN_B2 
.................... #define BTN_RESET PIN_B3 
.................... #define BTN_MODE PIN_B4 
....................  
.................... char morse_buffer[10]; 
.................... char text_buffer[21]; 
.................... int8 morse_index = 0; 
.................... int8 text_index = 0; 
....................  
.................... char rx_temp_buffer[40]; 
.................... char rx_display_buffer[25]; 
.................... int8 rx_temp_index = 0; 
.................... int1 rx_data_ready = 0; 
....................  
.................... volatile int16 press_counter = 0; 
.................... volatile int16 idle_counter = 0; 
.................... #define SLEEP_TIMEOUT 3000 
....................  
.................... int1 btn_prev_state = 0; 
.................... int1 update_needed = 0; 
....................  
.................... volatile int8 scroll_tick = 0; 
.................... int1 scroll_now = 0; 
.................... int8 scroll_pos = 0; 
....................  
.................... int1 app_mode = 0; 
....................  
.................... const char morse_tree[64] = { 
....................     0, 0, 'E', 'T', 'I', 'A', 'N', 'M', 'S', 'U', 'R', 'W', 'D', 'K', 'G', 'O', 
....................     'H', 'V', 'F', 0, 'L', 0, 'P', 'J', 'B', 'X', 'C', 'Y', 'Z', 'Q', 0, 0, 
....................     '5', '4', 0, '3', 0, 0, 0, '2', 0, 0, 0, 0, 0, 0, 0, '1', 
....................     '6', 0, 0, 0, 0, 0, 0, 0, '7', 0, 0, 0, '8', 0, '9', '0'}; 
....................  
.................... void wdt_delay_ms(int16 time) 
.................... { 
....................     int16 i; 
....................     for (i = 0; i < time; i++) 
*
0600:  BSF    03.6
0601:  CLRF   29
0602:  CLRF   28
0603:  MOVF   29,W
0604:  SUBWF  27,W
0605:  BTFSS  03.0
0606:  GOTO   617
0607:  BTFSS  03.2
0608:  GOTO   60D
0609:  MOVF   26,W
060A:  SUBWF  28,W
060B:  BTFSC  03.0
060C:  GOTO   617
....................     { 
....................         delay_ms(1); 
060D:  MOVLW  01
060E:  MOVWF  2E
060F:  BCF    03.6
0610:  CALL   1A4
....................         restart_wdt(); 
0611:  CLRWDT
0612:  BSF    03.6
0613:  INCF   28,F
0614:  BTFSC  03.2
0615:  INCF   29,F
0616:  GOTO   603
....................     } 
0617:  BCF    03.6
0618:  RETURN
.................... } 
....................  
.................... void save_text_to_eeprom() 
.................... { 
....................     int8 i; 
....................     write_eeprom(0, text_index); 
*
07B3:  MOVF   0B,W
07B4:  MOVWF  77
07B5:  BCF    0B.7
07B6:  BSF    03.6
07B7:  CLRF   0D
07B8:  BCF    03.6
07B9:  MOVF   4D,W
07BA:  BSF    03.6
07BB:  MOVWF  0C
07BC:  BSF    03.5
07BD:  BCF    0C.7
07BE:  BSF    0C.2
07BF:  MOVLW  55
07C0:  MOVWF  0D
07C1:  MOVLW  AA
07C2:  MOVWF  0D
07C3:  BSF    0C.1
07C4:  BTFSC  0C.1
07C5:  GOTO   7C4
07C6:  BCF    0C.2
07C7:  MOVF   77,W
07C8:  BCF    03.5
07C9:  BCF    03.6
07CA:  IORWF  0B,F
....................     for (i = 0; i < text_index; i++) 
07CB:  BSF    03.5
07CC:  CLRF   41
07CD:  BCF    03.5
07CE:  MOVF   4D,W
07CF:  BSF    03.5
07D0:  SUBWF  41,W
07D1:  BTFSC  03.0
07D2:  GOTO   7FE
....................     { 
....................         write_eeprom(i + 1, text_buffer[i]); 
07D3:  MOVLW  01
07D4:  ADDWF  41,W
07D5:  MOVWF  42
07D6:  MOVLW  37
07D7:  ADDWF  41,W
07D8:  MOVWF  04
07D9:  BCF    03.7
07DA:  MOVF   00,W
07DB:  MOVWF  43
07DC:  BCF    03.5
07DD:  MOVF   0B,W
07DE:  MOVWF  77
07DF:  BCF    0B.7
07E0:  BSF    03.5
07E1:  MOVF   42,W
07E2:  BCF    03.5
07E3:  BSF    03.6
07E4:  MOVWF  0D
07E5:  BSF    03.5
07E6:  BCF    03.6
07E7:  MOVF   43,W
07E8:  BCF    03.5
07E9:  BSF    03.6
07EA:  MOVWF  0C
07EB:  BSF    03.5
07EC:  BCF    0C.7
07ED:  BSF    0C.2
07EE:  MOVLW  55
07EF:  MOVWF  0D
07F0:  MOVLW  AA
07F1:  MOVWF  0D
07F2:  BSF    0C.1
07F3:  BTFSC  0C.1
07F4:  GOTO   7F3
07F5:  BCF    0C.2
07F6:  MOVF   77,W
07F7:  BCF    03.5
07F8:  BCF    03.6
07F9:  IORWF  0B,F
....................         restart_wdt(); 
07FA:  CLRWDT
07FB:  BSF    03.5
07FC:  INCF   41,F
07FD:  GOTO   7CD
....................     } 
07FE:  BCF    03.5
07FF:  RETURN
.................... } 
....................  
.................... void load_text_from_eeprom() 
.................... { 
....................     int8 i; 
....................     text_index = read_eeprom(0); 
*
02ED:  BSF    03.6
02EE:  CLRF   0D
02EF:  BSF    03.5
02F0:  BCF    0C.7
02F1:  BSF    0C.0
02F2:  BCF    03.5
02F3:  MOVF   0C,W
02F4:  BCF    03.6
02F5:  MOVWF  4D
....................     if (text_index > 20) 
02F6:  MOVF   4D,W
02F7:  SUBLW  14
02F8:  BTFSS  03.0
....................         text_index = 0; 
02F9:  CLRF   4D
....................     for (i = 0; i < text_index; i++) 
02FA:  BSF    03.5
02FB:  CLRF   41
02FC:  BCF    03.5
02FD:  MOVF   4D,W
02FE:  BSF    03.5
02FF:  SUBWF  41,W
0300:  BTFSC  03.0
0301:  GOTO   318
....................     { 
....................         text_buffer[i] = read_eeprom(i + 1); 
0302:  MOVLW  37
0303:  ADDWF  41,W
0304:  MOVWF  04
0305:  BCF    03.7
0306:  MOVLW  01
0307:  ADDWF  41,W
0308:  MOVWF  44
0309:  MOVF   44,W
030A:  BCF    03.5
030B:  BSF    03.6
030C:  MOVWF  0D
030D:  BSF    03.5
030E:  BCF    0C.7
030F:  BSF    0C.0
0310:  BCF    03.5
0311:  MOVF   0C,W
0312:  MOVWF  00
....................         restart_wdt(); 
0313:  CLRWDT
0314:  BSF    03.5
0315:  BCF    03.6
0316:  INCF   41,F
0317:  GOTO   2FC
....................     } 
....................     text_buffer[text_index] = '\0'; 
0318:  MOVLW  37
0319:  BCF    03.5
031A:  ADDWF  4D,W
031B:  MOVWF  04
031C:  BCF    03.7
031D:  CLRF   00
031E:  BSF    0A.3
031F:  BCF    0A.4
0320:  GOTO   05B (RETURN)
.................... } 
....................  
.................... void save_bt_to_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = strlen(rx_display_buffer); 
*
0674:  BSF    03.6
0675:  CLRF   2F
0676:  MOVLW  A0
0677:  MOVWF  2E
0678:  BCF    03.6
0679:  CALL   431
067A:  MOVF   78,W
067B:  BSF    03.5
067C:  MOVWF  42
....................     write_eeprom(50, len); 
067D:  BCF    03.5
067E:  MOVF   0B,W
067F:  MOVWF  77
0680:  BCF    0B.7
0681:  MOVLW  32
0682:  BSF    03.6
0683:  MOVWF  0D
0684:  BSF    03.5
0685:  BCF    03.6
0686:  MOVF   42,W
0687:  BCF    03.5
0688:  BSF    03.6
0689:  MOVWF  0C
068A:  BSF    03.5
068B:  BCF    0C.7
068C:  BSF    0C.2
068D:  MOVLW  55
068E:  MOVWF  0D
068F:  MOVLW  AA
0690:  MOVWF  0D
0691:  BSF    0C.1
0692:  BTFSC  0C.1
0693:  GOTO   692
0694:  BCF    0C.2
0695:  MOVF   77,W
0696:  BCF    03.5
0697:  BCF    03.6
0698:  IORWF  0B,F
....................     for (i = 0; i < len; i++) 
0699:  BSF    03.5
069A:  CLRF   41
069B:  MOVF   42,W
069C:  SUBWF  41,W
069D:  BTFSC  03.0
069E:  GOTO   6CA
....................     { 
....................         write_eeprom(51 + i, rx_display_buffer[i]); 
069F:  MOVLW  33
06A0:  ADDWF  41,W
06A1:  MOVWF  43
06A2:  MOVLW  A0
06A3:  ADDWF  41,W
06A4:  MOVWF  04
06A5:  BCF    03.7
06A6:  MOVF   00,W
06A7:  MOVWF  44
06A8:  BCF    03.5
06A9:  MOVF   0B,W
06AA:  MOVWF  77
06AB:  BCF    0B.7
06AC:  BSF    03.5
06AD:  MOVF   43,W
06AE:  BCF    03.5
06AF:  BSF    03.6
06B0:  MOVWF  0D
06B1:  BSF    03.5
06B2:  BCF    03.6
06B3:  MOVF   44,W
06B4:  BCF    03.5
06B5:  BSF    03.6
06B6:  MOVWF  0C
06B7:  BSF    03.5
06B8:  BCF    0C.7
06B9:  BSF    0C.2
06BA:  MOVLW  55
06BB:  MOVWF  0D
06BC:  MOVLW  AA
06BD:  MOVWF  0D
06BE:  BSF    0C.1
06BF:  BTFSC  0C.1
06C0:  GOTO   6BF
06C1:  BCF    0C.2
06C2:  MOVF   77,W
06C3:  BCF    03.5
06C4:  BCF    03.6
06C5:  IORWF  0B,F
....................         restart_wdt(); 
06C6:  CLRWDT
06C7:  BSF    03.5
06C8:  INCF   41,F
06C9:  GOTO   69B
....................     } 
06CA:  BCF    03.5
06CB:  BSF    0A.3
06CC:  BCF    0A.4
06CD:  GOTO   2AB (RETURN)
.................... } 
....................  
.................... void load_bt_from_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = read_eeprom(50); 
*
0321:  MOVLW  32
0322:  BSF    03.6
0323:  MOVWF  0D
0324:  BSF    03.5
0325:  BCF    0C.7
0326:  BSF    0C.0
0327:  BCF    03.5
0328:  MOVF   0C,W
0329:  BSF    03.5
032A:  BCF    03.6
032B:  MOVWF  42
....................     if (len > 20) 
032C:  MOVF   42,W
032D:  SUBLW  14
032E:  BTFSS  03.0
....................         len = 0; 
032F:  CLRF   42
....................  
....................     for (i = 0; i < len; i++) 
0330:  CLRF   41
0331:  MOVF   42,W
0332:  SUBWF  41,W
0333:  BTFSC  03.0
0334:  GOTO   34B
....................     { 
....................         rx_display_buffer[i] = read_eeprom(51 + i); 
0335:  MOVLW  A0
0336:  ADDWF  41,W
0337:  MOVWF  04
0338:  BCF    03.7
0339:  MOVLW  33
033A:  ADDWF  41,W
033B:  MOVWF  45
033C:  MOVF   45,W
033D:  BCF    03.5
033E:  BSF    03.6
033F:  MOVWF  0D
0340:  BSF    03.5
0341:  BCF    0C.7
0342:  BSF    0C.0
0343:  BCF    03.5
0344:  MOVF   0C,W
0345:  MOVWF  00
....................         restart_wdt(); 
0346:  CLRWDT
0347:  BSF    03.5
0348:  BCF    03.6
0349:  INCF   41,F
034A:  GOTO   331
....................     } 
....................     rx_display_buffer[len] = '\0'; 
034B:  MOVLW  A0
034C:  ADDWF  42,W
034D:  MOVWF  04
034E:  BCF    03.7
034F:  CLRF   00
0350:  BCF    03.5
0351:  BSF    0A.3
0352:  BCF    0A.4
0353:  GOTO   05E (RETURN)
.................... } 
....................  
.................... char decode_morse(char *code) 
*
0451:  MOVLW  01
0452:  BSF    03.6
0453:  MOVWF  2D
.................... { 
....................     int8 i, len; 
....................     int8 index = 1; 
....................     len = strlen(code); 
0454:  MOVF   2A,W
0455:  MOVWF  2F
0456:  MOVF   29,W
0457:  MOVWF  2E
0458:  BCF    03.6
0459:  CALL   431
045A:  MOVF   78,W
045B:  BSF    03.6
045C:  MOVWF  2C
....................     if (len == 0) 
045D:  MOVF   2C,F
045E:  BTFSS  03.2
045F:  GOTO   463
....................         return ' '; 
0460:  MOVLW  20
0461:  MOVWF  78
0462:  GOTO   48F
....................  
....................     for (i = 0; i < len; i++) 
0463:  CLRF   2B
0464:  MOVF   2C,W
0465:  SUBWF  2B,W
0466:  BTFSC  03.0
0467:  GOTO   47D
....................     { 
....................         index = index << 1; 
0468:  BCF    03.0
0469:  RLF    2D,F
....................         if (code[i] == '-') 
046A:  MOVF   2B,W
046B:  ADDWF  29,W
046C:  MOVWF  04
046D:  BCF    03.7
046E:  BTFSC  2A.0
046F:  BSF    03.7
0470:  MOVF   00,W
0471:  SUBLW  2D
0472:  BTFSC  03.2
....................             index |= 1; 
0473:  BSF    2D.0
....................         if (index >= 64) 
0474:  MOVF   2D,W
0475:  SUBLW  3F
0476:  BTFSC  03.0
0477:  GOTO   47B
....................             return '?'; 
0478:  MOVLW  3F
0479:  MOVWF  78
047A:  GOTO   48F
047B:  INCF   2B,F
047C:  GOTO   464
....................     } 
....................     if (morse_tree[index] == 0) 
047D:  MOVF   2D,W
047E:  BCF    03.6
047F:  CALL   049
0480:  XORLW  00
0481:  BTFSS  03.2
0482:  GOTO   488
....................         return '?'; 
0483:  MOVLW  3F
0484:  MOVWF  78
0485:  BSF    03.6
0486:  GOTO   48F
0487:  BCF    03.6
....................     return morse_tree[index]; 
0488:  BSF    03.6
0489:  MOVF   2D,W
048A:  BCF    03.6
048B:  CALL   049
048C:  MOVWF  78
048D:  MOVWF  78
048E:  BSF    03.6
048F:  BCF    03.6
0490:  RETURN
.................... } 
....................  
.................... void lcd_locate(int8 x, int8 y) 
.................... { 
....................     int8 address; 
....................     switch (y) 
*
0354:  BSF    03.6
0355:  MOVF   2A,W
0356:  XORLW  01
0357:  BCF    03.6
0358:  BTFSC  03.2
0359:  GOTO   364
035A:  XORLW  03
035B:  BTFSC  03.2
035C:  GOTO   367
035D:  XORLW  01
035E:  BTFSC  03.2
035F:  GOTO   36B
0360:  XORLW  07
0361:  BTFSC  03.2
0362:  GOTO   36F
0363:  GOTO   374
....................     { 
....................     case 1: 
....................         address = 0x00; 
0364:  BSF    03.6
0365:  CLRF   2B
....................         break; 
0366:  GOTO   376
....................     case 2: 
....................         address = 0x40; 
0367:  MOVLW  40
0368:  BSF    03.6
0369:  MOVWF  2B
....................         break; 
036A:  GOTO   376
....................     case 3: 
....................         address = 0x14; 
036B:  MOVLW  14
036C:  BSF    03.6
036D:  MOVWF  2B
....................         break; 
036E:  GOTO   376
....................     case 4: 
....................         address = 0x54; 
036F:  MOVLW  54
0370:  BSF    03.6
0371:  MOVWF  2B
....................         break; 
0372:  GOTO   376
0373:  BCF    03.6
....................     default: 
....................         address = 0x00; 
0374:  BSF    03.6
0375:  CLRF   2B
....................         break; 
....................     } 
....................     address += x - 1; 
0376:  MOVLW  01
0377:  SUBWF  29,W
0378:  ADDWF  2B,F
....................     lcd_send_byte(0, 0x80 | address); 
0379:  MOVF   2B,W
037A:  IORLW  80
037B:  MOVWF  2C
037C:  CLRF   32
037D:  MOVF   2C,W
037E:  MOVWF  33
037F:  BCF    03.6
0380:  CALL   22F
0381:  RETURN
.................... } 
....................  
.................... void update_scroll_line() 
*
0529:  MOVLW  04
052A:  BSF    03.5
052B:  MOVWF  44
.................... { 
....................     int8 len, i, current_char_idx; 
....................     int8 gap_size = 4; 
....................  
....................     if (rx_display_buffer[0] == '\0') 
052C:  MOVF   20,F
052D:  BTFSS  03.2
052E:  GOTO   540
....................     { 
....................         lcd_locate(1, 4); 
052F:  MOVLW  01
0530:  BCF    03.5
0531:  BSF    03.6
0532:  MOVWF  29
0533:  MOVLW  04
0534:  MOVWF  2A
0535:  BCF    03.6
0536:  CALL   354
....................         printf(lcd_putc, "                    "); 
0537:  MOVLW  B2
0538:  BSF    03.6
0539:  MOVWF  0D
053A:  MOVLW  00
053B:  MOVWF  0F
053C:  BCF    03.6
053D:  CALL   3D0
....................         return; 
053E:  GOTO   593
053F:  BSF    03.5
....................     } 
....................  
....................     len = strlen(rx_display_buffer); 
0540:  BCF    03.5
0541:  BSF    03.6
0542:  CLRF   2F
0543:  MOVLW  A0
0544:  MOVWF  2E
0545:  BCF    03.6
0546:  CALL   431
0547:  MOVF   78,W
0548:  BSF    03.5
0549:  MOVWF  41
....................     lcd_locate(1, 4); 
054A:  MOVLW  01
054B:  BCF    03.5
054C:  BSF    03.6
054D:  MOVWF  29
054E:  MOVLW  04
054F:  MOVWF  2A
0550:  BCF    03.6
0551:  CALL   354
....................  
....................     for (i = 0; i < 20; i++) 
0552:  BSF    03.5
0553:  CLRF   42
0554:  MOVF   42,W
0555:  SUBLW  13
0556:  BTFSS  03.0
0557:  GOTO   592
....................     { 
....................         current_char_idx = (scroll_pos + i) % (len + gap_size); 
0558:  MOVF   42,W
0559:  ADDWF  3B,W
055A:  MOVWF  45
055B:  MOVF   44,W
055C:  ADDWF  41,W
055D:  MOVWF  46
055E:  MOVF   45,W
055F:  MOVWF  47
0560:  MOVF   46,W
0561:  MOVWF  48
*
0576:  MOVF   77,W
0577:  MOVWF  43
....................         if (current_char_idx < len) 
0578:  MOVF   41,W
0579:  SUBWF  43,W
057A:  BTFSC  03.0
057B:  GOTO   589
....................             lcd_putc(rx_display_buffer[current_char_idx]); 
057C:  MOVLW  A0
057D:  ADDWF  43,W
057E:  MOVWF  04
057F:  BCF    03.7
0580:  MOVF   00,W
0581:  MOVWF  45
0582:  BCF    03.5
0583:  BSF    03.6
0584:  MOVWF  2D
0585:  BCF    03.6
0586:  CALL   396
0587:  GOTO   58F
0588:  BSF    03.5
....................         else 
....................             lcd_putc(' '); 
0589:  MOVLW  20
058A:  BCF    03.5
058B:  BSF    03.6
058C:  MOVWF  2D
058D:  BCF    03.6
058E:  CALL   396
058F:  BSF    03.5
0590:  INCF   42,F
0591:  GOTO   554
0592:  BCF    03.5
....................     } 
0593:  BSF    0A.3
0594:  BCF    0A.4
0595:  GOTO   0BE (RETURN)
.................... } 
....................  
.................... void update_lcd() 
.................... { 
....................     int8 i, len; 
....................     char preview_char; 
....................  
....................     lcd_locate(1, 1); 
*
0491:  MOVLW  01
0492:  BSF    03.6
0493:  MOVWF  29
0494:  MOVWF  2A
0495:  BCF    03.6
0496:  CALL   354
....................     if (app_mode == 0) 
0497:  BTFSC  7B.4
0498:  GOTO   4A1
....................         printf(lcd_putc, "MOD: MESAJ          "); 
0499:  MOVLW  BD
049A:  BSF    03.6
049B:  MOVWF  0D
049C:  MOVLW  00
049D:  MOVWF  0F
049E:  BCF    03.6
049F:  CALL   3D0
04A0:  GOTO   4A8
....................     else 
....................         printf(lcd_putc, "MOD: KOMUT          "); 
04A1:  MOVLW  C8
04A2:  BSF    03.6
04A3:  MOVWF  0D
04A4:  MOVLW  00
04A5:  MOVWF  0F
04A6:  BCF    03.6
04A7:  CALL   3D0
....................  
....................     lcd_locate(1, 2); 
04A8:  MOVLW  01
04A9:  BSF    03.6
04AA:  MOVWF  29
04AB:  MOVLW  02
04AC:  MOVWF  2A
04AD:  BCF    03.6
04AE:  CALL   354
....................     printf(lcd_putc, "%s", text_buffer); 
04AF:  MOVLW  37
04B0:  MOVWF  04
04B1:  BCF    03.7
04B2:  CALL   414
....................  
....................     if (morse_index > 0) 
04B3:  MOVF   4C,F
04B4:  BTFSC  03.2
04B5:  GOTO   4C9
....................     { 
....................         preview_char = decode_morse(morse_buffer); 
04B6:  BSF    03.6
04B7:  CLRF   2A
04B8:  MOVLW  2D
04B9:  MOVWF  29
04BA:  BCF    03.6
04BB:  CALL   451
04BC:  MOVF   78,W
04BD:  BSF    03.6
04BE:  MOVWF  28
....................         lcd_putc(preview_char); 
04BF:  MOVF   28,W
04C0:  MOVWF  2D
04C1:  BCF    03.6
04C2:  CALL   396
....................         lcd_putc('<'); 
04C3:  MOVLW  3C
04C4:  BSF    03.6
04C5:  MOVWF  2D
04C6:  BCF    03.6
04C7:  CALL   396
....................     } 
04C8:  GOTO   4D0
....................     else 
....................     { 
....................         lcd_putc("  "); 
04C9:  MOVLW  D3
04CA:  BSF    03.6
04CB:  MOVWF  0D
04CC:  MOVLW  00
04CD:  MOVWF  0F
04CE:  BCF    03.6
04CF:  CALL   3D0
....................     } 
....................  
....................     len = strlen(text_buffer) + (morse_index > 0 ? 2 : 0); 
04D0:  BSF    03.6
04D1:  CLRF   2F
04D2:  MOVLW  37
04D3:  MOVWF  2E
04D4:  BCF    03.6
04D5:  CALL   431
04D6:  MOVF   78,W
04D7:  BSF    03.6
04D8:  MOVWF  29
04D9:  BCF    03.6
04DA:  MOVF   4C,F
04DB:  BTFSC  03.2
04DC:  GOTO   4E0
04DD:  CLRF   7A
04DE:  MOVLW  02
04DF:  GOTO   4E2
04E0:  CLRF   7A
04E1:  MOVLW  00
04E2:  BSF    03.6
04E3:  ADDWF  29,W
04E4:  MOVWF  27
....................     for (i = len; i < 20; i++) 
04E5:  MOVF   27,W
04E6:  MOVWF  26
04E7:  MOVF   26,W
04E8:  SUBLW  13
04E9:  BTFSS  03.0
04EA:  GOTO   4F2
....................         lcd_putc(' '); 
04EB:  MOVLW  20
04EC:  MOVWF  2D
04ED:  BCF    03.6
04EE:  CALL   396
04EF:  BSF    03.6
04F0:  INCF   26,F
04F1:  GOTO   4E7
....................  
....................     lcd_locate(1, 3); 
04F2:  MOVLW  01
04F3:  MOVWF  29
04F4:  MOVLW  03
04F5:  MOVWF  2A
04F6:  BCF    03.6
04F7:  CALL   354
....................     printf(lcd_putc, "%s", morse_buffer); 
04F8:  MOVLW  2D
04F9:  MOVWF  04
04FA:  BCF    03.7
04FB:  CALL   414
....................     len = strlen(morse_buffer); 
04FC:  BSF    03.6
04FD:  CLRF   2F
04FE:  MOVLW  2D
04FF:  MOVWF  2E
0500:  BCF    03.6
0501:  CALL   431
0502:  MOVF   78,W
0503:  BSF    03.6
0504:  MOVWF  27
....................     for (i = len; i < 20; i++) 
0505:  MOVF   27,W
0506:  MOVWF  26
0507:  MOVF   26,W
0508:  SUBLW  13
0509:  BTFSS  03.0
050A:  GOTO   512
....................         lcd_putc(' '); 
050B:  MOVLW  20
050C:  MOVWF  2D
050D:  BCF    03.6
050E:  CALL   396
050F:  BSF    03.6
0510:  INCF   26,F
0511:  GOTO   507
....................  
....................     if (rx_display_buffer[0] == '\0') 
0512:  BSF    03.5
0513:  BCF    03.6
0514:  MOVF   20,F
0515:  BTFSS  03.2
0516:  GOTO   527
....................     { 
....................         lcd_locate(1, 4); 
0517:  MOVLW  01
0518:  BCF    03.5
0519:  BSF    03.6
051A:  MOVWF  29
051B:  MOVLW  04
051C:  MOVWF  2A
051D:  BCF    03.6
051E:  CALL   354
....................         printf(lcd_putc, "                    "); 
051F:  MOVLW  D5
0520:  BSF    03.6
0521:  MOVWF  0D
0522:  MOVLW  00
0523:  MOVWF  0F
0524:  BCF    03.6
0525:  CALL   3D0
0526:  BSF    03.5
....................     } 
0527:  BCF    03.5
0528:  RETURN
.................... } 
....................  
.................... void send_nmea_packet() 
*
0736:  BSF    03.5
0737:  CLRF   42
.................... { 
....................     char type_char; 
....................     int8 checksum = 0; 
....................     int8 i, len; 
....................     char char_to_send; 
....................  
....................     if (app_mode == 0) 
0738:  BTFSC  7B.4
0739:  GOTO   73D
....................         type_char = 'M'; 
073A:  MOVLW  4D
073B:  MOVWF  41
073C:  GOTO   73F
....................     else 
....................         type_char = 'K'; 
073D:  MOVLW  4B
073E:  MOVWF  41
....................  
....................     fprintf(BT_MODUL, "$%c,", type_char); 
073F:  MOVLW  24
0740:  BCF    03.5
0741:  BTFSS  0C.4
0742:  GOTO   741
0743:  MOVWF  19
0744:  BSF    03.5
0745:  MOVF   41,W
0746:  BCF    03.5
0747:  BTFSS  0C.4
0748:  GOTO   747
0749:  MOVWF  19
074A:  MOVLW  2C
074B:  BTFSS  0C.4
074C:  GOTO   74B
074D:  MOVWF  19
....................     checksum = type_char ^ ','; 
074E:  BSF    03.5
074F:  MOVF   41,W
0750:  XORLW  2C
0751:  MOVWF  42
....................  
....................     len = strlen(text_buffer); 
0752:  BCF    03.5
0753:  BSF    03.6
0754:  CLRF   2F
0755:  MOVLW  37
0756:  MOVWF  2E
0757:  BCF    03.6
0758:  CALL   431
0759:  MOVF   78,W
075A:  BSF    03.5
075B:  MOVWF  44
....................     for (i = 0; i < len; i++) 
075C:  CLRF   43
075D:  MOVF   44,W
075E:  SUBWF  43,W
075F:  BTFSC  03.0
0760:  GOTO   779
....................     { 
....................         char_to_send = text_buffer[i]; 
0761:  MOVLW  37
0762:  ADDWF  43,W
0763:  MOVWF  04
0764:  BCF    03.7
0765:  MOVF   00,W
0766:  MOVWF  45
....................         if (app_mode == 1 && char_to_send == ' ') 
0767:  BTFSS  7B.4
0768:  GOTO   76F
0769:  MOVF   45,W
076A:  SUBLW  20
076B:  BTFSS  03.2
076C:  GOTO   76F
....................             char_to_send = ','; 
076D:  MOVLW  2C
076E:  MOVWF  45
....................         fputc(char_to_send, BT_MODUL); 
076F:  MOVF   45,W
0770:  BCF    03.5
0771:  BTFSS  0C.4
0772:  GOTO   771
0773:  MOVWF  19
....................         checksum ^= char_to_send; 
0774:  BSF    03.5
0775:  MOVF   45,W
0776:  XORWF  42,F
0777:  INCF   43,F
0778:  GOTO   75D
....................     } 
....................     fprintf(BT_MODUL, "*%02X\r\n", checksum); 
0779:  MOVLW  2A
077A:  BCF    03.5
077B:  BTFSS  0C.4
077C:  GOTO   77B
077D:  MOVWF  19
077E:  BSF    03.5
077F:  MOVF   42,W
0780:  MOVWF  46
0781:  MOVLW  37
0782:  MOVWF  47
*
07A8:  MOVLW  0D
07A9:  BTFSS  0C.4
07AA:  GOTO   7A9
07AB:  MOVWF  19
07AC:  MOVLW  0A
07AD:  BTFSS  0C.4
07AE:  GOTO   7AD
07AF:  MOVWF  19
07B0:  BSF    0A.3
07B1:  BCF    0A.4
07B2:  GOTO   351 (RETURN)
.................... } 
....................  
.................... void full_wipe_reset() 
.................... { 
....................     lcd_putc('\f'); 
*
0619:  MOVLW  0C
061A:  BSF    03.6
061B:  MOVWF  2D
061C:  BCF    03.6
061D:  CALL   396
....................     lcd_locate(1, 1); 
061E:  MOVLW  01
061F:  BSF    03.6
0620:  MOVWF  29
0621:  MOVWF  2A
0622:  BCF    03.6
0623:  CALL   354
....................     printf(lcd_putc, "HEPSI SILINIYOR"); 
0624:  MOVLW  E0
0625:  BSF    03.6
0626:  MOVWF  0D
0627:  MOVLW  00
0628:  MOVWF  0F
0629:  BCF    03.6
062A:  CALL   3D0
....................     output_high(BUZZER_PIN); 
062B:  BSF    03.5
062C:  BCF    05.1
062D:  BCF    03.5
062E:  BSF    05.1
....................     wdt_delay_ms(500); 
062F:  MOVLW  01
0630:  BSF    03.6
0631:  MOVWF  27
0632:  MOVLW  F4
0633:  MOVWF  26
0634:  BCF    03.6
0635:  CALL   600
....................     output_low(BUZZER_PIN); 
0636:  BSF    03.5
0637:  BCF    05.1
0638:  BCF    03.5
0639:  BCF    05.1
....................  
....................     write_eeprom(0, 0); 
063A:  MOVF   0B,W
063B:  MOVWF  77
063C:  BCF    0B.7
063D:  BSF    03.6
063E:  CLRF   0D
063F:  CLRF   0C
0640:  BSF    03.5
0641:  BCF    0C.7
0642:  BSF    0C.2
0643:  MOVLW  55
0644:  MOVWF  0D
0645:  MOVLW  AA
0646:  MOVWF  0D
0647:  BSF    0C.1
0648:  BTFSC  0C.1
0649:  GOTO   648
064A:  BCF    0C.2
064B:  MOVF   77,W
064C:  BCF    03.5
064D:  BCF    03.6
064E:  IORWF  0B,F
....................     write_eeprom(50, 0); 
064F:  MOVF   0B,W
0650:  MOVWF  77
0651:  BCF    0B.7
0652:  MOVLW  32
0653:  BSF    03.6
0654:  MOVWF  0D
0655:  CLRF   0C
0656:  BSF    03.5
0657:  BCF    0C.7
0658:  BSF    0C.2
0659:  MOVLW  55
065A:  MOVWF  0D
065B:  MOVLW  AA
065C:  MOVWF  0D
065D:  BSF    0C.1
065E:  BTFSC  0C.1
065F:  GOTO   65E
0660:  BCF    0C.2
0661:  MOVF   77,W
0662:  BCF    03.5
0663:  BCF    03.6
0664:  IORWF  0B,F
....................  
....................     text_index = 0; 
0665:  CLRF   4D
....................     text_buffer[0] = '\0'; 
0666:  CLRF   37
....................  
....................     morse_index = 0; 
0667:  CLRF   4C
....................     morse_buffer[0] = '\0'; 
0668:  CLRF   2D
....................  
....................     rx_display_buffer[0] = '\0'; 
0669:  BSF    03.5
066A:  CLRF   20
....................     scroll_pos = 0; 
066B:  CLRF   3B
....................  
....................     lcd_putc('\f'); 
066C:  MOVLW  0C
066D:  BCF    03.5
066E:  BSF    03.6
066F:  MOVWF  2D
0670:  BCF    03.6
0671:  CALL   396
....................     update_lcd(); 
0672:  CALL   491
0673:  RETURN
.................... } 
....................  
.................... void process_incoming_nmea() 
*
08C2:  BCF    60.0
08C3:  MOVLW  FF
08C4:  MOVWF  62
.................... { 
....................     char *ptr_start; 
....................     char *ptr_end; 
....................     int8 len; 
....................     char packet_type; 
....................     char payload[25]; 
....................     int1 param_val = 0; 
....................     int8 i; 
....................     int8 comma_index = 255; 
....................  
....................     char cmd_rst[] = "rst"; 
08C5:  MOVLW  72
08C6:  MOVWF  63
08C7:  MOVLW  73
08C8:  MOVWF  64
08C9:  MOVLW  74
08CA:  MOVWF  65
08CB:  CLRF   66
....................     char cmd_led[] = "led_set"; 
08CC:  MOVLW  6C
08CD:  MOVWF  67
08CE:  MOVLW  65
08CF:  MOVWF  68
08D0:  MOVLW  64
08D1:  MOVWF  69
08D2:  MOVLW  5F
08D3:  MOVWF  6A
08D4:  MOVLW  73
08D5:  MOVWF  6B
08D6:  MOVLW  65
08D7:  MOVWF  6C
08D8:  MOVLW  74
08D9:  MOVWF  6D
08DA:  CLRF   6E
....................     char cmd_buz[] = "buzzer_set"; 
08DB:  MOVLW  62
08DC:  BCF    03.5
08DD:  BSF    03.6
08DE:  MOVWF  10
08DF:  MOVLW  75
08E0:  MOVWF  11
08E1:  MOVLW  7A
08E2:  MOVWF  12
08E3:  MOVWF  13
08E4:  MOVLW  65
08E5:  MOVWF  14
08E6:  MOVLW  72
08E7:  MOVWF  15
08E8:  MOVLW  5F
08E9:  MOVWF  16
08EA:  MOVLW  73
08EB:  MOVWF  17
08EC:  MOVLW  65
08ED:  MOVWF  18
08EE:  MOVLW  74
08EF:  MOVWF  19
08F0:  CLRF   1A
....................     char cmd_hrst[] = "hard_reset"; 
08F1:  MOVLW  68
08F2:  MOVWF  1B
08F3:  MOVLW  61
08F4:  MOVWF  1C
08F5:  MOVLW  72
08F6:  MOVWF  1D
08F7:  MOVLW  64
08F8:  MOVWF  1E
08F9:  MOVLW  5F
08FA:  MOVWF  1F
08FB:  MOVLW  72
08FC:  MOVWF  20
08FD:  MOVLW  65
08FE:  MOVWF  21
08FF:  MOVLW  73
0900:  MOVWF  22
0901:  MOVLW  65
0902:  MOVWF  23
0903:  MOVLW  74
0904:  MOVWF  24
0905:  CLRF   25
....................  
....................     if (rx_temp_buffer[0] == '$') 
0906:  BCF    03.6
0907:  MOVF   4E,W
0908:  SUBLW  24
0909:  BTFSS  03.2
090A:  GOTO   2A6
....................     { 
....................         packet_type = rx_temp_buffer[1]; 
090B:  MOVF   4F,W
090C:  BSF    03.5
090D:  MOVWF  46
....................         ptr_start = strchr(rx_temp_buffer, ','); 
090E:  BCF    03.5
090F:  BSF    03.6
0910:  CLRF   27
0911:  MOVLW  4E
0912:  MOVWF  26
0913:  MOVLW  2C
0914:  MOVWF  28
0915:  BCF    0A.3
0916:  BCF    03.6
0917:  CALL   596
0918:  BSF    0A.3
0919:  MOVF   79,W
091A:  BSF    03.5
091B:  MOVWF  42
091C:  MOVF   78,W
091D:  MOVWF  41
....................         ptr_end = strchr(rx_temp_buffer, '*'); 
091E:  BCF    03.5
091F:  BSF    03.6
0920:  CLRF   27
0921:  MOVLW  4E
0922:  MOVWF  26
0923:  MOVLW  2A
0924:  MOVWF  28
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   596
0928:  BSF    0A.3
0929:  MOVF   79,W
092A:  BSF    03.5
092B:  MOVWF  44
092C:  MOVF   78,W
092D:  MOVWF  43
....................  
....................         if (ptr_start != 0 && ptr_end != 0 && ptr_end > ptr_start) 
092E:  MOVF   41,F
092F:  BTFSS  03.2
0930:  GOTO   134
0931:  MOVF   42,F
0932:  BTFSC  03.2
0933:  GOTO   28B
0934:  MOVF   43,F
0935:  BTFSS  03.2
0936:  GOTO   13A
0937:  MOVF   44,F
0938:  BTFSC  03.2
0939:  GOTO   28B
093A:  MOVF   42,W
093B:  SUBWF  44,W
093C:  BTFSS  03.0
093D:  GOTO   28B
093E:  BTFSS  03.2
093F:  GOTO   144
0940:  MOVF   43,W
0941:  SUBWF  41,W
0942:  BTFSC  03.0
0943:  GOTO   28B
....................         { 
....................             len = (int8)(ptr_end - ptr_start) - 1; 
0944:  MOVF   41,W
0945:  SUBWF  43,W
0946:  MOVWF  77
0947:  MOVF   44,W
0948:  MOVWF  7A
0949:  MOVF   42,W
094A:  BTFSS  03.0
094B:  INCFSZ 42,W
094C:  SUBWF  7A,F
094D:  MOVF   77,W
094E:  ADDLW  FF
094F:  MOVWF  45
....................             if (len > 24) 
0950:  MOVF   45,W
0951:  SUBLW  18
0952:  BTFSC  03.0
0953:  GOTO   156
....................                 len = 24; 
0954:  MOVLW  18
0955:  MOVWF  45
....................  
....................             strncpy(payload, ptr_start + 1, len); 
0956:  MOVLW  01
0957:  ADDWF  41,W
0958:  BCF    03.5
0959:  BSF    03.6
095A:  MOVWF  26
095B:  BSF    03.5
095C:  BCF    03.6
095D:  MOVF   42,W
095E:  BCF    03.5
095F:  BSF    03.6
0960:  MOVWF  27
0961:  BTFSC  03.0
0962:  INCF   27,F
0963:  CLRF   29
0964:  MOVLW  C7
0965:  MOVWF  28
0966:  MOVF   27,W
0967:  MOVWF  2B
0968:  MOVF   26,W
0969:  MOVWF  2A
096A:  CLRF   2D
096B:  BSF    03.5
096C:  BCF    03.6
096D:  MOVF   45,W
096E:  BCF    03.5
096F:  BSF    03.6
0970:  MOVWF  2C
....................             payload[len] = '\0'; 
*
09C0:  MOVLW  C7
09C1:  BSF    03.5
09C2:  BCF    03.6
09C3:  ADDWF  45,W
09C4:  MOVWF  04
09C5:  BCF    03.7
09C6:  CLRF   00
....................  
....................             if (packet_type == 'M') 
09C7:  MOVF   46,W
09C8:  SUBLW  4D
09C9:  BTFSS  03.2
09CA:  GOTO   1EA
....................             { 
....................                 strcpy(rx_display_buffer, payload); 
09CB:  BCF    03.5
09CC:  BSF    03.6
09CD:  CLRF   29
09CE:  MOVLW  C7
09CF:  MOVWF  28
09D0:  CLRF   27
09D1:  MOVLW  A0
09D2:  MOVWF  26
09D3:  MOVF   28,W
09D4:  MOVWF  04
09D5:  BCF    03.7
09D6:  BTFSC  29.0
09D7:  BSF    03.7
09D8:  MOVF   00,W
09D9:  MOVWF  2A
09DA:  MOVF   26,W
09DB:  MOVWF  04
09DC:  BCF    03.7
09DD:  BTFSC  27.0
09DE:  BSF    03.7
09DF:  MOVF   2A,W
09E0:  MOVWF  00
09E1:  MOVF   00,F
09E2:  BTFSC  03.2
09E3:  GOTO   1E7
09E4:  INCF   26,F
09E5:  INCF   28,F
09E6:  GOTO   1D3
....................             } 
09E7:  GOTO   288
09E8:  BSF    03.5
09E9:  BCF    03.6
....................             else if (packet_type == 'K') 
09EA:  MOVF   46,W
09EB:  SUBLW  4B
09EC:  BTFSS  03.2
09ED:  GOTO   28A
....................             { 
....................                 for (i = 0; i < len; i++) 
09EE:  CLRF   61
09EF:  MOVF   45,W
09F0:  SUBWF  61,W
09F1:  BTFSC  03.0
09F2:  GOTO   200
....................                 { 
....................                     if (payload[i] == ',') 
09F3:  MOVLW  C7
09F4:  ADDWF  61,W
09F5:  MOVWF  04
09F6:  BCF    03.7
09F7:  MOVF   00,W
09F8:  SUBLW  2C
09F9:  BTFSS  03.2
09FA:  GOTO   1FE
....................                     { 
....................                         comma_index = i; 
09FB:  MOVF   61,W
09FC:  MOVWF  62
....................                         break; 
09FD:  GOTO   200
....................                     } 
09FE:  INCF   61,F
09FF:  GOTO   1EF
....................                 } 
....................  
....................                 if (comma_index != 255) 
0A00:  INCFSZ 62,W
0A01:  GOTO   203
0A02:  GOTO   211
....................                 { 
....................                     payload[comma_index] = '\0'; 
0A03:  MOVLW  C7
0A04:  ADDWF  62,W
0A05:  MOVWF  04
0A06:  BCF    03.7
0A07:  CLRF   00
....................                     if (payload[comma_index + 1] == '1') 
0A08:  MOVLW  01
0A09:  ADDWF  62,W
0A0A:  ADDLW  C7
0A0B:  MOVWF  04
0A0C:  BCF    03.7
0A0D:  MOVF   00,W
0A0E:  SUBLW  31
0A0F:  BTFSC  03.2
....................                         param_val = 1; 
0A10:  BSF    60.0
....................                 } 
....................  
....................                 if (strcmp(payload, cmd_rst) == 0) 
0A11:  BCF    03.5
0A12:  BSF    03.6
0A13:  CLRF   27
0A14:  MOVLW  C7
0A15:  MOVWF  26
0A16:  CLRF   29
0A17:  MOVLW  E3
0A18:  MOVWF  28
0A19:  BCF    0A.3
0A1A:  BCF    03.6
0A1B:  CALL   5BA
0A1C:  BSF    0A.3
0A1D:  MOVF   78,F
0A1E:  BTFSS  03.2
0A1F:  GOTO   223
....................                 { 
....................                     reset_cpu(); 
0A20:  CLRF   0A
0A21:  GOTO   000
....................                 } 
0A22:  GOTO   289
....................                 else if (strcmp(payload, cmd_led) == 0) 
0A23:  BSF    03.6
0A24:  CLRF   27
0A25:  MOVLW  C7
0A26:  MOVWF  26
0A27:  CLRF   29
0A28:  MOVLW  E7
0A29:  MOVWF  28
0A2A:  BCF    0A.3
0A2B:  BCF    03.6
0A2C:  CALL   5BA
0A2D:  BSF    0A.3
0A2E:  MOVF   78,F
0A2F:  BTFSS  03.2
0A30:  GOTO   240
....................                 { 
....................                     if (param_val) 
0A31:  BSF    03.5
0A32:  BTFSS  60.0
0A33:  GOTO   239
....................                         output_high(LED_PIN); 
0A34:  BCF    05.0
0A35:  BCF    03.5
0A36:  BSF    05.0
0A37:  GOTO   23C
0A38:  BSF    03.5
....................                     else 
....................                         output_low(LED_PIN); 
0A39:  BCF    05.0
0A3A:  BCF    03.5
0A3B:  BCF    05.0
....................                     rx_display_buffer[0] = '\0'; 
0A3C:  BSF    03.5
0A3D:  CLRF   20
....................                 } 
0A3E:  GOTO   28A
0A3F:  BCF    03.5
....................                 else if (strcmp(payload, cmd_buz) == 0) 
0A40:  BSF    03.6
0A41:  CLRF   27
0A42:  MOVLW  C7
0A43:  MOVWF  26
0A44:  MOVLW  01
0A45:  MOVWF  29
0A46:  MOVLW  10
0A47:  MOVWF  28
0A48:  BCF    0A.3
0A49:  BCF    03.6
0A4A:  CALL   5BA
0A4B:  BSF    0A.3
0A4C:  MOVF   78,F
0A4D:  BTFSS  03.2
0A4E:  GOTO   25E
....................                 { 
....................                     if (param_val) 
0A4F:  BSF    03.5
0A50:  BTFSS  60.0
0A51:  GOTO   257
....................                         output_high(BUZZER_PIN); 
0A52:  BCF    05.1
0A53:  BCF    03.5
0A54:  BSF    05.1
0A55:  GOTO   25A
0A56:  BSF    03.5
....................                     else 
....................                         output_low(BUZZER_PIN); 
0A57:  BCF    05.1
0A58:  BCF    03.5
0A59:  BCF    05.1
....................                     rx_display_buffer[0] = '\0'; 
0A5A:  BSF    03.5
0A5B:  CLRF   20
....................                 } 
0A5C:  GOTO   28A
0A5D:  BCF    03.5
....................                 else if (strcmp(payload, cmd_hrst) == 0) 
0A5E:  BSF    03.6
0A5F:  CLRF   27
0A60:  MOVLW  C7
0A61:  MOVWF  26
0A62:  MOVLW  01
0A63:  MOVWF  29
0A64:  MOVLW  1B
0A65:  MOVWF  28
0A66:  BCF    0A.3
0A67:  BCF    03.6
0A68:  CALL   5BA
0A69:  BSF    0A.3
0A6A:  MOVF   78,F
0A6B:  BTFSS  03.2
0A6C:  GOTO   273
....................                 { 
....................                     full_wipe_reset(); 
0A6D:  BCF    0A.3
0A6E:  CALL   619
0A6F:  BSF    0A.3
....................                     reset_cpu(); 
0A70:  CLRF   0A
0A71:  GOTO   000
....................                 } 
0A72:  GOTO   289
....................                 else 
....................                 { 
....................                     strcpy(rx_display_buffer, "TANIMSIZ KOMUT"); 
0A73:  BSF    03.6
0A74:  CLRF   26
0A75:  CLRF   27
0A76:  MOVLW  A0
0A77:  MOVWF  04
0A78:  BCF    03.7
0A79:  MOVF   26,W
0A7A:  ADDWF  04,F
0A7B:  MOVF   27,W
0A7C:  BCF    0A.3
0A7D:  BCF    03.6
0A7E:  CALL   08D
0A7F:  BSF    0A.3
0A80:  MOVWF  00
0A81:  IORLW  00
0A82:  BTFSC  03.2
0A83:  GOTO   289
0A84:  BSF    03.6
0A85:  INCF   27,F
0A86:  INCF   26,F
0A87:  GOTO   276
0A88:  BCF    03.6
0A89:  BSF    03.5
....................                 } 
....................             } 
....................         } 
0A8A:  GOTO   2A7
....................         else 
....................         { 
....................             if (packet_type == 'M') 
0A8B:  MOVF   46,W
0A8C:  SUBLW  4D
0A8D:  BTFSS  03.2
0A8E:  GOTO   2A7
....................                 strcpy(rx_display_buffer, "FORMAT HATASI"); 
0A8F:  BCF    03.5
0A90:  BSF    03.6
0A91:  CLRF   26
0A92:  CLRF   27
0A93:  MOVLW  A0
0A94:  MOVWF  04
0A95:  BCF    03.7
0A96:  MOVF   26,W
0A97:  ADDWF  04,F
0A98:  MOVF   27,W
0A99:  BCF    0A.3
0A9A:  BCF    03.6
0A9B:  CALL   0A0
0A9C:  BSF    0A.3
0A9D:  MOVWF  00
0A9E:  IORLW  00
0A9F:  BTFSC  03.2
0AA0:  GOTO   2A6
0AA1:  BSF    03.6
0AA2:  INCF   27,F
0AA3:  INCF   26,F
0AA4:  GOTO   293
0AA5:  BCF    03.6
0AA6:  BSF    03.5
....................         } 
....................     } 
....................     scroll_pos = 0; 
0AA7:  CLRF   3B
.................... } 
....................  
.................... void enter_sleep_mode() 
.................... { 
....................     lcd_putc('\f'); 
*
06CE:  MOVLW  0C
06CF:  BSF    03.6
06D0:  MOVWF  2D
06D1:  BCF    03.6
06D2:  CALL   396
....................     lcd_locate(1, 1); 
06D3:  MOVLW  01
06D4:  BSF    03.6
06D5:  MOVWF  29
06D6:  MOVWF  2A
06D7:  BCF    03.6
06D8:  CALL   354
....................     printf(lcd_putc, "UYKU MODU..."); 
06D9:  MOVLW  E8
06DA:  BSF    03.6
06DB:  MOVWF  0D
06DC:  MOVLW  00
06DD:  MOVWF  0F
06DE:  BCF    03.6
06DF:  CALL   3D0
....................     wdt_delay_ms(500); 
06E0:  MOVLW  01
06E1:  BSF    03.6
06E2:  MOVWF  27
06E3:  MOVLW  F4
06E4:  MOVWF  26
06E5:  BCF    03.6
06E6:  CALL   600
....................     lcd_send_byte(0, 0x08); 
06E7:  BSF    03.6
06E8:  CLRF   32
06E9:  MOVLW  08
06EA:  MOVWF  33
06EB:  BCF    03.6
06EC:  CALL   22F
....................  
....................     output_low(LED_PIN); 
06ED:  BSF    03.5
06EE:  BCF    05.0
06EF:  BCF    03.5
06F0:  BCF    05.0
....................     output_low(BUZZER_PIN); 
06F1:  BSF    03.5
06F2:  BCF    05.1
06F3:  BCF    03.5
06F4:  BCF    05.1
....................  
....................     while (TRUE) 
....................     { 
....................         restart_wdt(); 
06F5:  CLRWDT
....................         sleep(); 
06F6:  SLEEP
....................  
....................         if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_MODE)) 
06F7:  BSF    03.5
06F8:  BSF    06.0
06F9:  BCF    03.5
06FA:  BTFSS  06.0
06FB:  GOTO   710
06FC:  BSF    03.5
06FD:  BSF    06.1
06FE:  BCF    03.5
06FF:  BTFSS  06.1
0700:  GOTO   710
0701:  BSF    03.5
0702:  BSF    06.2
0703:  BCF    03.5
0704:  BTFSS  06.2
0705:  GOTO   710
0706:  BSF    03.5
0707:  BSF    06.3
0708:  BCF    03.5
0709:  BTFSS  06.3
070A:  GOTO   710
070B:  BSF    03.5
070C:  BSF    06.4
070D:  BCF    03.5
070E:  BTFSC  06.4
070F:  GOTO   72E
....................         { 
....................             delay_ms(20); 
0710:  MOVLW  14
0711:  BSF    03.6
0712:  MOVWF  2E
0713:  BCF    03.6
0714:  CALL   1A4
....................             if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_MODE)) 
0715:  BSF    03.5
0716:  BSF    06.0
0717:  BCF    03.5
0718:  BTFSS  06.0
0719:  GOTO   72D
071A:  BSF    03.5
071B:  BSF    06.1
071C:  BCF    03.5
071D:  BTFSS  06.1
071E:  GOTO   72D
071F:  BSF    03.5
0720:  BSF    06.2
0721:  BCF    03.5
0722:  BTFSS  06.2
0723:  GOTO   72D
0724:  BSF    03.5
0725:  BSF    06.3
0726:  BCF    03.5
0727:  BTFSS  06.3
0728:  GOTO   72D
0729:  BSF    03.5
072A:  BSF    06.4
072B:  BCF    03.5
072C:  BTFSS  06.4
....................             { 
....................                 break; 
072D:  GOTO   72F
....................             } 
....................         } 
072E:  GOTO   6F5
....................     } 
....................  
....................     lcd_init(); 
072F:  CALL   298
....................     update_lcd(); 
0730:  CALL   491
....................     idle_counter = 0; 
0731:  BSF    03.5
0732:  CLRF   3A
0733:  CLRF   39
0734:  BCF    03.5
0735:  RETURN
.................... } 
....................  
.................... #INT_RDA 
.................... void serial_isr() 
.................... { 
....................     char incoming; 
....................     if (kbhit(BT_MODUL)) 
*
00EF:  BTFSS  0C.5
00F0:  GOTO   115
....................     { 
....................         incoming = fgetc(BT_MODUL); 
00F1:  BTFSS  0C.5
00F2:  GOTO   0F1
00F3:  MOVF   1A,W
00F4:  BSF    03.6
00F5:  MOVWF  38
....................  
....................         if (incoming == '$') 
00F6:  MOVF   38,W
00F7:  SUBLW  24
00F8:  BTFSC  03.2
....................         { 
....................             rx_temp_index = 0; 
00F9:  CLRF   76
....................         } 
....................         if (incoming == '\n' || incoming == '\r') 
00FA:  MOVF   38,W
00FB:  SUBLW  0A
00FC:  BTFSC  03.2
00FD:  GOTO   102
00FE:  MOVF   38,W
00FF:  SUBLW  0D
0100:  BTFSS  03.2
0101:  GOTO   109
....................         { 
....................             rx_temp_buffer[rx_temp_index] = '\0'; 
0102:  MOVLW  4E
0103:  ADDWF  76,W
0104:  MOVWF  04
0105:  BCF    03.7
0106:  CLRF   00
....................             rx_data_ready = 1; 
0107:  BSF    7B.0
....................         } 
0108:  GOTO   114
....................         else 
....................         { 
....................             if (rx_temp_index < 38) 
0109:  MOVF   76,W
010A:  SUBLW  25
010B:  BTFSS  03.0
010C:  GOTO   114
....................             { 
....................                 rx_temp_buffer[rx_temp_index] = incoming; 
010D:  MOVLW  4E
010E:  ADDWF  76,W
010F:  MOVWF  04
0110:  BCF    03.7
0111:  MOVF   38,W
0112:  MOVWF  00
....................                 rx_temp_index++; 
0113:  INCF   76,F
0114:  BCF    03.6
....................             } 
....................         } 
....................     } 
.................... } 
....................  
0115:  BCF    0C.5
0116:  BCF    0A.3
0117:  BCF    0A.4
0118:  GOTO   027
.................... #INT_TIMER1 
.................... void timer1_isr() 
.................... { 
....................     set_timer1(63036); 
0119:  CLRF   0E
011A:  MOVLW  F6
011B:  MOVWF  0F
011C:  MOVLW  3C
011D:  MOVWF  0E
....................     if (idle_counter < 32000) 
011E:  BSF    03.5
011F:  MOVF   3A,W
0120:  SUBLW  7C
0121:  BTFSS  03.0
0122:  GOTO   126
....................         idle_counter++; 
0123:  INCF   39,F
0124:  BTFSC  03.2
0125:  INCF   3A,F
....................  
....................     int1 btn_current = !input(BTN_SIGNAL); 
0126:  BSF    06.0
0127:  BCF    03.5
0128:  BSF    03.6
0129:  BCF    38.0
012A:  BCF    03.6
012B:  BTFSC  06.0
012C:  GOTO   130
012D:  BSF    03.6
012E:  BSF    38.0
012F:  BCF    03.6
....................  
....................     if (btn_current) 
0130:  BSF    03.6
0131:  BTFSS  38.0
0132:  GOTO   143
....................     { 
....................         idle_counter = 0; 
0133:  BSF    03.5
0134:  BCF    03.6
0135:  CLRF   3A
0136:  CLRF   39
....................         press_counter++; 
0137:  INCF   7C,F
0138:  BTFSC  03.2
0139:  INCF   7D,F
....................         output_high(LED_PIN); 
013A:  BCF    05.0
013B:  BCF    03.5
013C:  BSF    05.0
....................         output_high(BUZZER_PIN); 
013D:  BSF    03.5
013E:  BCF    05.1
013F:  BCF    03.5
0140:  BSF    05.1
....................     } 
0141:  GOTO   181
0142:  BSF    03.6
....................     else 
....................     { 
....................         output_low(LED_PIN); 
0143:  BSF    03.5
0144:  BCF    03.6
0145:  BCF    05.0
0146:  BCF    03.5
0147:  BCF    05.0
....................         output_low(BUZZER_PIN); 
0148:  BSF    03.5
0149:  BCF    05.1
014A:  BCF    03.5
014B:  BCF    05.1
....................         if (btn_prev_state == 1) 
014C:  BTFSS  7B.1
014D:  GOTO   181
....................         { 
....................             idle_counter = 0; 
014E:  BSF    03.5
014F:  CLRF   3A
0150:  CLRF   39
....................             if (press_counter > 2) 
0151:  MOVF   7D,F
0152:  BTFSS  03.2
0153:  GOTO   158
0154:  MOVF   7C,W
0155:  SUBLW  02
0156:  BTFSC  03.0
0157:  GOTO   17E
....................             { 
....................                 if (press_counter < 30) 
0158:  MOVF   7D,F
0159:  BTFSS  03.2
015A:  GOTO   169
015B:  MOVF   7C,W
015C:  SUBLW  1D
015D:  BTFSS  03.0
015E:  GOTO   169
....................                     morse_buffer[morse_index++] = '.'; 
015F:  BCF    03.5
0160:  MOVF   4C,W
0161:  INCF   4C,F
0162:  ADDLW  2D
0163:  MOVWF  04
0164:  BCF    03.7
0165:  MOVLW  2E
0166:  MOVWF  00
0167:  GOTO   171
0168:  BSF    03.5
....................                 else 
....................                     morse_buffer[morse_index++] = '-'; 
0169:  BCF    03.5
016A:  MOVF   4C,W
016B:  INCF   4C,F
016C:  ADDLW  2D
016D:  MOVWF  04
016E:  BCF    03.7
016F:  MOVLW  2D
0170:  MOVWF  00
....................  
....................                 if (morse_index > 9) 
0171:  MOVF   4C,W
0172:  SUBLW  09
0173:  BTFSC  03.0
0174:  GOTO   177
....................                     morse_index = 9; 
0175:  MOVLW  09
0176:  MOVWF  4C
....................  
....................                 morse_buffer[morse_index] = '\0'; 
0177:  MOVLW  2D
0178:  ADDWF  4C,W
0179:  MOVWF  04
017A:  BCF    03.7
017B:  CLRF   00
....................                 update_needed = 1; 
017C:  BSF    7B.2
017D:  BSF    03.5
....................             } 
....................             press_counter = 0; 
017E:  CLRF   7D
017F:  CLRF   7C
0180:  BCF    03.5
....................         } 
....................     } 
....................     btn_prev_state = btn_current; 
0181:  BCF    7B.1
0182:  BSF    03.6
0183:  BTFSC  38.0
0184:  BSF    7B.1
.................... } 
....................  
0185:  BCF    03.6
0186:  BCF    0C.0
0187:  BCF    0A.3
0188:  BCF    0A.4
0189:  GOTO   027
.................... #INT_TIMER0 
.................... void timer0_isr() 
.................... { 
....................     scroll_tick++; 
018A:  INCF   7E,F
....................     if (scroll_tick > 60) 
018B:  MOVF   7E,W
018C:  SUBLW  3C
018D:  BTFSC  03.0
018E:  GOTO   191
....................     { 
....................         scroll_tick = 0; 
018F:  CLRF   7E
....................         scroll_now = 1; 
0190:  BSF    7B.3
....................     } 
0191:  BCF    0B.2
0192:  BCF    0A.3
0193:  BCF    0A.4
0194:  GOTO   027
.................... } 
....................  
.................... void main() 
*
0800:  MOVLW  71
0801:  BSF    03.5
0802:  MOVWF  0F
0803:  MOVF   0F,W
0804:  BSF    03.6
0805:  BCF    07.3
0806:  MOVLW  0C
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  A2
080A:  MOVWF  18
080B:  MOVLW  90
080C:  BCF    03.5
080D:  MOVWF  18
080E:  CLRF   4C
080F:  CLRF   4D
0810:  CLRF   76
0811:  BCF    7B.0
0812:  CLRF   7D
0813:  CLRF   7C
0814:  BSF    03.5
0815:  CLRF   3A
0816:  CLRF   39
0817:  BCF    7B.1
0818:  BCF    7B.2
0819:  CLRF   7E
081A:  BCF    7B.3
081B:  CLRF   3B
081C:  BCF    7B.4
081D:  BSF    03.6
081E:  MOVF   09,W
081F:  ANDLW  C0
0820:  MOVWF  09
0821:  BCF    03.6
0822:  BCF    1F.4
0823:  BCF    1F.5
0824:  MOVLW  00
0825:  BSF    03.6
0826:  MOVWF  08
0827:  BCF    03.5
0828:  CLRF   07
0829:  CLRF   08
082A:  CLRF   09
082B:  BCF    03.7
082C:  MOVLW  1F
082D:  ANDWF  03,F
.................... { 
....................     setup_oscillator(OSC_8MHZ); 
*
0831:  MOVLW  71
0832:  BSF    03.5
0833:  MOVWF  0F
0834:  MOVF   0F,W
....................  
....................     setup_wdt(WDT_OFF); 
0835:  BCF    03.5
0836:  BSF    03.6
0837:  BCF    05.0
....................  
....................     set_tris_b(0xFF); 
0838:  MOVLW  FF
0839:  BSF    03.5
083A:  BCF    03.6
083B:  MOVWF  06
....................     port_b_pullups(TRUE); 
083C:  MOVLW  01
083D:  MOVWF  15
083E:  BCF    01.7
....................     output_drive(LED_PIN); 
083F:  BCF    05.0
....................     output_drive(BUZZER_PIN); 
0840:  BCF    05.1
....................  
....................     output_high(BUZZER_PIN); 
0841:  BCF    05.1
0842:  BCF    03.5
0843:  BSF    05.1
....................     delay_ms(50); 
0844:  MOVLW  32
0845:  BSF    03.6
0846:  MOVWF  2E
0847:  BCF    0A.3
0848:  BCF    03.6
0849:  CALL   1A4
084A:  BSF    0A.3
....................     output_low(BUZZER_PIN); 
084B:  BSF    03.5
084C:  BCF    05.1
084D:  BCF    03.5
084E:  BCF    05.1
....................  
....................     lcd_init(); 
084F:  BCF    0A.3
0850:  CALL   298
0851:  BSF    0A.3
....................     delay_ms(100); 
0852:  MOVLW  64
0853:  BSF    03.6
0854:  MOVWF  2E
0855:  BCF    0A.3
0856:  BCF    03.6
0857:  CALL   1A4
0858:  BSF    0A.3
....................  
....................     load_text_from_eeprom(); 
0859:  BCF    0A.3
085A:  GOTO   2ED
085B:  BSF    0A.3
....................     load_bt_from_eeprom(); 
085C:  BCF    0A.3
085D:  GOTO   321
085E:  BSF    0A.3
....................  
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
085F:  MOVLW  35
0860:  MOVWF  10
....................     set_timer1(63036); 
0861:  CLRF   0E
0862:  MOVLW  F6
0863:  MOVWF  0F
0864:  MOVLW  3C
0865:  MOVWF  0E
....................     setup_timer_0(T0_INTERNAL | T0_DIV_256); 
0866:  BSF    03.5
0867:  MOVF   01,W
0868:  ANDLW  C0
0869:  IORLW  07
086A:  MOVWF  01
....................  
....................     enable_interrupts(INT_TIMER1); 
086B:  BSF    0C.0
....................     enable_interrupts(INT_TIMER0); 
086C:  BCF    03.5
086D:  BSF    0B.5
....................     enable_interrupts(INT_RDA); 
086E:  BSF    03.5
086F:  BSF    0C.5
....................     enable_interrupts(GLOBAL); 
0870:  MOVLW  C0
0871:  BCF    03.5
0872:  IORWF  0B,F
....................  
....................     lcd_locate(1, 1); 
0873:  MOVLW  01
0874:  BSF    03.6
0875:  MOVWF  29
0876:  MOVWF  2A
0877:  BCF    0A.3
0878:  BCF    03.6
0879:  CALL   354
087A:  BSF    0A.3
....................     printf(lcd_putc, "Mors Telgraf"); 
087B:  MOVLW  95
087C:  BSF    03.6
087D:  MOVWF  0D
087E:  MOVLW  01
087F:  MOVWF  0F
0880:  BCF    0A.3
0881:  BCF    03.6
0882:  CALL   3D0
0883:  BSF    0A.3
....................     delay_ms(1000); 
0884:  MOVLW  04
0885:  BSF    03.5
0886:  MOVWF  41
0887:  MOVLW  FA
0888:  BCF    03.5
0889:  BSF    03.6
088A:  MOVWF  2E
088B:  BCF    0A.3
088C:  BCF    03.6
088D:  CALL   1A4
088E:  BSF    0A.3
088F:  BSF    03.5
0890:  DECFSZ 41,F
0891:  GOTO   087
....................  
....................     lcd_putc('\f'); 
0892:  MOVLW  0C
0893:  BCF    03.5
0894:  BSF    03.6
0895:  MOVWF  2D
0896:  BCF    0A.3
0897:  BCF    03.6
0898:  CALL   396
0899:  BSF    0A.3
....................     update_lcd(); 
089A:  BCF    0A.3
089B:  CALL   491
089C:  BSF    0A.3
....................  
....................     setup_wdt(WDT_2304MS); 
089D:  MOVLW  09
089E:  BSF    03.6
089F:  MOVWF  05
08A0:  MOVLW  0F
08A1:  MOVWF  77
08A2:  BCF    03.6
08A3:  CLRF   01
08A4:  MOVLW  81
08A5:  MOVWF  04
08A6:  BCF    03.7
08A7:  MOVF   00,W
08A8:  ANDLW  F0
08A9:  IORLW  07
08AA:  MOVWF  00
08AB:  CLRWDT
08AC:  MOVF   00,W
08AD:  ANDLW  F7
08AE:  BTFSC  77.3
08AF:  ANDLW  F0
08B0:  IORWF  77,W
08B1:  MOVWF  00
....................  
....................     while (TRUE) 
....................     { 
....................         restart_wdt(); 
08B2:  CLRWDT
....................  
....................         if (scroll_now) 
08B3:  BTFSS  7B.3
08B4:  GOTO   0BF
....................         { 
....................             scroll_now = 0; 
08B5:  BCF    7B.3
....................             if (rx_display_buffer[0] != '\0') 
08B6:  BSF    03.5
08B7:  MOVF   20,F
08B8:  BTFSC  03.2
08B9:  GOTO   0C0
....................             { 
....................                 scroll_pos++; 
08BA:  INCF   3B,F
....................                 update_scroll_line(); 
08BB:  BCF    0A.3
08BC:  BCF    03.5
08BD:  GOTO   529
08BE:  BSF    0A.3
08BF:  BSF    03.5
....................             } 
....................         } 
....................  
....................         if (rx_data_ready) 
08C0:  BTFSS  7B.0
08C1:  GOTO   2B3
....................         { 
....................             process_incoming_nmea(); 
....................             save_bt_to_eeprom(); 
*
0AA8:  BCF    0A.3
0AA9:  BCF    03.5
0AAA:  GOTO   674
0AAB:  BSF    0A.3
....................             rx_data_ready = 0; 
0AAC:  BCF    7B.0
....................             update_lcd(); 
0AAD:  BCF    0A.3
0AAE:  CALL   491
0AAF:  BSF    0A.3
....................             idle_counter = 0; 
0AB0:  BSF    03.5
0AB1:  CLRF   3A
0AB2:  CLRF   39
....................         } 
....................  
....................         if (idle_counter > SLEEP_TIMEOUT) 
0AB3:  MOVF   3A,W
0AB4:  SUBLW  0A
0AB5:  BTFSC  03.0
0AB6:  GOTO   2C3
0AB7:  XORLW  FF
0AB8:  BTFSS  03.2
0AB9:  GOTO   2BE
0ABA:  MOVF   39,W
0ABB:  SUBLW  B8
0ABC:  BTFSC  03.0
0ABD:  GOTO   2C3
....................         { 
....................             enter_sleep_mode(); 
0ABE:  BCF    0A.3
0ABF:  BCF    03.5
0AC0:  CALL   6CE
0AC1:  BSF    0A.3
0AC2:  BSF    03.5
....................         } 
....................  
....................         if (update_needed) 
0AC3:  BTFSS  7B.2
0AC4:  GOTO   2CB
....................         { 
....................             update_lcd(); 
0AC5:  BCF    0A.3
0AC6:  BCF    03.5
0AC7:  CALL   491
0AC8:  BSF    0A.3
....................             update_needed = 0; 
0AC9:  BCF    7B.2
0ACA:  BSF    03.5
....................         } 
....................  
....................         if (!input(BTN_MODE) && !input(BTN_RESET)) 
0ACB:  BSF    06.4
0ACC:  BCF    03.5
0ACD:  BTFSC  06.4
0ACE:  GOTO   2F4
0ACF:  BSF    03.5
0AD0:  BSF    06.3
0AD1:  BCF    03.5
0AD2:  BTFSC  06.3
0AD3:  GOTO   2F4
....................         { 
....................             delay_ms(50); 
0AD4:  MOVLW  32
0AD5:  BSF    03.6
0AD6:  MOVWF  2E
0AD7:  BCF    0A.3
0AD8:  BCF    03.6
0AD9:  CALL   1A4
0ADA:  BSF    0A.3
....................             if (!input(BTN_MODE) && !input(BTN_RESET)) 
0ADB:  BSF    03.5
0ADC:  BSF    06.4
0ADD:  BCF    03.5
0ADE:  BTFSC  06.4
0ADF:  GOTO   2F4
0AE0:  BSF    03.5
0AE1:  BSF    06.3
0AE2:  BCF    03.5
0AE3:  BTFSC  06.3
0AE4:  GOTO   2F4
....................             { 
....................                 enter_sleep_mode(); 
0AE5:  BCF    0A.3
0AE6:  CALL   6CE
0AE7:  BSF    0A.3
....................                 while (!input(BTN_MODE) || !input(BTN_RESET)) 
0AE8:  BSF    03.5
0AE9:  BSF    06.4
0AEA:  BCF    03.5
0AEB:  BTFSS  06.4
0AEC:  GOTO   2F2
0AED:  BSF    03.5
0AEE:  BSF    06.3
0AEF:  BCF    03.5
0AF0:  BTFSC  06.3
0AF1:  GOTO   2F4
....................                     restart_wdt(); 
0AF2:  CLRWDT
0AF3:  GOTO   2E8
....................             } 
....................         } 
....................  
....................         if (!input(BTN_MODE) && input(BTN_RESET)) 
0AF4:  BSF    03.5
0AF5:  BSF    06.4
0AF6:  BCF    03.5
0AF7:  BTFSC  06.4
0AF8:  GOTO   31A
0AF9:  BSF    03.5
0AFA:  BSF    06.3
0AFB:  BCF    03.5
0AFC:  BTFSS  06.3
0AFD:  GOTO   31A
....................         { 
....................             idle_counter = 0; 
0AFE:  BSF    03.5
0AFF:  CLRF   3A
0B00:  CLRF   39
....................             delay_ms(50); 
0B01:  MOVLW  32
0B02:  BCF    03.5
0B03:  BSF    03.6
0B04:  MOVWF  2E
0B05:  BCF    0A.3
0B06:  BCF    03.6
0B07:  CALL   1A4
0B08:  BSF    0A.3
....................             if (!input(BTN_MODE)) 
0B09:  BSF    03.5
0B0A:  BSF    06.4
0B0B:  BCF    03.5
0B0C:  BTFSC  06.4
0B0D:  GOTO   31A
....................             { 
....................                 app_mode = !app_mode; 
0B0E:  MOVLW  10
0B0F:  XORWF  7B,F
....................                 update_lcd(); 
0B10:  BCF    0A.3
0B11:  CALL   491
0B12:  BSF    0A.3
....................                 while (!input(BTN_MODE)) 
0B13:  BSF    03.5
0B14:  BSF    06.4
0B15:  BCF    03.5
0B16:  BTFSC  06.4
0B17:  GOTO   31A
....................                     restart_wdt(); 
0B18:  CLRWDT
0B19:  GOTO   313
....................             } 
....................         } 
....................  
....................         if (!input(BTN_UPLOAD)) 
0B1A:  BSF    03.5
0B1B:  BSF    06.1
0B1C:  BCF    03.5
0B1D:  BTFSC  06.1
0B1E:  GOTO   3D6
....................         { 
....................             idle_counter = 0; 
0B1F:  BSF    03.5
0B20:  CLRF   3A
0B21:  CLRF   39
....................             int16 hold_counter = 0; 
0B22:  CLRF   3D
0B23:  CLRF   3C
....................  
....................             while (!input(BTN_UPLOAD) && hold_counter < 50) 
0B24:  BSF    06.1
0B25:  BCF    03.5
0B26:  BTFSC  06.1
0B27:  GOTO   343
0B28:  BSF    03.5
0B29:  MOVF   3D,F
0B2A:  BTFSC  03.2
0B2B:  GOTO   32E
0B2C:  BCF    03.5
0B2D:  GOTO   343
0B2E:  MOVF   3C,W
0B2F:  SUBLW  31
0B30:  BTFSC  03.0
0B31:  GOTO   334
0B32:  BCF    03.5
0B33:  GOTO   343
....................             { 
....................                 delay_ms(10); 
0B34:  MOVLW  0A
0B35:  BCF    03.5
0B36:  BSF    03.6
0B37:  MOVWF  2E
0B38:  BCF    0A.3
0B39:  BCF    03.6
0B3A:  CALL   1A4
0B3B:  BSF    0A.3
....................                 restart_wdt(); 
0B3C:  CLRWDT
....................                 hold_counter++; 
0B3D:  BSF    03.5
0B3E:  INCF   3C,F
0B3F:  BTFSC  03.2
0B40:  INCF   3D,F
0B41:  GOTO   324
0B42:  BCF    03.5
....................             } 
....................  
....................             if (hold_counter >= 50) 
0B43:  BSF    03.5
0B44:  MOVF   3D,F
0B45:  BTFSS  03.2
0B46:  GOTO   34B
0B47:  MOVF   3C,W
0B48:  SUBLW  31
0B49:  BTFSC  03.0
0B4A:  GOTO   39D
....................             { 
....................                 if (text_index > 0) 
0B4B:  BCF    03.5
0B4C:  MOVF   4D,F
0B4D:  BTFSC  03.2
0B4E:  GOTO   362
....................                 { 
....................                     send_nmea_packet(); 
0B4F:  BCF    0A.3
0B50:  GOTO   736
0B51:  BSF    0A.3
....................                     output_high(BUZZER_PIN); 
0B52:  BSF    03.5
0B53:  BCF    05.1
0B54:  BCF    03.5
0B55:  BSF    05.1
....................                     wdt_delay_ms(100); 
0B56:  BSF    03.6
0B57:  CLRF   27
0B58:  MOVLW  64
0B59:  MOVWF  26
0B5A:  BCF    0A.3
0B5B:  BCF    03.6
0B5C:  CALL   600
0B5D:  BSF    0A.3
....................                     output_low(BUZZER_PIN); 
0B5E:  BSF    03.5
0B5F:  BCF    05.1
0B60:  BCF    03.5
0B61:  BCF    05.1
....................                 } 
....................                 while (!input(BTN_UPLOAD)) 
0B62:  BSF    03.5
0B63:  BSF    06.1
0B64:  BCF    03.5
0B65:  BTFSC  06.1
0B66:  GOTO   369
....................                     restart_wdt(); 
0B67:  CLRWDT
0B68:  GOTO   362
....................  
....................                 text_index = 0; 
0B69:  CLRF   4D
....................                 text_buffer[0] = '\0'; 
0B6A:  CLRF   37
....................                 morse_index = 0; 
0B6B:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0B6C:  CLRF   2D
....................                 save_text_to_eeprom(); 
0B6D:  BCF    0A.3
0B6E:  CALL   7B3
0B6F:  BSF    0A.3
....................  
....................                 lcd_putc('\f'); 
0B70:  MOVLW  0C
0B71:  BSF    03.6
0B72:  MOVWF  2D
0B73:  BCF    0A.3
0B74:  BCF    03.6
0B75:  CALL   396
0B76:  BSF    0A.3
....................                 lcd_locate(1, 1); 
0B77:  MOVLW  01
0B78:  BSF    03.6
0B79:  MOVWF  29
0B7A:  MOVWF  2A
0B7B:  BCF    0A.3
0B7C:  BCF    03.6
0B7D:  CALL   354
0B7E:  BSF    0A.3
....................                 printf(lcd_putc, "VERI GONDERILDI"); 
0B7F:  MOVLW  9C
0B80:  BSF    03.6
0B81:  MOVWF  0D
0B82:  MOVLW  01
0B83:  MOVWF  0F
0B84:  BCF    0A.3
0B85:  BCF    03.6
0B86:  CALL   3D0
0B87:  BSF    0A.3
....................                 wdt_delay_ms(1000); 
0B88:  MOVLW  03
0B89:  BSF    03.6
0B8A:  MOVWF  27
0B8B:  MOVLW  E8
0B8C:  MOVWF  26
0B8D:  BCF    0A.3
0B8E:  BCF    03.6
0B8F:  CALL   600
0B90:  BSF    0A.3
....................                 lcd_putc('\f'); 
0B91:  MOVLW  0C
0B92:  BSF    03.6
0B93:  MOVWF  2D
0B94:  BCF    0A.3
0B95:  BCF    03.6
0B96:  CALL   396
0B97:  BSF    0A.3
....................                 update_lcd(); 
0B98:  BCF    0A.3
0B99:  CALL   491
0B9A:  BSF    0A.3
....................             } 
0B9B:  GOTO   3D6
0B9C:  BSF    03.5
....................             else 
....................             { 
....................                 while (!input(BTN_UPLOAD)) 
0B9D:  BSF    06.1
0B9E:  BCF    03.5
0B9F:  BTFSC  06.1
0BA0:  GOTO   3A5
....................                     restart_wdt(); 
0BA1:  CLRWDT
0BA2:  BSF    03.5
0BA3:  GOTO   39D
0BA4:  BCF    03.5
....................                 if (morse_index > 0) 
0BA5:  MOVF   4C,F
0BA6:  BTFSC  03.2
0BA7:  GOTO   3D6
....................                 { 
....................                     char final_char = decode_morse(morse_buffer); 
0BA8:  BSF    03.6
0BA9:  CLRF   2A
0BAA:  MOVLW  2D
0BAB:  MOVWF  29
0BAC:  BCF    0A.3
0BAD:  BCF    03.6
0BAE:  CALL   451
0BAF:  BSF    0A.3
0BB0:  MOVF   78,W
0BB1:  BSF    03.5
0BB2:  MOVWF  3E
....................                     if (text_index < 20 && final_char != '?') 
0BB3:  BCF    03.5
0BB4:  MOVF   4D,W
0BB5:  SUBLW  13
0BB6:  BTFSS  03.0
0BB7:  GOTO   3D1
0BB8:  BSF    03.5
0BB9:  MOVF   3E,W
0BBA:  SUBLW  3F
0BBB:  BTFSS  03.2
0BBC:  GOTO   3BF
0BBD:  BCF    03.5
0BBE:  GOTO   3D1
....................                     { 
....................                         text_buffer[text_index++] = final_char; 
0BBF:  BCF    03.5
0BC0:  MOVF   4D,W
0BC1:  INCF   4D,F
0BC2:  ADDLW  37
0BC3:  MOVWF  04
0BC4:  BCF    03.7
0BC5:  BSF    03.5
0BC6:  MOVF   3E,W
0BC7:  MOVWF  00
....................                         text_buffer[text_index] = '\0'; 
0BC8:  MOVLW  37
0BC9:  BCF    03.5
0BCA:  ADDWF  4D,W
0BCB:  MOVWF  04
0BCC:  BCF    03.7
0BCD:  CLRF   00
....................                         save_text_to_eeprom(); 
0BCE:  BCF    0A.3
0BCF:  CALL   7B3
0BD0:  BSF    0A.3
....................                     } 
....................                     morse_index = 0; 
0BD1:  CLRF   4C
....................                     morse_buffer[0] = '\0'; 
0BD2:  CLRF   2D
....................                     update_lcd(); 
0BD3:  BCF    0A.3
0BD4:  CALL   491
0BD5:  BSF    0A.3
....................                 } 
....................             } 
....................         } 
....................  
....................         if (!input(BTN_DELETE)) 
0BD6:  BSF    03.5
0BD7:  BSF    06.2
0BD8:  BCF    03.5
0BD9:  BTFSC  06.2
0BDA:  GOTO   40B
....................         { 
....................             delay_ms(20); 
0BDB:  MOVLW  14
0BDC:  BSF    03.6
0BDD:  MOVWF  2E
0BDE:  BCF    0A.3
0BDF:  BCF    03.6
0BE0:  CALL   1A4
0BE1:  BSF    0A.3
....................             if (!input(BTN_DELETE)) 
0BE2:  BSF    03.5
0BE3:  BSF    06.2
0BE4:  BCF    03.5
0BE5:  BTFSC  06.2
0BE6:  GOTO   40B
....................             { 
....................                 idle_counter = 0; 
0BE7:  BSF    03.5
0BE8:  CLRF   3A
0BE9:  CLRF   39
....................                 if (morse_index > 0) 
0BEA:  BCF    03.5
0BEB:  MOVF   4C,F
0BEC:  BTFSC  03.2
0BED:  GOTO   3F5
....................                     morse_buffer[--morse_index] = '\0'; 
0BEE:  DECF   4C,F
0BEF:  MOVLW  2D
0BF0:  ADDWF  4C,W
0BF1:  MOVWF  04
0BF2:  BCF    03.7
0BF3:  CLRF   00
0BF4:  GOTO   401
....................                 else if (text_index > 0) 
0BF5:  MOVF   4D,F
0BF6:  BTFSC  03.2
0BF7:  GOTO   401
....................                 { 
....................                     text_buffer[--text_index] = '\0'; 
0BF8:  DECF   4D,F
0BF9:  MOVLW  37
0BFA:  ADDWF  4D,W
0BFB:  MOVWF  04
0BFC:  BCF    03.7
0BFD:  CLRF   00
....................                     save_text_to_eeprom(); 
0BFE:  BCF    0A.3
0BFF:  CALL   7B3
0C00:  BSF    0A.3
....................                 } 
....................                 update_lcd(); 
0C01:  BCF    0A.3
0C02:  CALL   491
0C03:  BSF    0A.3
....................                 while (!input(BTN_DELETE)) 
0C04:  BSF    03.5
0C05:  BSF    06.2
0C06:  BCF    03.5
0C07:  BTFSC  06.2
0C08:  GOTO   40B
....................                     restart_wdt(); 
0C09:  CLRWDT
0C0A:  GOTO   404
....................             } 
....................         } 
....................  
....................         if (!input(BTN_RESET) && input(BTN_MODE)) 
0C0B:  BSF    03.5
0C0C:  BSF    06.3
0C0D:  BCF    03.5
0C0E:  BTFSC  06.3
0C0F:  GOTO   45E
0C10:  BSF    03.5
0C11:  BSF    06.4
0C12:  BCF    03.5
0C13:  BTFSS  06.4
0C14:  GOTO   45E
....................         { 
....................             idle_counter = 0; 
0C15:  BSF    03.5
0C16:  CLRF   3A
0C17:  CLRF   39
....................             int16 reset_hold = 0; 
0C18:  CLRF   40
0C19:  CLRF   3F
....................  
....................             while (!input(BTN_RESET)) 
0C1A:  BSF    06.3
0C1B:  BCF    03.5
0C1C:  BTFSC  06.3
0C1D:  GOTO   440
....................             { 
....................                 delay_ms(10); 
0C1E:  MOVLW  0A
0C1F:  BSF    03.6
0C20:  MOVWF  2E
0C21:  BCF    0A.3
0C22:  BCF    03.6
0C23:  CALL   1A4
0C24:  BSF    0A.3
....................                 restart_wdt(); 
0C25:  CLRWDT
....................                 reset_hold++; 
0C26:  BSF    03.5
0C27:  INCF   3F,F
0C28:  BTFSC  03.2
0C29:  INCF   40,F
....................  
....................                 if (reset_hold > 200) 
0C2A:  MOVF   40,F
0C2B:  BTFSS  03.2
0C2C:  GOTO   431
0C2D:  MOVF   3F,W
0C2E:  SUBLW  C8
0C2F:  BTFSC  03.0
0C30:  GOTO   43E
....................                 { 
....................                     full_wipe_reset(); 
0C31:  BCF    0A.3
0C32:  BCF    03.5
0C33:  CALL   619
0C34:  BSF    0A.3
....................                     while (!input(BTN_RESET)) 
0C35:  BSF    03.5
0C36:  BSF    06.3
0C37:  BCF    03.5
0C38:  BTFSC  06.3
0C39:  GOTO   43C
....................                         restart_wdt(); 
0C3A:  CLRWDT
0C3B:  GOTO   435
....................                     break; 
0C3C:  GOTO   440
0C3D:  BSF    03.5
....................                 } 
0C3E:  GOTO   41A
0C3F:  BCF    03.5
....................             } 
....................  
....................             if (reset_hold > 5 && reset_hold <= 200) 
0C40:  BSF    03.5
0C41:  MOVF   40,F
0C42:  BTFSS  03.2
0C43:  GOTO   448
0C44:  MOVF   3F,W
0C45:  SUBLW  05
0C46:  BTFSC  03.0
0C47:  GOTO   45F
0C48:  MOVF   40,F
0C49:  BTFSS  03.2
0C4A:  GOTO   45F
0C4B:  MOVF   3F,W
0C4C:  SUBLW  C8
0C4D:  BTFSS  03.0
0C4E:  GOTO   45F
....................             { 
....................                 text_index = 0; 
0C4F:  BCF    03.5
0C50:  CLRF   4D
....................                 text_buffer[0] = '\0'; 
0C51:  CLRF   37
....................                 morse_index = 0; 
0C52:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0C53:  CLRF   2D
....................                 update_lcd(); 
0C54:  BCF    0A.3
0C55:  CALL   491
0C56:  BSF    0A.3
....................                 while (!input(BTN_RESET)) 
0C57:  BSF    03.5
0C58:  BSF    06.3
0C59:  BCF    03.5
0C5A:  BTFSC  06.3
0C5B:  GOTO   45E
....................                     restart_wdt(); 
0C5C:  CLRWDT
0C5D:  GOTO   457
0C5E:  BSF    03.5
....................             } 
....................         } 
0C5F:  BCF    03.5
0C60:  GOTO   0B2
....................     } 
.................... } 
0C61:  SLEEP

Configuration Fuses:
   Word  1: 2CC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
