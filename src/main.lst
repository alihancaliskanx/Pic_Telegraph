CCS PCM C Compiler, Version 5.007, 61971               19-Ara-25 19:18

               Filename:   C:\Users\Alihan\Desktop\DERS\Pic_Telegraph\src\main.lst

               ROM used:   2241 words (27%)
                           Largest free fragment is 2048
               RAM used:   111 (30%) at main() level
                           137 (37%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   038
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.0
0020:  GOTO   023
0021:  BTFSC  0C.0
0022:  GOTO   03B
0023:  BTFSS  0B.5
0024:  GOTO   027
0025:  BTFSC  0B.2
0026:  GOTO   03E
0027:  MOVF   22,W
0028:  MOVWF  04
0029:  MOVF   23,W
002A:  MOVWF  77
002B:  MOVF   24,W
002C:  MOVWF  78
002D:  MOVF   25,W
002E:  MOVWF  79
002F:  MOVF   26,W
0030:  MOVWF  7A
0031:  MOVF   20,W
0032:  MOVWF  0A
0033:  SWAPF  21,W
0034:  MOVWF  03
0035:  SWAPF  7F,F
0036:  SWAPF  7F,W
0037:  RETFIE
0038:  BCF    0A.3
0039:  BCF    0A.4
003A:  GOTO   09C
003B:  BCF    0A.3
003C:  BCF    0A.4
003D:  GOTO   0EB
003E:  BCF    0A.3
003F:  BCF    0A.4
0040:  GOTO   14F
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
0041:  BCF    0A.0
0042:  BCF    0A.1
0043:  BCF    0A.2
0044:  ADDWF  02,F
0045:  RETLW  28
0046:  RETLW  0C
0047:  RETLW  01
0048:  RETLW  06
0049:  BCF    0A.0
004A:  BCF    0A.1
004B:  BCF    0A.2
004C:  ADDWF  02,F
004D:  RETLW  00
004E:  RETLW  00
004F:  RETLW  45
0050:  RETLW  54
0051:  RETLW  49
0052:  RETLW  41
0053:  RETLW  4E
0054:  RETLW  4D
0055:  RETLW  53
0056:  RETLW  55
0057:  RETLW  52
0058:  RETLW  57
0059:  RETLW  44
005A:  RETLW  4B
005B:  RETLW  47
005C:  RETLW  4F
005D:  RETLW  48
005E:  RETLW  56
005F:  RETLW  46
0060:  RETLW  00
0061:  RETLW  4C
0062:  RETLW  00
0063:  RETLW  50
0064:  RETLW  4A
0065:  RETLW  42
0066:  RETLW  58
0067:  RETLW  43
0068:  RETLW  59
0069:  RETLW  5A
006A:  RETLW  51
006B:  RETLW  00
006C:  RETLW  00
006D:  RETLW  35
006E:  RETLW  34
006F:  RETLW  00
0070:  RETLW  33
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  00
0074:  RETLW  32
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  00
007B:  RETLW  00
007C:  RETLW  31
007D:  RETLW  36
007E:  RETLW  00
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  00
0082:  RETLW  00
0083:  RETLW  00
0084:  RETLW  00
0085:  RETLW  37
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  00
0089:  RETLW  38
008A:  RETLW  00
008B:  RETLW  39
008C:  RETLW  30
008D:  DATA 20,10
008E:  DATA 00,00
008F:  DATA D5,2C
0090:  DATA CB,2A
0091:  DATA A0,26
0092:  DATA 4F,22
0093:  DATA 55,17
0094:  DATA 2E,17
0095:  DATA 00,01
0096:  DATA CD,27
0097:  DATA 44,1D
0098:  DATA A0,2C
0099:  DATA 41,2D
009A:  DATA C9,26
009B:  DATA 00,00
*
015A:  DATA CD,37
015B:  DATA F2,39
015C:  DATA 20,2A
015D:  DATA 65,36
015E:  DATA 67,39
015F:  DATA 61,33
0160:  DATA 00,01
0161:  DATA CD,27
0162:  DATA 44,1D
0163:  DATA A0,2C
0164:  DATA 41,2D
0165:  DATA C9,26
0166:  DATA 00,01
0167:  DATA D6,22
0168:  DATA D2,24
0169:  DATA A0,23
016A:  DATA 4F,27
016B:  DATA C4,22
016C:  DATA D2,24
016D:  DATA 4C,22
016E:  DATA 49,00
016F:  DATA CD,27
0170:  DATA 44,1D
0171:  DATA A0,2C
0172:  DATA 41,2D
0173:  DATA C9,26
0174:  DATA 00,01
0175:  DATA C6,27
0176:  DATA D2,26
0177:  DATA 41,2A
0178:  DATA A0,20
0179:  DATA D4,24
017A:  DATA CC,24
017B:  DATA D9,27
017C:  DATA D2,10
017D:  DATA 00,01
017E:  DATA CD,27
017F:  DATA 44,1D
0180:  DATA A0,2C
0181:  DATA 41,2D
0182:  DATA C9,26
0183:  DATA 00,00
*
038D:  MOVF   0B,W
038E:  BSF    03.5
038F:  MOVWF  40
0390:  BCF    03.5
0391:  BCF    0B.7
0392:  BSF    03.5
0393:  BSF    03.6
0394:  BSF    0C.7
0395:  BSF    0C.0
0396:  NOP
0397:  NOP
0398:  BCF    03.5
0399:  MOVF   0C,W
039A:  ANDLW  7F
039B:  BTFSC  03.2
039C:  GOTO   3EA
039D:  BSF    03.5
039E:  BCF    03.6
039F:  MOVWF  41
03A0:  BCF    03.5
03A1:  BSF    03.6
03A2:  MOVF   0D,W
03A3:  BSF    03.5
03A4:  BCF    03.6
03A5:  MOVWF  42
03A6:  BCF    03.5
03A7:  BSF    03.6
03A8:  MOVF   0F,W
03A9:  BSF    03.5
03AA:  BCF    03.6
03AB:  MOVWF  43
03AC:  MOVF   41,W
03AD:  MOVWF  44
03AE:  BCF    03.5
03AF:  CALL   353
03B0:  BSF    03.5
03B1:  MOVF   42,W
03B2:  BCF    03.5
03B3:  BSF    03.6
03B4:  MOVWF  0D
03B5:  BSF    03.5
03B6:  BCF    03.6
03B7:  MOVF   43,W
03B8:  BCF    03.5
03B9:  BSF    03.6
03BA:  MOVWF  0F
03BB:  BSF    03.5
03BC:  BSF    0C.7
03BD:  BSF    0C.0
03BE:  NOP
03BF:  NOP
03C0:  BCF    03.5
03C1:  RLF    0C,W
03C2:  RLF    0E,W
03C3:  ANDLW  7F
03C4:  BTFSC  03.2
03C5:  GOTO   3EA
03C6:  BSF    03.5
03C7:  BCF    03.6
03C8:  MOVWF  41
03C9:  BCF    03.5
03CA:  BSF    03.6
03CB:  MOVF   0D,W
03CC:  BSF    03.5
03CD:  BCF    03.6
03CE:  MOVWF  42
03CF:  BCF    03.5
03D0:  BSF    03.6
03D1:  MOVF   0F,W
03D2:  BSF    03.5
03D3:  BCF    03.6
03D4:  MOVWF  43
03D5:  MOVF   41,W
03D6:  MOVWF  44
03D7:  BCF    03.5
03D8:  CALL   353
03D9:  BSF    03.5
03DA:  MOVF   42,W
03DB:  BCF    03.5
03DC:  BSF    03.6
03DD:  MOVWF  0D
03DE:  BSF    03.5
03DF:  BCF    03.6
03E0:  MOVF   43,W
03E1:  BCF    03.5
03E2:  BSF    03.6
03E3:  MOVWF  0F
03E4:  INCF   0D,F
03E5:  BTFSC  03.2
03E6:  INCF   0F,F
03E7:  BCF    03.6
03E8:  GOTO   392
03E9:  BSF    03.6
03EA:  BSF    03.5
03EB:  BCF    03.6
03EC:  BTFSS  40.7
03ED:  GOTO   3F1
03EE:  BCF    03.5
03EF:  BSF    0B.7
03F0:  BSF    03.5
03F1:  BCF    03.5
03F2:  RETURN
03F3:  MOVF   00,F
03F4:  BTFSC  03.2
03F5:  GOTO   40F
03F6:  BSF    03.5
03F7:  CLRF   41
03F8:  MOVF   04,W
03F9:  MOVWF  40
03FA:  BCF    41.0
03FB:  BTFSC  03.7
03FC:  BSF    41.0
03FD:  MOVF   00,W
03FE:  MOVWF  44
03FF:  BCF    03.5
0400:  CALL   353
0401:  BSF    03.5
0402:  MOVF   40,W
0403:  MOVWF  04
0404:  BCF    03.7
0405:  BTFSC  41.0
0406:  BSF    03.7
0407:  INCF   04,F
0408:  BTFSS  03.2
0409:  GOTO   40D
040A:  BCF    03.5
040B:  INCF   05,F
040C:  BSF    03.5
040D:  BCF    03.5
040E:  GOTO   3F3
040F:  RETURN
*
0502:  MOVF   44,W
0503:  CLRF   78
0504:  SUBWF  43,W
0505:  BTFSC  03.0
0506:  GOTO   50A
0507:  MOVF   43,W
0508:  MOVWF  77
0509:  GOTO   516
050A:  CLRF   77
050B:  MOVLW  08
050C:  MOVWF  45
050D:  RLF    43,F
050E:  RLF    77,F
050F:  MOVF   44,W
0510:  SUBWF  77,W
0511:  BTFSC  03.0
0512:  MOVWF  77
0513:  RLF    78,F
0514:  DECFSZ 45,F
0515:  GOTO   50D
*
05E3:  MOVF   00,F
05E4:  BTFSC  03.2
05E5:  GOTO   600
05E6:  BSF    03.5
05E7:  CLRF   3E
05E8:  MOVF   04,W
05E9:  MOVWF  3D
05EA:  BCF    3E.0
05EB:  BTFSC  03.7
05EC:  BSF    3E.0
05ED:  MOVF   00,W
05EE:  BCF    03.5
05EF:  BTFSS  0C.4
05F0:  GOTO   5EF
05F1:  MOVWF  19
05F2:  BSF    03.5
05F3:  MOVF   3D,W
05F4:  MOVWF  04
05F5:  BCF    03.7
05F6:  BTFSC  3E.0
05F7:  BSF    03.7
05F8:  INCF   04,F
05F9:  BTFSS  03.2
05FA:  GOTO   5FE
05FB:  BCF    03.5
05FC:  INCF   05,F
05FD:  BSF    03.5
05FE:  BCF    03.5
05FF:  GOTO   5E3
0600:  BSF    0A.3
0601:  BCF    0A.4
0602:  GOTO   0F6 (RETURN)
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOWDT, NOPROTECT, NOLVP, NOBROWNOUT, NOPUT, NOMCLR 
.................... #use delay(clock = 8000000) 
*
0184:  MOVLW  C5
0185:  MOVWF  04
0186:  BCF    03.7
0187:  MOVF   00,W
0188:  BTFSC  03.2
0189:  GOTO   197
018A:  MOVLW  02
018B:  MOVWF  78
018C:  CLRF   77
018D:  DECFSZ 77,F
018E:  GOTO   18D
018F:  DECFSZ 78,F
0190:  GOTO   18C
0191:  MOVLW  97
0192:  MOVWF  77
0193:  DECFSZ 77,F
0194:  GOTO   193
0195:  DECFSZ 00,F
0196:  GOTO   18A
0197:  RETURN
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = BT_MODUL) 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
082D:  BCF    03.6
082E:  CLRF   27
082F:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0410:  BSF    03.5
0411:  MOVF   46,W
0412:  MOVWF  48
0413:  MOVF   45,W
0414:  MOVWF  47
0415:  MOVF   48,W
0416:  MOVWF  7A
0417:  MOVF   47,W
0418:  MOVWF  04
0419:  BCF    03.7
041A:  BTFSC  7A.0
041B:  BSF    03.7
041C:  MOVF   00,F
041D:  BTFSC  03.2
041E:  GOTO   423
041F:  INCF   47,F
0420:  BTFSC  03.2
0421:  INCF   48,F
0422:  GOTO   415
....................    return(sc - s); 
0423:  MOVF   45,W
0424:  SUBWF  47,W
0425:  MOVWF  77
0426:  MOVF   48,W
0427:  MOVWF  7A
0428:  MOVF   46,W
0429:  BTFSS  03.0
042A:  INCFSZ 46,W
042B:  SUBWF  7A,F
042C:  MOVF   77,W
042D:  MOVWF  78
042E:  BCF    03.5
042F:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LCD_RS_PIN PIN_D1 
.................... #define LCD_RW_PIN PIN_D2 
.................... #define LCD_ENABLE_PIN PIN_D3 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... #include <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0209:  BSF    08.4
....................    output_float(LCD_DATA5); 
020A:  BSF    08.5
....................    output_float(LCD_DATA6); 
020B:  BSF    08.6
....................    output_float(LCD_DATA7); 
020C:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
020D:  BCF    03.5
020E:  BSF    08.2
020F:  BSF    03.5
0210:  BCF    08.2
....................    delay_cycles(1); 
0211:  NOP
....................    lcd_output_enable(1); 
0212:  BCF    03.5
0213:  BSF    08.3
0214:  BSF    03.5
0215:  BCF    08.3
....................    delay_cycles(1); 
0216:  NOP
....................    high = lcd_read_nibble(); 
0217:  BCF    03.5
0218:  CALL   1CE
0219:  MOVF   78,W
021A:  BSF    03.5
021B:  MOVWF  4C
....................        
....................    lcd_output_enable(0); 
021C:  BCF    03.5
021D:  BCF    08.3
021E:  BSF    03.5
021F:  BCF    08.3
....................    delay_cycles(1); 
0220:  NOP
....................    lcd_output_enable(1); 
0221:  BCF    03.5
0222:  BSF    08.3
0223:  BSF    03.5
0224:  BCF    08.3
....................    delay_us(1); 
0225:  GOTO   226
....................    low = lcd_read_nibble(); 
0226:  BCF    03.5
0227:  CALL   1CE
0228:  MOVF   78,W
0229:  BSF    03.5
022A:  MOVWF  4B
....................        
....................    lcd_output_enable(0); 
022B:  BCF    03.5
022C:  BCF    08.3
022D:  BSF    03.5
022E:  BCF    08.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
022F:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0230:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0231:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0232:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0233:  SWAPF  4C,W
0234:  MOVWF  77
0235:  MOVLW  F0
0236:  ANDWF  77,F
0237:  MOVF   77,W
0238:  IORWF  4B,W
0239:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01CE:  BSF    03.5
01CF:  CLRF   4D
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01D0:  BSF    08.4
01D1:  MOVLW  00
01D2:  BCF    03.5
01D3:  BTFSC  08.4
01D4:  MOVLW  01
01D5:  BSF    03.5
01D6:  IORWF  4D,F
....................    n |= input(LCD_DATA5) << 1; 
01D7:  BSF    08.5
01D8:  MOVLW  00
01D9:  BCF    03.5
01DA:  BTFSC  08.5
01DB:  MOVLW  01
01DC:  MOVWF  77
01DD:  BCF    03.0
01DE:  RLF    77,F
01DF:  MOVF   77,W
01E0:  BSF    03.5
01E1:  IORWF  4D,F
....................    n |= input(LCD_DATA6) << 2; 
01E2:  BSF    08.6
01E3:  MOVLW  00
01E4:  BCF    03.5
01E5:  BTFSC  08.6
01E6:  MOVLW  01
01E7:  MOVWF  77
01E8:  RLF    77,F
01E9:  RLF    77,F
01EA:  MOVLW  FC
01EB:  ANDWF  77,F
01EC:  MOVF   77,W
01ED:  BSF    03.5
01EE:  IORWF  4D,F
....................    n |= input(LCD_DATA7) << 3; 
01EF:  BSF    08.7
01F0:  MOVLW  00
01F1:  BCF    03.5
01F2:  BTFSC  08.7
01F3:  MOVLW  01
01F4:  MOVWF  77
01F5:  RLF    77,F
01F6:  RLF    77,F
01F7:  RLF    77,F
01F8:  MOVLW  F8
01F9:  ANDWF  77,F
01FA:  MOVF   77,W
01FB:  BSF    03.5
01FC:  IORWF  4D,F
....................     
....................    return(n); 
01FD:  MOVF   4D,W
01FE:  MOVWF  78
....................   #else 
01FF:  BCF    03.5
0200:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0198:  BSF    03.5
0199:  BTFSC  4C.0
019A:  GOTO   19F
019B:  BCF    03.5
019C:  BCF    08.4
019D:  GOTO   1A1
019E:  BSF    03.5
019F:  BCF    03.5
01A0:  BSF    08.4
01A1:  BSF    03.5
01A2:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
01A3:  BTFSC  4C.1
01A4:  GOTO   1A9
01A5:  BCF    03.5
01A6:  BCF    08.5
01A7:  GOTO   1AB
01A8:  BSF    03.5
01A9:  BCF    03.5
01AA:  BSF    08.5
01AB:  BSF    03.5
01AC:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
01AD:  BTFSC  4C.2
01AE:  GOTO   1B3
01AF:  BCF    03.5
01B0:  BCF    08.6
01B1:  GOTO   1B5
01B2:  BSF    03.5
01B3:  BCF    03.5
01B4:  BSF    08.6
01B5:  BSF    03.5
01B6:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01B7:  BTFSC  4C.3
01B8:  GOTO   1BD
01B9:  BCF    03.5
01BA:  BCF    08.7
01BB:  GOTO   1BF
01BC:  BSF    03.5
01BD:  BCF    03.5
01BE:  BSF    08.7
01BF:  BSF    03.5
01C0:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01C1:  NOP
....................    lcd_output_enable(1); 
01C2:  BCF    03.5
01C3:  BSF    08.3
01C4:  BSF    03.5
01C5:  BCF    08.3
....................    delay_us(2); 
01C6:  GOTO   1C7
01C7:  GOTO   1C8
....................    lcd_output_enable(0); 
01C8:  BCF    03.5
01C9:  BCF    08.3
01CA:  BSF    03.5
01CB:  BCF    08.3
01CC:  BCF    03.5
01CD:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0201:  BSF    03.5
0202:  BCF    08.3
....................    lcd_rs_tris(); 
0203:  BCF    08.1
....................    lcd_rw_tris(); 
0204:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0205:  BCF    03.5
0206:  BCF    08.1
0207:  BSF    03.5
0208:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
023A:  MOVF   78,W
023B:  MOVWF  4B
023C:  BTFSC  4B.7
023D:  GOTO   209
....................    lcd_output_rs(address); 
023E:  MOVF   49,F
023F:  BTFSS  03.2
0240:  GOTO   245
0241:  BCF    03.5
0242:  BCF    08.1
0243:  GOTO   247
0244:  BSF    03.5
0245:  BCF    03.5
0246:  BSF    08.1
0247:  BSF    03.5
0248:  BCF    08.1
....................    delay_cycles(1); 
0249:  NOP
....................    lcd_output_rw(0); 
024A:  BCF    03.5
024B:  BCF    08.2
024C:  BSF    03.5
024D:  BCF    08.2
....................    delay_cycles(1); 
024E:  NOP
....................    lcd_output_enable(0); 
024F:  BCF    03.5
0250:  BCF    08.3
0251:  BSF    03.5
0252:  BCF    08.3
....................    lcd_send_nibble(n >> 4); 
0253:  SWAPF  4A,W
0254:  MOVWF  4B
0255:  MOVLW  0F
0256:  ANDWF  4B,F
0257:  MOVF   4B,W
0258:  MOVWF  4C
0259:  BCF    03.5
025A:  CALL   198
....................    lcd_send_nibble(n & 0xf); 
025B:  BSF    03.5
025C:  MOVF   4A,W
025D:  ANDLW  0F
025E:  MOVWF  4B
025F:  MOVWF  4C
0260:  BCF    03.5
0261:  CALL   198
0262:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0263:  BSF    03.5
0264:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0265:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0266:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0267:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0268:  BCF    08.3
....................    lcd_rs_tris(); 
0269:  BCF    08.1
....................    lcd_rw_tris(); 
026A:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
026B:  BCF    03.5
026C:  BCF    08.1
026D:  BSF    03.5
026E:  BCF    08.1
....................    lcd_output_rw(0); 
026F:  BCF    03.5
0270:  BCF    08.2
0271:  BSF    03.5
0272:  BCF    08.2
....................    lcd_output_enable(0); 
0273:  BCF    03.5
0274:  BCF    08.3
0275:  BSF    03.5
0276:  BCF    08.3
....................      
....................    delay_ms(15); 
0277:  MOVLW  0F
0278:  MOVWF  45
0279:  BCF    03.5
027A:  CALL   184
....................    for(i=1;i<=3;++i) 
027B:  MOVLW  01
027C:  BSF    03.5
027D:  MOVWF  3D
027E:  MOVF   3D,W
027F:  SUBLW  03
0280:  BTFSS  03.0
0281:  GOTO   28E
....................    { 
....................        lcd_send_nibble(3); 
0282:  MOVLW  03
0283:  MOVWF  4C
0284:  BCF    03.5
0285:  CALL   198
....................        delay_ms(5); 
0286:  MOVLW  05
0287:  BSF    03.5
0288:  MOVWF  45
0289:  BCF    03.5
028A:  CALL   184
028B:  BSF    03.5
028C:  INCF   3D,F
028D:  GOTO   27E
....................    } 
....................     
....................    lcd_send_nibble(2); 
028E:  MOVLW  02
028F:  MOVWF  4C
0290:  BCF    03.5
0291:  CALL   198
....................    delay_ms(5); 
0292:  MOVLW  05
0293:  BSF    03.5
0294:  MOVWF  45
0295:  BCF    03.5
0296:  CALL   184
....................    for(i=0;i<=3;++i) 
0297:  BSF    03.5
0298:  CLRF   3D
0299:  MOVF   3D,W
029A:  SUBLW  03
029B:  BTFSS  03.0
029C:  GOTO   2AA
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
029D:  MOVF   3D,W
029E:  BCF    03.5
029F:  CALL   041
02A0:  BSF    03.5
02A1:  MOVWF  3E
02A2:  CLRF   49
02A3:  MOVF   3E,W
02A4:  MOVWF  4A
02A5:  BCF    03.5
02A6:  CALL   201
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02A7:  BSF    03.5
02A8:  INCF   3D,F
02A9:  GOTO   299
02AA:  BCF    03.5
02AB:  RETURN
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
033F:  BSF    03.5
0340:  DECFSZ 46,W
0341:  GOTO   343
0342:  GOTO   346
....................       address=LCD_LINE_TWO; 
0343:  MOVLW  40
0344:  MOVWF  47
0345:  GOTO   347
....................    else 
....................       address=0; 
0346:  CLRF   47
....................       
....................    address+=x-1; 
0347:  MOVLW  01
0348:  SUBWF  45,W
0349:  ADDWF  47,F
....................    lcd_send_byte(0,0x80|address); 
034A:  MOVF   47,W
034B:  IORLW  80
034C:  MOVWF  48
034D:  CLRF   49
034E:  MOVF   48,W
034F:  MOVWF  4A
0350:  BCF    03.5
0351:  CALL   201
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0352:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0353:  BSF    03.5
0354:  MOVF   44,W
0355:  XORLW  07
0356:  BCF    03.5
0357:  BTFSC  03.2
0358:  GOTO   363
0359:  XORLW  0B
035A:  BTFSC  03.2
035B:  GOTO   36A
035C:  XORLW  06
035D:  BTFSC  03.2
035E:  GOTO   376
035F:  XORLW  02
0360:  BTFSC  03.2
0361:  GOTO   37E
0362:  GOTO   385
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0363:  MOVLW  01
0364:  BSF    03.5
0365:  MOVWF  45
0366:  MOVWF  46
0367:  BCF    03.5
0368:  CALL   33F
0369:  GOTO   38C
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
036A:  BSF    03.5
036B:  CLRF   49
036C:  MOVLW  01
036D:  MOVWF  4A
036E:  BCF    03.5
036F:  CALL   201
....................                      delay_ms(2); 
0370:  MOVLW  02
0371:  BSF    03.5
0372:  MOVWF  45
0373:  BCF    03.5
0374:  CALL   184
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0375:  GOTO   38C
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0376:  MOVLW  01
0377:  BSF    03.5
0378:  MOVWF  45
0379:  MOVLW  02
037A:  MOVWF  46
037B:  BCF    03.5
037C:  CALL   33F
037D:  GOTO   38C
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
037E:  BSF    03.5
037F:  CLRF   49
0380:  MOVLW  10
0381:  MOVWF  4A
0382:  BCF    03.5
0383:  CALL   201
0384:  GOTO   38C
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0385:  MOVLW  01
0386:  BSF    03.5
0387:  MOVWF  49
0388:  MOVF   44,W
0389:  MOVWF  4A
038A:  BCF    03.5
038B:  CALL   201
....................      #endif 
....................    } 
038C:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define LED_PIN PIN_A0 
.................... #define BUZZER_PIN PIN_A1 
....................  
.................... #define BTN_SIGNAL PIN_B0 
.................... #define BTN_UPLOAD PIN_B1 
.................... #define BTN_DELETE PIN_B2 
.................... #define BTN_RESET PIN_B3 
.................... #define BTN_HARD_RESET PIN_B4 
....................  
.................... char morse_buffer[10]; 
.................... char text_buffer[21]; 
.................... int8 morse_index = 0; 
.................... int8 text_index = 0; 
....................  
.................... char rx_temp_buffer[25]; 
.................... char rx_display_buffer[25]; 
.................... int8 rx_temp_index = 0; 
.................... int1 rx_data_ready = 0; 
....................  
.................... volatile int16 press_counter = 0; 
.................... volatile int16 idle_counter = 0; 
.................... #define SLEEP_TIMEOUT 3000 
....................  
.................... int1 btn_prev_state = 0; 
.................... int1 update_needed = 0; 
....................  
.................... volatile int8 scroll_tick = 0; 
.................... int1 scroll_now = 0; 
.................... int8 scroll_pos = 0; 
....................  
.................... const char morse_tree[64] = { 
....................     0, 0, 'E', 'T', 'I', 'A', 'N', 'M', 'S', 'U', 'R', 'W', 'D', 'K', 'G', 'O', 
....................     'H', 'V', 'F', 0, 'L', 0, 'P', 'J', 'B', 'X', 'C', 'Y', 'Z', 'Q', 0, 0, 
....................     '5', '4', 0, '3', 0, 0, 0, '2', 0, 0, 0, 0, 0, 0, 0, '1', 
....................     '6', 0, 0, 0, 0, 0, 0, 0, '7', 0, 0, 0, '8', 0, '9', '0'}; 
....................  
.................... void save_text_to_eeprom() 
.................... { 
....................     int8 i; 
....................     write_eeprom(0, text_index); 
*
0603:  MOVF   0B,W
0604:  MOVWF  77
0605:  BCF    0B.7
0606:  BSF    03.6
0607:  CLRF   0D
0608:  BCF    03.6
0609:  MOVF   4D,W
060A:  BSF    03.6
060B:  MOVWF  0C
060C:  BSF    03.5
060D:  BCF    0C.7
060E:  BSF    0C.2
060F:  MOVLW  55
0610:  MOVWF  0D
0611:  MOVLW  AA
0612:  MOVWF  0D
0613:  BSF    0C.1
0614:  BTFSC  0C.1
0615:  GOTO   614
0616:  BCF    0C.2
0617:  MOVF   77,W
0618:  BCF    03.5
0619:  BCF    03.6
061A:  IORWF  0B,F
....................     for (i = 0; i < text_index; i++) 
061B:  BSF    03.5
061C:  CLRF   3D
061D:  BCF    03.5
061E:  MOVF   4D,W
061F:  BSF    03.5
0620:  SUBWF  3D,W
0621:  BTFSC  03.0
0622:  GOTO   64D
....................     { 
....................         write_eeprom(i + 1, text_buffer[i]); 
0623:  MOVLW  01
0624:  ADDWF  3D,W
0625:  MOVWF  3E
0626:  MOVLW  37
0627:  ADDWF  3D,W
0628:  MOVWF  04
0629:  BCF    03.7
062A:  MOVF   00,W
062B:  MOVWF  3F
062C:  BCF    03.5
062D:  MOVF   0B,W
062E:  MOVWF  77
062F:  BCF    0B.7
0630:  BSF    03.5
0631:  MOVF   3E,W
0632:  BCF    03.5
0633:  BSF    03.6
0634:  MOVWF  0D
0635:  BSF    03.5
0636:  BCF    03.6
0637:  MOVF   3F,W
0638:  BCF    03.5
0639:  BSF    03.6
063A:  MOVWF  0C
063B:  BSF    03.5
063C:  BCF    0C.7
063D:  BSF    0C.2
063E:  MOVLW  55
063F:  MOVWF  0D
0640:  MOVLW  AA
0641:  MOVWF  0D
0642:  BSF    0C.1
0643:  BTFSC  0C.1
0644:  GOTO   643
0645:  BCF    0C.2
0646:  MOVF   77,W
0647:  BCF    03.5
0648:  BCF    03.6
0649:  IORWF  0B,F
064A:  BSF    03.5
064B:  INCF   3D,F
064C:  GOTO   61D
....................     } 
064D:  BCF    03.5
064E:  RETURN
.................... } 
....................  
.................... void load_text_from_eeprom() 
.................... { 
....................     int8 i; 
....................     text_index = read_eeprom(0); 
*
02AC:  BSF    03.6
02AD:  CLRF   0D
02AE:  BSF    03.5
02AF:  BCF    0C.7
02B0:  BSF    0C.0
02B1:  BCF    03.5
02B2:  MOVF   0C,W
02B3:  BCF    03.6
02B4:  MOVWF  4D
....................     if (text_index > 20) 
02B5:  MOVF   4D,W
02B6:  SUBLW  14
02B7:  BTFSS  03.0
....................         text_index = 0; 
02B8:  CLRF   4D
....................     for (i = 0; i < text_index; i++) 
02B9:  BSF    03.5
02BA:  CLRF   3D
02BB:  BCF    03.5
02BC:  MOVF   4D,W
02BD:  BSF    03.5
02BE:  SUBWF  3D,W
02BF:  BTFSC  03.0
02C0:  GOTO   2D6
....................     { 
....................         text_buffer[i] = read_eeprom(i + 1); 
02C1:  MOVLW  37
02C2:  ADDWF  3D,W
02C3:  MOVWF  04
02C4:  BCF    03.7
02C5:  MOVLW  01
02C6:  ADDWF  3D,W
02C7:  MOVWF  40
02C8:  MOVF   40,W
02C9:  BCF    03.5
02CA:  BSF    03.6
02CB:  MOVWF  0D
02CC:  BSF    03.5
02CD:  BCF    0C.7
02CE:  BSF    0C.0
02CF:  BCF    03.5
02D0:  MOVF   0C,W
02D1:  MOVWF  00
02D2:  BSF    03.5
02D3:  BCF    03.6
02D4:  INCF   3D,F
02D5:  GOTO   2BB
....................     } 
....................     text_buffer[text_index] = '\0'; 
02D6:  MOVLW  37
02D7:  BCF    03.5
02D8:  ADDWF  4D,W
02D9:  MOVWF  04
02DA:  BCF    03.7
02DB:  CLRF   00
02DC:  BSF    0A.3
02DD:  BCF    0A.4
02DE:  GOTO   045 (RETURN)
.................... } 
....................  
.................... void save_bt_to_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = strlen(rx_display_buffer); 
*
0532:  BSF    03.5
0533:  CLRF   46
0534:  MOVLW  A0
0535:  MOVWF  45
0536:  BCF    03.5
0537:  CALL   410
0538:  MOVF   78,W
0539:  BSF    03.5
053A:  MOVWF  3E
....................     write_eeprom(50, len); 
053B:  BCF    03.5
053C:  MOVF   0B,W
053D:  MOVWF  77
053E:  BCF    0B.7
053F:  MOVLW  32
0540:  BSF    03.6
0541:  MOVWF  0D
0542:  BSF    03.5
0543:  BCF    03.6
0544:  MOVF   3E,W
0545:  BCF    03.5
0546:  BSF    03.6
0547:  MOVWF  0C
0548:  BSF    03.5
0549:  BCF    0C.7
054A:  BSF    0C.2
054B:  MOVLW  55
054C:  MOVWF  0D
054D:  MOVLW  AA
054E:  MOVWF  0D
054F:  BSF    0C.1
0550:  BTFSC  0C.1
0551:  GOTO   550
0552:  BCF    0C.2
0553:  MOVF   77,W
0554:  BCF    03.5
0555:  BCF    03.6
0556:  IORWF  0B,F
....................     for (i = 0; i < len; i++) 
0557:  BSF    03.5
0558:  CLRF   3D
0559:  MOVF   3E,W
055A:  SUBWF  3D,W
055B:  BTFSC  03.0
055C:  GOTO   587
....................     { 
....................         write_eeprom(51 + i, rx_display_buffer[i]); 
055D:  MOVLW  33
055E:  ADDWF  3D,W
055F:  MOVWF  3F
0560:  MOVLW  A0
0561:  ADDWF  3D,W
0562:  MOVWF  04
0563:  BCF    03.7
0564:  MOVF   00,W
0565:  MOVWF  40
0566:  BCF    03.5
0567:  MOVF   0B,W
0568:  MOVWF  77
0569:  BCF    0B.7
056A:  BSF    03.5
056B:  MOVF   3F,W
056C:  BCF    03.5
056D:  BSF    03.6
056E:  MOVWF  0D
056F:  BSF    03.5
0570:  BCF    03.6
0571:  MOVF   40,W
0572:  BCF    03.5
0573:  BSF    03.6
0574:  MOVWF  0C
0575:  BSF    03.5
0576:  BCF    0C.7
0577:  BSF    0C.2
0578:  MOVLW  55
0579:  MOVWF  0D
057A:  MOVLW  AA
057B:  MOVWF  0D
057C:  BSF    0C.1
057D:  BTFSC  0C.1
057E:  GOTO   57D
057F:  BCF    0C.2
0580:  MOVF   77,W
0581:  BCF    03.5
0582:  BCF    03.6
0583:  IORWF  0B,F
0584:  BSF    03.5
0585:  INCF   3D,F
0586:  GOTO   559
....................     } 
0587:  BCF    03.5
0588:  BSF    0A.3
0589:  BCF    0A.4
058A:  GOTO   0A6 (RETURN)
.................... } 
....................  
.................... void load_bt_from_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = read_eeprom(50); 
*
02DF:  MOVLW  32
02E0:  BSF    03.6
02E1:  MOVWF  0D
02E2:  BSF    03.5
02E3:  BCF    0C.7
02E4:  BSF    0C.0
02E5:  BCF    03.5
02E6:  MOVF   0C,W
02E7:  BSF    03.5
02E8:  BCF    03.6
02E9:  MOVWF  3E
....................     if (len > 20) 
02EA:  MOVF   3E,W
02EB:  SUBLW  14
02EC:  BTFSS  03.0
....................         len = 0; 
02ED:  CLRF   3E
....................  
....................     for (i = 0; i < len; i++) 
02EE:  CLRF   3D
02EF:  MOVF   3E,W
02F0:  SUBWF  3D,W
02F1:  BTFSC  03.0
02F2:  GOTO   308
....................     { 
....................         rx_display_buffer[i] = read_eeprom(51 + i); 
02F3:  MOVLW  A0
02F4:  ADDWF  3D,W
02F5:  MOVWF  04
02F6:  BCF    03.7
02F7:  MOVLW  33
02F8:  ADDWF  3D,W
02F9:  MOVWF  41
02FA:  MOVF   41,W
02FB:  BCF    03.5
02FC:  BSF    03.6
02FD:  MOVWF  0D
02FE:  BSF    03.5
02FF:  BCF    0C.7
0300:  BSF    0C.0
0301:  BCF    03.5
0302:  MOVF   0C,W
0303:  MOVWF  00
0304:  BSF    03.5
0305:  BCF    03.6
0306:  INCF   3D,F
0307:  GOTO   2EF
....................     } 
....................     rx_display_buffer[len] = '\0'; 
0308:  MOVLW  A0
0309:  ADDWF  3E,W
030A:  MOVWF  04
030B:  BCF    03.7
030C:  CLRF   00
030D:  BCF    03.5
030E:  BSF    0A.3
030F:  BCF    0A.4
0310:  GOTO   048 (RETURN)
.................... } 
....................  
.................... char decode_morse(char *code) 
*
0430:  MOVLW  01
0431:  BSF    03.5
0432:  MOVWF  44
.................... { 
....................     int8 i, len; 
....................     int8 index = 1; 
....................     len = strlen(code); 
0433:  MOVF   41,W
0434:  MOVWF  46
0435:  MOVF   40,W
0436:  MOVWF  45
0437:  BCF    03.5
0438:  CALL   410
0439:  MOVF   78,W
043A:  BSF    03.5
043B:  MOVWF  43
....................     if (len == 0) 
043C:  MOVF   43,F
043D:  BTFSS  03.2
043E:  GOTO   442
....................         return ' '; 
043F:  MOVLW  20
0440:  MOVWF  78
0441:  GOTO   46E
....................  
....................     for (i = 0; i < len; i++) 
0442:  CLRF   42
0443:  MOVF   43,W
0444:  SUBWF  42,W
0445:  BTFSC  03.0
0446:  GOTO   45C
....................     { 
....................         index = index << 1; 
0447:  BCF    03.0
0448:  RLF    44,F
....................         if (code[i] == '-') 
0449:  MOVF   42,W
044A:  ADDWF  40,W
044B:  MOVWF  04
044C:  BCF    03.7
044D:  BTFSC  41.0
044E:  BSF    03.7
044F:  MOVF   00,W
0450:  SUBLW  2D
0451:  BTFSC  03.2
....................             index |= 1; 
0452:  BSF    44.0
....................         if (index >= 64) 
0453:  MOVF   44,W
0454:  SUBLW  3F
0455:  BTFSC  03.0
0456:  GOTO   45A
....................             return '?'; 
0457:  MOVLW  3F
0458:  MOVWF  78
0459:  GOTO   46E
045A:  INCF   42,F
045B:  GOTO   443
....................     } 
....................     if (morse_tree[index] == 0) 
045C:  MOVF   44,W
045D:  BCF    03.5
045E:  CALL   049
045F:  XORLW  00
0460:  BTFSS  03.2
0461:  GOTO   467
....................         return '?'; 
0462:  MOVLW  3F
0463:  MOVWF  78
0464:  BSF    03.5
0465:  GOTO   46E
0466:  BCF    03.5
....................     return morse_tree[index]; 
0467:  BSF    03.5
0468:  MOVF   44,W
0469:  BCF    03.5
046A:  CALL   049
046B:  MOVWF  78
046C:  MOVWF  78
046D:  BSF    03.5
046E:  BCF    03.5
046F:  RETURN
.................... } 
....................  
.................... void lcd_locate(int8 x, int8 y) 
.................... { 
....................     int8 address; 
....................     switch (y) 
*
0311:  BSF    03.5
0312:  MOVF   42,W
0313:  XORLW  01
0314:  BCF    03.5
0315:  BTFSC  03.2
0316:  GOTO   321
0317:  XORLW  03
0318:  BTFSC  03.2
0319:  GOTO   324
031A:  XORLW  01
031B:  BTFSC  03.2
031C:  GOTO   328
031D:  XORLW  07
031E:  BTFSC  03.2
031F:  GOTO   32C
0320:  GOTO   331
....................     { 
....................     case 1: 
....................         address = 0x00; 
0321:  BSF    03.5
0322:  CLRF   43
....................         break; 
0323:  GOTO   333
....................     case 2: 
....................         address = 0x40; 
0324:  MOVLW  40
0325:  BSF    03.5
0326:  MOVWF  43
....................         break; 
0327:  GOTO   333
....................     case 3: 
....................         address = 0x14; 
0328:  MOVLW  14
0329:  BSF    03.5
032A:  MOVWF  43
....................         break; 
032B:  GOTO   333
....................     case 4: 
....................         address = 0x54; 
032C:  MOVLW  54
032D:  BSF    03.5
032E:  MOVWF  43
....................         break; 
032F:  GOTO   333
0330:  BCF    03.5
....................     default: 
....................         address = 0x00; 
0331:  BSF    03.5
0332:  CLRF   43
....................         break; 
....................     } 
....................     address += x - 1; 
0333:  MOVLW  01
0334:  SUBWF  41,W
0335:  ADDWF  43,F
....................     lcd_send_byte(0, 0x80 | address); 
0336:  MOVF   43,W
0337:  IORLW  80
0338:  MOVWF  44
0339:  CLRF   49
033A:  MOVF   44,W
033B:  MOVWF  4A
033C:  BCF    03.5
033D:  CALL   201
033E:  RETURN
.................... } 
....................  
.................... void update_scroll_line() 
*
04DC:  MOVLW  04
04DD:  BSF    03.5
04DE:  MOVWF  40
.................... { 
....................     int8 len, i, current_char_idx; 
....................     int8 gap_size = 4; 
....................  
....................     if (rx_display_buffer[0] == '\0') 
04DF:  MOVF   20,F
04E0:  BTFSC  03.2
....................         return; 
04E1:  GOTO   52E
....................  
....................     len = strlen(rx_display_buffer); 
04E2:  CLRF   46
04E3:  MOVLW  A0
04E4:  MOVWF  45
04E5:  BCF    03.5
04E6:  CALL   410
04E7:  MOVF   78,W
04E8:  BSF    03.5
04E9:  MOVWF  3D
....................     lcd_locate(1, 4); 
04EA:  MOVLW  01
04EB:  MOVWF  41
04EC:  MOVLW  04
04ED:  MOVWF  42
04EE:  BCF    03.5
04EF:  CALL   311
....................  
....................     for (i = 0; i < 20; i++) 
04F0:  BSF    03.5
04F1:  CLRF   3E
04F2:  MOVF   3E,W
04F3:  SUBLW  13
04F4:  BTFSS  03.0
04F5:  GOTO   52E
....................     { 
....................         current_char_idx = (scroll_pos + i) % (len + gap_size); 
04F6:  MOVF   3E,W
04F7:  BCF    03.5
04F8:  ADDWF  6E,W
04F9:  BSF    03.5
04FA:  MOVWF  41
04FB:  MOVF   40,W
04FC:  ADDWF  3D,W
04FD:  MOVWF  42
04FE:  MOVF   41,W
04FF:  MOVWF  43
0500:  MOVF   42,W
0501:  MOVWF  44
*
0516:  MOVF   77,W
0517:  MOVWF  3F
....................  
....................         if (current_char_idx < len) 
0518:  MOVF   3D,W
0519:  SUBWF  3F,W
051A:  BTFSC  03.0
051B:  GOTO   527
....................             lcd_putc(rx_display_buffer[current_char_idx]); 
051C:  MOVLW  A0
051D:  ADDWF  3F,W
051E:  MOVWF  04
051F:  BCF    03.7
0520:  MOVF   00,W
0521:  MOVWF  41
0522:  MOVWF  44
0523:  BCF    03.5
0524:  CALL   353
0525:  GOTO   52B
0526:  BSF    03.5
....................         else 
....................             lcd_putc(' '); 
0527:  MOVLW  20
0528:  MOVWF  44
0529:  BCF    03.5
052A:  CALL   353
052B:  BSF    03.5
052C:  INCF   3E,F
052D:  GOTO   4F2
....................     } 
052E:  BCF    03.5
052F:  BSF    0A.3
0530:  BCF    0A.4
0531:  GOTO   09F (RETURN)
.................... } 
....................  
.................... void update_lcd() 
.................... { 
....................     int8 i, len; 
....................     char preview_char; 
....................  
....................     lcd_locate(1, 2); 
*
0470:  MOVLW  01
0471:  BSF    03.5
0472:  MOVWF  41
0473:  MOVLW  02
0474:  MOVWF  42
0475:  BCF    03.5
0476:  CALL   311
....................     printf(lcd_putc, "%s", text_buffer); 
0477:  MOVLW  37
0478:  MOVWF  04
0479:  BCF    03.7
047A:  CALL   3F3
....................  
....................     if (morse_index > 0) 
047B:  MOVF   4C,F
047C:  BTFSC  03.2
047D:  GOTO   491
....................     { 
....................         preview_char = decode_morse(morse_buffer); 
047E:  BSF    03.5
047F:  CLRF   41
0480:  MOVLW  2D
0481:  MOVWF  40
0482:  BCF    03.5
0483:  CALL   430
0484:  MOVF   78,W
0485:  BSF    03.5
0486:  MOVWF  3F
....................         lcd_putc(preview_char); 
0487:  MOVF   3F,W
0488:  MOVWF  44
0489:  BCF    03.5
048A:  CALL   353
....................         lcd_putc('<'); 
048B:  MOVLW  3C
048C:  BSF    03.5
048D:  MOVWF  44
048E:  BCF    03.5
048F:  CALL   353
....................     } 
0490:  GOTO   498
....................     else 
....................     { 
....................         lcd_putc("  "); 
0491:  MOVLW  8D
0492:  BSF    03.6
0493:  MOVWF  0D
0494:  MOVLW  00
0495:  MOVWF  0F
0496:  BCF    03.6
0497:  CALL   38D
....................     } 
....................  
....................     len = strlen(text_buffer) + (morse_index > 0 ? 2 : 0); 
0498:  BSF    03.5
0499:  CLRF   46
049A:  MOVLW  37
049B:  MOVWF  45
049C:  BCF    03.5
049D:  CALL   410
049E:  MOVF   78,W
049F:  BSF    03.5
04A0:  MOVWF  40
04A1:  BCF    03.5
04A2:  MOVF   4C,F
04A3:  BTFSC  03.2
04A4:  GOTO   4A8
04A5:  CLRF   7A
04A6:  MOVLW  02
04A7:  GOTO   4AA
04A8:  CLRF   7A
04A9:  MOVLW  00
04AA:  BSF    03.5
04AB:  ADDWF  40,W
04AC:  MOVWF  3E
....................     for (i = len; i < 20; i++) 
04AD:  MOVF   3E,W
04AE:  MOVWF  3D
04AF:  MOVF   3D,W
04B0:  SUBLW  13
04B1:  BTFSS  03.0
04B2:  GOTO   4BA
....................         lcd_putc(' '); 
04B3:  MOVLW  20
04B4:  MOVWF  44
04B5:  BCF    03.5
04B6:  CALL   353
04B7:  BSF    03.5
04B8:  INCF   3D,F
04B9:  GOTO   4AF
....................  
....................     lcd_locate(1, 3); 
04BA:  MOVLW  01
04BB:  MOVWF  41
04BC:  MOVLW  03
04BD:  MOVWF  42
04BE:  BCF    03.5
04BF:  CALL   311
....................     printf(lcd_putc, "%s", morse_buffer); 
04C0:  MOVLW  2D
04C1:  MOVWF  04
04C2:  BCF    03.7
04C3:  CALL   3F3
....................     len = strlen(morse_buffer); 
04C4:  BSF    03.5
04C5:  CLRF   46
04C6:  MOVLW  2D
04C7:  MOVWF  45
04C8:  BCF    03.5
04C9:  CALL   410
04CA:  MOVF   78,W
04CB:  BSF    03.5
04CC:  MOVWF  3E
....................     for (i = len; i < 20; i++) 
04CD:  MOVF   3E,W
04CE:  MOVWF  3D
04CF:  MOVF   3D,W
04D0:  SUBLW  13
04D1:  BTFSS  03.0
04D2:  GOTO   4DA
....................         lcd_putc(' '); 
04D3:  MOVLW  20
04D4:  MOVWF  44
04D5:  BCF    03.5
04D6:  CALL   353
04D7:  BSF    03.5
04D8:  INCF   3D,F
04D9:  GOTO   4CF
04DA:  BCF    03.5
04DB:  RETURN
.................... } 
....................  
.................... void enter_sleep_mode() 
.................... { 
....................     lcd_putc('\f'); 
*
058B:  MOVLW  0C
058C:  BSF    03.5
058D:  MOVWF  44
058E:  BCF    03.5
058F:  CALL   353
....................     lcd_locate(1, 1); 
0590:  MOVLW  01
0591:  BSF    03.5
0592:  MOVWF  41
0593:  MOVWF  42
0594:  BCF    03.5
0595:  CALL   311
....................     printf(lcd_putc, "UYKU MODU..."); 
0596:  MOVLW  8F
0597:  BSF    03.6
0598:  MOVWF  0D
0599:  MOVLW  00
059A:  MOVWF  0F
059B:  BCF    03.6
059C:  CALL   38D
....................     delay_ms(500); 
059D:  MOVLW  02
059E:  BSF    03.5
059F:  MOVWF  3D
05A0:  MOVLW  FA
05A1:  MOVWF  45
05A2:  BCF    03.5
05A3:  CALL   184
05A4:  BSF    03.5
05A5:  DECFSZ 3D,F
05A6:  GOTO   5A0
....................     lcd_send_byte(0, 0x08); 
05A7:  CLRF   49
05A8:  MOVLW  08
05A9:  MOVWF  4A
05AA:  BCF    03.5
05AB:  CALL   201
....................  
....................     output_low(LED_PIN); 
05AC:  BSF    03.5
05AD:  BCF    05.0
05AE:  BCF    03.5
05AF:  BCF    05.0
....................     output_low(BUZZER_PIN); 
05B0:  BSF    03.5
05B1:  BCF    05.1
05B2:  BCF    03.5
05B3:  BCF    05.1
....................  
....................     while (TRUE) 
....................     { 
....................         sleep(); 
05B4:  SLEEP
....................         if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_HARD_RESET)) 
05B5:  BSF    03.5
05B6:  BSF    06.0
05B7:  BCF    03.5
05B8:  BTFSS  06.0
05B9:  GOTO   5CD
05BA:  BSF    03.5
05BB:  BSF    06.1
05BC:  BCF    03.5
05BD:  BTFSS  06.1
05BE:  GOTO   5CD
05BF:  BSF    03.5
05C0:  BSF    06.2
05C1:  BCF    03.5
05C2:  BTFSS  06.2
05C3:  GOTO   5CD
05C4:  BSF    03.5
05C5:  BSF    06.3
05C6:  BCF    03.5
05C7:  BTFSS  06.3
05C8:  GOTO   5CD
05C9:  BSF    03.5
05CA:  BSF    06.4
05CB:  BCF    03.5
05CC:  BTFSS  06.4
....................         { 
....................             break; 
05CD:  GOTO   5CF
....................         } 
05CE:  GOTO   5B4
....................     } 
....................  
....................     lcd_init(); 
05CF:  CALL   263
....................     lcd_locate(1, 1); 
05D0:  MOVLW  01
05D1:  BSF    03.5
05D2:  MOVWF  41
05D3:  MOVWF  42
05D4:  BCF    03.5
05D5:  CALL   311
....................     printf(lcd_putc, "MOD: YAZIM"); 
05D6:  MOVLW  96
05D7:  BSF    03.6
05D8:  MOVWF  0D
05D9:  MOVLW  00
05DA:  MOVWF  0F
05DB:  BCF    03.6
05DC:  CALL   38D
....................     update_lcd(); 
05DD:  CALL   470
....................     idle_counter = 0; 
05DE:  CLRF   6C
05DF:  CLRF   6B
05E0:  BSF    0A.3
05E1:  BCF    0A.4
05E2:  GOTO   0B8 (RETURN)
.................... } 
....................  
.................... #INT_RDA 
.................... void serial_isr() 
.................... { 
....................     char incoming; 
....................     if (kbhit(BT_MODUL)) 
*
009C:  BTFSS  0C.5
009D:  GOTO   0E7
....................     { 
....................         incoming = fgetc(BT_MODUL); 
009E:  BTFSS  0C.5
009F:  GOTO   09E
00A0:  MOVF   1A,W
00A1:  BSF    03.5
00A2:  MOVWF  4F
....................  
....................         if (incoming == '\\' || incoming == '\n' || incoming == '\r') 
00A3:  MOVF   4F,W
00A4:  SUBLW  5C
00A5:  BTFSC  03.2
00A6:  GOTO   0AF
00A7:  MOVF   4F,W
00A8:  SUBLW  0A
00A9:  BTFSC  03.2
00AA:  GOTO   0AF
00AB:  MOVF   4F,W
00AC:  SUBLW  0D
00AD:  BTFSS  03.2
00AE:  GOTO   0D9
....................         { 
....................             if (rx_temp_index > 0) 
00AF:  BCF    03.5
00B0:  MOVF   67,F
00B1:  BTFSC  03.2
00B2:  GOTO   0D7
....................             { 
....................                 rx_temp_buffer[rx_temp_index] = '\0'; 
00B3:  MOVLW  4E
00B4:  ADDWF  67,W
00B5:  MOVWF  04
00B6:  BCF    03.7
00B7:  CLRF   00
....................                 strcpy(rx_display_buffer, rx_temp_buffer); 
00B8:  BSF    03.5
00B9:  CLRF   53
00BA:  MOVLW  4E
00BB:  MOVWF  52
00BC:  CLRF   51
00BD:  MOVLW  A0
00BE:  MOVWF  50
00BF:  MOVF   52,W
00C0:  MOVWF  04
00C1:  BCF    03.7
00C2:  BTFSC  53.0
00C3:  BSF    03.7
00C4:  MOVF   00,W
00C5:  MOVWF  54
00C6:  MOVF   50,W
00C7:  MOVWF  04
00C8:  BCF    03.7
00C9:  BTFSC  51.0
00CA:  BSF    03.7
00CB:  MOVF   54,W
00CC:  MOVWF  00
00CD:  MOVF   00,F
00CE:  BTFSC  03.2
00CF:  GOTO   0D3
00D0:  INCF   50,F
00D1:  INCF   52,F
00D2:  GOTO   0BF
....................                 rx_data_ready = 1; 
00D3:  BCF    03.5
00D4:  BSF    68.0
....................                 rx_temp_index = 0; 
00D5:  CLRF   67
....................                 scroll_pos = 0; 
00D6:  CLRF   6E
....................             } 
....................         } 
00D7:  GOTO   0E7
00D8:  BSF    03.5
....................         else 
....................         { 
....................             if (rx_temp_index < 20) 
00D9:  BCF    03.5
00DA:  MOVF   67,W
00DB:  SUBLW  13
00DC:  BTFSS  03.0
00DD:  GOTO   0E7
....................             { 
....................                 rx_temp_buffer[rx_temp_index++] = incoming; 
00DE:  MOVF   67,W
00DF:  INCF   67,F
00E0:  ADDLW  4E
00E1:  MOVWF  04
00E2:  BCF    03.7
00E3:  BSF    03.5
00E4:  MOVF   4F,W
00E5:  MOVWF  00
00E6:  BCF    03.5
....................             } 
....................         } 
....................     } 
.................... } 
....................  
00E7:  BCF    0C.5
00E8:  BCF    0A.3
00E9:  BCF    0A.4
00EA:  GOTO   027
.................... #INT_TIMER1 
.................... void timer1_isr() 
.................... { 
....................     set_timer1(63036); 
00EB:  CLRF   0E
00EC:  MOVLW  F6
00ED:  MOVWF  0F
00EE:  MOVLW  3C
00EF:  MOVWF  0E
....................  
....................     if (idle_counter < 32000) 
00F0:  MOVF   6C,W
00F1:  SUBLW  7C
00F2:  BTFSS  03.0
00F3:  GOTO   0F7
....................     { 
....................         idle_counter++; 
00F4:  INCF   6B,F
00F5:  BTFSC  03.2
00F6:  INCF   6C,F
....................     } 
....................  
....................     int1 btn_current = !input(BTN_SIGNAL); 
00F7:  BSF    03.5
00F8:  BSF    06.0
00F9:  BCF    4F.0
00FA:  BCF    03.5
00FB:  BTFSC  06.0
00FC:  GOTO   100
00FD:  BSF    03.5
00FE:  BSF    4F.0
00FF:  BCF    03.5
....................  
....................     if (btn_current) 
0100:  BSF    03.5
0101:  BTFSS  4F.0
0102:  GOTO   113
....................     { 
....................         idle_counter = 0; 
0103:  BCF    03.5
0104:  CLRF   6C
0105:  CLRF   6B
....................         press_counter++; 
0106:  INCF   69,F
0107:  BTFSC  03.2
0108:  INCF   6A,F
....................         output_high(LED_PIN); 
0109:  BSF    03.5
010A:  BCF    05.0
010B:  BCF    03.5
010C:  BSF    05.0
....................         output_high(BUZZER_PIN); 
010D:  BSF    03.5
010E:  BCF    05.1
010F:  BCF    03.5
0110:  BSF    05.1
....................     } 
0111:  GOTO   143
0112:  BSF    03.5
....................     else 
....................     { 
....................         output_low(LED_PIN); 
0113:  BCF    05.0
0114:  BCF    03.5
0115:  BCF    05.0
....................         output_low(BUZZER_PIN); 
0116:  BSF    03.5
0117:  BCF    05.1
0118:  BCF    03.5
0119:  BCF    05.1
....................         if (btn_prev_state == 1) 
011A:  BTFSS  68.1
011B:  GOTO   143
....................         { 
....................             idle_counter = 0; 
011C:  CLRF   6C
011D:  CLRF   6B
....................             if (press_counter > 2) 
011E:  MOVF   6A,F
011F:  BTFSS  03.2
0120:  GOTO   125
0121:  MOVF   69,W
0122:  SUBLW  02
0123:  BTFSC  03.0
0124:  GOTO   141
....................             { 
....................                 if (press_counter < 30) 
0125:  MOVF   6A,F
0126:  BTFSS  03.2
0127:  GOTO   134
0128:  MOVF   69,W
0129:  SUBLW  1D
012A:  BTFSS  03.0
012B:  GOTO   134
....................                     morse_buffer[morse_index++] = '.'; 
012C:  MOVF   4C,W
012D:  INCF   4C,F
012E:  ADDLW  2D
012F:  MOVWF  04
0130:  BCF    03.7
0131:  MOVLW  2E
0132:  MOVWF  00
0133:  GOTO   13B
....................                 else 
....................                     morse_buffer[morse_index++] = '-'; 
0134:  MOVF   4C,W
0135:  INCF   4C,F
0136:  ADDLW  2D
0137:  MOVWF  04
0138:  BCF    03.7
0139:  MOVLW  2D
013A:  MOVWF  00
....................  
....................                 morse_buffer[morse_index] = '\0'; 
013B:  MOVLW  2D
013C:  ADDWF  4C,W
013D:  MOVWF  04
013E:  BCF    03.7
013F:  CLRF   00
....................                 update_needed = 1; 
0140:  BSF    68.2
....................             } 
....................             press_counter = 0; 
0141:  CLRF   6A
0142:  CLRF   69
....................         } 
....................     } 
....................     btn_prev_state = btn_current; 
0143:  BCF    68.1
0144:  BSF    03.5
0145:  BTFSS  4F.0
0146:  GOTO   14A
0147:  BCF    03.5
0148:  BSF    68.1
0149:  BSF    03.5
.................... } 
....................  
014A:  BCF    03.5
014B:  BCF    0C.0
014C:  BCF    0A.3
014D:  BCF    0A.4
014E:  GOTO   027
.................... #INT_TIMER0 
.................... void timer0_isr() 
.................... { 
....................     scroll_tick++; 
014F:  INCF   6D,F
....................     if (scroll_tick > 10) 
0150:  MOVF   6D,W
0151:  SUBLW  0A
0152:  BTFSC  03.0
0153:  GOTO   156
....................     { 
....................         scroll_tick = 0; 
0154:  CLRF   6D
....................         scroll_now = 1; 
0155:  BSF    68.3
....................     } 
0156:  BCF    0B.2
0157:  BCF    0A.3
0158:  BCF    0A.4
0159:  GOTO   027
.................... } 
....................  
.................... void main() 
*
0800:  MOVLW  71
0801:  BSF    03.5
0802:  MOVWF  0F
0803:  MOVF   0F,W
0804:  BSF    03.6
0805:  BCF    07.3
0806:  MOVLW  0C
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  A2
080A:  MOVWF  18
080B:  MOVLW  90
080C:  BCF    03.5
080D:  MOVWF  18
080E:  CLRF   4C
080F:  CLRF   4D
0810:  CLRF   67
0811:  BCF    68.0
0812:  CLRF   6A
0813:  CLRF   69
0814:  CLRF   6C
0815:  CLRF   6B
0816:  BCF    68.1
0817:  BCF    68.2
0818:  CLRF   6D
0819:  BCF    68.3
081A:  CLRF   6E
081B:  BSF    03.5
081C:  BSF    03.6
081D:  MOVF   09,W
081E:  ANDLW  C0
081F:  MOVWF  09
0820:  BCF    03.6
0821:  BCF    1F.4
0822:  BCF    1F.5
0823:  MOVLW  00
0824:  BSF    03.6
0825:  MOVWF  08
0826:  BCF    03.5
0827:  CLRF   07
0828:  CLRF   08
0829:  CLRF   09
082A:  BCF    03.7
082B:  MOVLW  1F
082C:  ANDWF  03,F
.................... { 
....................     set_tris_b(0xFF); 
*
0830:  MOVLW  FF
0831:  BSF    03.5
0832:  MOVWF  06
....................     port_b_pullups(TRUE); 
0833:  MOVLW  01
0834:  MOVWF  15
0835:  BCF    01.7
....................     output_drive(LED_PIN); 
0836:  BCF    05.0
....................     output_drive(BUZZER_PIN); 
0837:  BCF    05.1
....................  
....................     lcd_init(); 
0838:  BCF    0A.3
0839:  BCF    03.5
083A:  CALL   263
083B:  BSF    0A.3
....................     delay_ms(100); 
083C:  MOVLW  64
083D:  BSF    03.5
083E:  MOVWF  45
083F:  BCF    0A.3
0840:  BCF    03.5
0841:  CALL   184
0842:  BSF    0A.3
....................  
....................     load_text_from_eeprom(); 
0843:  BCF    0A.3
0844:  GOTO   2AC
0845:  BSF    0A.3
....................     load_bt_from_eeprom(); 
0846:  BCF    0A.3
0847:  GOTO   2DF
0848:  BSF    0A.3
....................  
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
0849:  MOVLW  35
084A:  MOVWF  10
....................     set_timer1(63036); 
084B:  CLRF   0E
084C:  MOVLW  F6
084D:  MOVWF  0F
084E:  MOVLW  3C
084F:  MOVWF  0E
....................  
....................     setup_timer_0(T0_INTERNAL | T0_DIV_256); 
0850:  BSF    03.5
0851:  MOVF   01,W
0852:  ANDLW  C0
0853:  IORLW  07
0854:  MOVWF  01
....................  
....................     enable_interrupts(INT_TIMER1); 
0855:  BSF    0C.0
....................     enable_interrupts(INT_TIMER0); 
0856:  BCF    03.5
0857:  BSF    0B.5
....................     enable_interrupts(INT_RDA); 
0858:  BSF    03.5
0859:  BSF    0C.5
....................     enable_interrupts(GLOBAL); 
085A:  MOVLW  C0
085B:  BCF    03.5
085C:  IORWF  0B,F
....................  
....................     lcd_locate(1, 1); 
085D:  MOVLW  01
085E:  BSF    03.5
085F:  MOVWF  41
0860:  MOVWF  42
0861:  BCF    0A.3
0862:  BCF    03.5
0863:  CALL   311
0864:  BSF    0A.3
....................     printf(lcd_putc, "Mors Telgraf"); 
0865:  MOVLW  5A
0866:  BSF    03.6
0867:  MOVWF  0D
0868:  MOVLW  01
0869:  MOVWF  0F
086A:  BCF    0A.3
086B:  BCF    03.6
086C:  CALL   38D
086D:  BSF    0A.3
....................     delay_ms(1000); 
086E:  MOVLW  04
086F:  BSF    03.5
0870:  MOVWF  3D
0871:  MOVLW  FA
0872:  MOVWF  45
0873:  BCF    0A.3
0874:  BCF    03.5
0875:  CALL   184
0876:  BSF    0A.3
0877:  BSF    03.5
0878:  DECFSZ 3D,F
0879:  GOTO   071
....................  
....................     lcd_putc('\f'); 
087A:  MOVLW  0C
087B:  MOVWF  44
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   353
087F:  BSF    0A.3
....................     lcd_locate(1, 1); 
0880:  MOVLW  01
0881:  BSF    03.5
0882:  MOVWF  41
0883:  MOVWF  42
0884:  BCF    0A.3
0885:  BCF    03.5
0886:  CALL   311
0887:  BSF    0A.3
....................     printf(lcd_putc, "MOD: YAZIM"); 
0888:  MOVLW  61
0889:  BSF    03.6
088A:  MOVWF  0D
088B:  MOVLW  01
088C:  MOVWF  0F
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   38D
0890:  BSF    0A.3
....................     update_lcd(); 
0891:  BCF    0A.3
0892:  CALL   470
0893:  BSF    0A.3
....................  
....................     while (TRUE) 
....................     { 
....................         if (scroll_now) 
0894:  BTFSS  68.3
0895:  GOTO   0A0
....................         { 
....................             scroll_now = 0; 
0896:  BCF    68.3
....................             if (rx_display_buffer[0] != '\0') 
0897:  BSF    03.5
0898:  MOVF   20,F
0899:  BTFSC  03.2
089A:  GOTO   0A1
....................             { 
....................                 scroll_pos++; 
089B:  BCF    03.5
089C:  INCF   6E,F
....................                 update_scroll_line(); 
089D:  BCF    0A.3
089E:  GOTO   4DC
089F:  BSF    0A.3
08A0:  BSF    03.5
....................             } 
....................         } 
....................  
....................         if (rx_data_ready) 
08A1:  BCF    03.5
08A2:  BTFSS  68.0
08A3:  GOTO   0AB
....................         { 
....................             save_bt_to_eeprom(); 
08A4:  BCF    0A.3
08A5:  GOTO   532
08A6:  BSF    0A.3
....................             rx_data_ready = 0; 
08A7:  BCF    68.0
....................             update_lcd(); 
08A8:  BCF    0A.3
08A9:  CALL   470
08AA:  BSF    0A.3
....................         } 
....................  
....................         if (idle_counter > SLEEP_TIMEOUT) 
08AB:  MOVF   6C,W
08AC:  SUBLW  0A
08AD:  BTFSC  03.0
08AE:  GOTO   0B9
08AF:  XORLW  FF
08B0:  BTFSS  03.2
08B1:  GOTO   0B6
08B2:  MOVF   6B,W
08B3:  SUBLW  B8
08B4:  BTFSC  03.0
08B5:  GOTO   0B9
....................         { 
....................             enter_sleep_mode(); 
08B6:  BCF    0A.3
08B7:  GOTO   58B
08B8:  BSF    0A.3
....................         } 
....................  
....................         if (update_needed) 
08B9:  BTFSS  68.2
08BA:  GOTO   0BF
....................         { 
....................             update_lcd(); 
08BB:  BCF    0A.3
08BC:  CALL   470
08BD:  BSF    0A.3
....................             update_needed = 0; 
08BE:  BCF    68.2
....................         } 
....................  
....................         if (!input(BTN_UPLOAD)) 
08BF:  BSF    03.5
08C0:  BSF    06.1
08C1:  BCF    03.5
08C2:  BTFSC  06.1
08C3:  GOTO   191
....................         { 
....................             idle_counter = 0; 
08C4:  CLRF   6C
08C5:  CLRF   6B
....................             int16 hold_counter = 0; 
08C6:  BSF    03.5
08C7:  CLRF   3A
08C8:  CLRF   39
....................  
....................             while (!input(BTN_UPLOAD) && hold_counter < 50) 
08C9:  BSF    06.1
08CA:  BCF    03.5
08CB:  BTFSC  06.1
08CC:  GOTO   0E5
08CD:  BSF    03.5
08CE:  MOVF   3A,F
08CF:  BTFSC  03.2
08D0:  GOTO   0D3
08D1:  BCF    03.5
08D2:  GOTO   0E5
08D3:  MOVF   39,W
08D4:  SUBLW  31
08D5:  BTFSC  03.0
08D6:  GOTO   0D9
08D7:  BCF    03.5
08D8:  GOTO   0E5
....................             { 
....................                 delay_ms(10); 
08D9:  MOVLW  0A
08DA:  MOVWF  45
08DB:  BCF    0A.3
08DC:  BCF    03.5
08DD:  CALL   184
08DE:  BSF    0A.3
....................                 hold_counter++; 
08DF:  BSF    03.5
08E0:  INCF   39,F
08E1:  BTFSC  03.2
08E2:  INCF   3A,F
08E3:  GOTO   0C9
08E4:  BCF    03.5
....................             } 
....................  
....................             if (hold_counter >= 50) 
08E5:  BSF    03.5
08E6:  MOVF   3A,F
08E7:  BTFSS  03.2
08E8:  GOTO   0ED
08E9:  MOVF   39,W
08EA:  SUBLW  31
08EB:  BTFSC  03.0
08EC:  GOTO   15A
....................             { 
....................                 if (text_index > 0) 
08ED:  BCF    03.5
08EE:  MOVF   4D,F
08EF:  BTFSC  03.2
08F0:  GOTO   10E
....................                 { 
....................                     fprintf(BT_MODUL, "%s\r\n", text_buffer); 
08F1:  MOVLW  37
08F2:  MOVWF  04
08F3:  BCF    03.7
08F4:  BCF    0A.3
08F5:  GOTO   5E3
08F6:  BSF    0A.3
08F7:  MOVLW  0D
08F8:  BTFSS  0C.4
08F9:  GOTO   0F8
08FA:  MOVWF  19
08FB:  MOVLW  0A
08FC:  BTFSS  0C.4
08FD:  GOTO   0FC
08FE:  MOVWF  19
....................                     output_high(BUZZER_PIN); 
08FF:  BSF    03.5
0900:  BCF    05.1
0901:  BCF    03.5
0902:  BSF    05.1
....................                     delay_ms(100); 
0903:  MOVLW  64
0904:  BSF    03.5
0905:  MOVWF  45
0906:  BCF    0A.3
0907:  BCF    03.5
0908:  CALL   184
0909:  BSF    0A.3
....................                     output_low(BUZZER_PIN); 
090A:  BSF    03.5
090B:  BCF    05.1
090C:  BCF    03.5
090D:  BCF    05.1
....................                 } 
....................  
....................                 while (!input(BTN_UPLOAD)) 
090E:  BSF    03.5
090F:  BSF    06.1
0910:  BCF    03.5
0911:  BTFSS  06.1
0912:  GOTO   10E
....................                     ; 
....................  
....................                 text_index = 0; 
0913:  CLRF   4D
....................                 text_buffer[0] = '\0'; 
0914:  CLRF   37
....................                 morse_index = 0; 
0915:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0916:  CLRF   2D
....................                 save_text_to_eeprom(); 
0917:  BCF    0A.3
0918:  CALL   603
0919:  BSF    0A.3
....................  
....................                 lcd_putc('\f'); 
091A:  MOVLW  0C
091B:  BSF    03.5
091C:  MOVWF  44
091D:  BCF    0A.3
091E:  BCF    03.5
091F:  CALL   353
0920:  BSF    0A.3
....................                 lcd_locate(1, 1); 
0921:  MOVLW  01
0922:  BSF    03.5
0923:  MOVWF  41
0924:  MOVWF  42
0925:  BCF    0A.3
0926:  BCF    03.5
0927:  CALL   311
0928:  BSF    0A.3
....................                 printf(lcd_putc, "VERI GONDERILDI"); 
0929:  MOVLW  67
092A:  BSF    03.6
092B:  MOVWF  0D
092C:  MOVLW  01
092D:  MOVWF  0F
092E:  BCF    0A.3
092F:  BCF    03.6
0930:  CALL   38D
0931:  BSF    0A.3
....................                 delay_ms(1000); 
0932:  MOVLW  04
0933:  BSF    03.5
0934:  MOVWF  3D
0935:  MOVLW  FA
0936:  MOVWF  45
0937:  BCF    0A.3
0938:  BCF    03.5
0939:  CALL   184
093A:  BSF    0A.3
093B:  BSF    03.5
093C:  DECFSZ 3D,F
093D:  GOTO   135
....................  
....................                 lcd_putc('\f'); 
093E:  MOVLW  0C
093F:  MOVWF  44
0940:  BCF    0A.3
0941:  BCF    03.5
0942:  CALL   353
0943:  BSF    0A.3
....................                 lcd_locate(1, 1); 
0944:  MOVLW  01
0945:  BSF    03.5
0946:  MOVWF  41
0947:  MOVWF  42
0948:  BCF    0A.3
0949:  BCF    03.5
094A:  CALL   311
094B:  BSF    0A.3
....................                 printf(lcd_putc, "MOD: YAZIM"); 
094C:  MOVLW  6F
094D:  BSF    03.6
094E:  MOVWF  0D
094F:  MOVLW  01
0950:  MOVWF  0F
0951:  BCF    0A.3
0952:  BCF    03.6
0953:  CALL   38D
0954:  BSF    0A.3
....................                 update_lcd(); 
0955:  BCF    0A.3
0956:  CALL   470
0957:  BSF    0A.3
....................             } 
0958:  GOTO   191
0959:  BSF    03.5
....................             else 
....................             { 
....................                 while (!input(BTN_UPLOAD)) 
095A:  BSF    06.1
095B:  BCF    03.5
095C:  BTFSC  06.1
095D:  GOTO   160
095E:  BSF    03.5
095F:  GOTO   15A
....................                     ; 
....................  
....................                 if (morse_index > 0) 
0960:  MOVF   4C,F
0961:  BTFSC  03.2
0962:  GOTO   191
....................                 { 
....................                     char final_char = decode_morse(morse_buffer); 
0963:  BSF    03.5
0964:  CLRF   41
0965:  MOVLW  2D
0966:  MOVWF  40
0967:  BCF    0A.3
0968:  BCF    03.5
0969:  CALL   430
096A:  BSF    0A.3
096B:  MOVF   78,W
096C:  BSF    03.5
096D:  MOVWF  3B
....................                     if (text_index < 20 && final_char != '?') 
096E:  BCF    03.5
096F:  MOVF   4D,W
0970:  SUBLW  13
0971:  BTFSS  03.0
0972:  GOTO   18C
0973:  BSF    03.5
0974:  MOVF   3B,W
0975:  SUBLW  3F
0976:  BTFSS  03.2
0977:  GOTO   17A
0978:  BCF    03.5
0979:  GOTO   18C
....................                     { 
....................                         text_buffer[text_index++] = final_char; 
097A:  BCF    03.5
097B:  MOVF   4D,W
097C:  INCF   4D,F
097D:  ADDLW  37
097E:  MOVWF  04
097F:  BCF    03.7
0980:  BSF    03.5
0981:  MOVF   3B,W
0982:  MOVWF  00
....................                         text_buffer[text_index] = '\0'; 
0983:  MOVLW  37
0984:  BCF    03.5
0985:  ADDWF  4D,W
0986:  MOVWF  04
0987:  BCF    03.7
0988:  CLRF   00
....................                         save_text_to_eeprom(); 
0989:  BCF    0A.3
098A:  CALL   603
098B:  BSF    0A.3
....................                     } 
....................                     morse_index = 0; 
098C:  CLRF   4C
....................                     morse_buffer[0] = '\0'; 
098D:  CLRF   2D
....................                     update_lcd(); 
098E:  BCF    0A.3
098F:  CALL   470
0990:  BSF    0A.3
....................                 } 
....................             } 
....................         } 
....................  
....................         if (!input(BTN_DELETE)) 
0991:  BSF    03.5
0992:  BSF    06.2
0993:  BCF    03.5
0994:  BTFSC  06.2
0995:  GOTO   1C2
....................         { 
....................             delay_ms(20); 
0996:  MOVLW  14
0997:  BSF    03.5
0998:  MOVWF  45
0999:  BCF    0A.3
099A:  BCF    03.5
099B:  CALL   184
099C:  BSF    0A.3
....................             if (!input(BTN_DELETE)) 
099D:  BSF    03.5
099E:  BSF    06.2
099F:  BCF    03.5
09A0:  BTFSC  06.2
09A1:  GOTO   1C2
....................             { 
....................                 idle_counter = 0; 
09A2:  CLRF   6C
09A3:  CLRF   6B
....................  
....................                 if (morse_index > 0) 
09A4:  MOVF   4C,F
09A5:  BTFSC  03.2
09A6:  GOTO   1AE
....................                 { 
....................                     morse_buffer[--morse_index] = '\0'; 
09A7:  DECF   4C,F
09A8:  MOVLW  2D
09A9:  ADDWF  4C,W
09AA:  MOVWF  04
09AB:  BCF    03.7
09AC:  CLRF   00
....................                 } 
09AD:  GOTO   1BA
....................                 else if (text_index > 0) 
09AE:  MOVF   4D,F
09AF:  BTFSC  03.2
09B0:  GOTO   1BA
....................                 { 
....................                     text_buffer[--text_index] = '\0'; 
09B1:  DECF   4D,F
09B2:  MOVLW  37
09B3:  ADDWF  4D,W
09B4:  MOVWF  04
09B5:  BCF    03.7
09B6:  CLRF   00
....................                     save_text_to_eeprom(); 
09B7:  BCF    0A.3
09B8:  CALL   603
09B9:  BSF    0A.3
....................                 } 
....................                 update_lcd(); 
09BA:  BCF    0A.3
09BB:  CALL   470
09BC:  BSF    0A.3
....................  
....................                 while (!input(BTN_DELETE)) 
09BD:  BSF    03.5
09BE:  BSF    06.2
09BF:  BCF    03.5
09C0:  BTFSS  06.2
09C1:  GOTO   1BD
....................                     ; 
....................             } 
....................         } 
....................  
....................         if (!input(BTN_RESET)) 
09C2:  BSF    03.5
09C3:  BSF    06.3
09C4:  BCF    03.5
09C5:  BTFSC  06.3
09C6:  GOTO   1D5
....................         { 
....................             idle_counter = 0; 
09C7:  CLRF   6C
09C8:  CLRF   6B
....................             while (!input(BTN_RESET)) 
09C9:  BSF    03.5
09CA:  BSF    06.3
09CB:  BCF    03.5
09CC:  BTFSS  06.3
09CD:  GOTO   1C9
....................                 ; 
....................  
....................             text_index = 0; 
09CE:  CLRF   4D
....................             text_buffer[0] = '\0'; 
09CF:  CLRF   37
....................             morse_index = 0; 
09D0:  CLRF   4C
....................             morse_buffer[0] = '\0'; 
09D1:  CLRF   2D
....................  
....................             update_lcd(); 
09D2:  BCF    0A.3
09D3:  CALL   470
09D4:  BSF    0A.3
....................         } 
....................  
....................         if (!input(BTN_HARD_RESET)) 
09D5:  BSF    03.5
09D6:  BSF    06.4
09D7:  BCF    03.5
09D8:  BTFSC  06.4
09D9:  GOTO   270
....................         { 
....................             idle_counter = 0; 
09DA:  CLRF   6C
09DB:  CLRF   6B
....................  
....................             lcd_putc('\f'); 
09DC:  MOVLW  0C
09DD:  BSF    03.5
09DE:  MOVWF  44
09DF:  BCF    0A.3
09E0:  BCF    03.5
09E1:  CALL   353
09E2:  BSF    0A.3
....................             lcd_locate(1, 1); 
09E3:  MOVLW  01
09E4:  BSF    03.5
09E5:  MOVWF  41
09E6:  MOVWF  42
09E7:  BCF    0A.3
09E8:  BCF    03.5
09E9:  CALL   311
09EA:  BSF    0A.3
....................             printf(lcd_putc, "FORMAT ATILIYOR!"); 
09EB:  MOVLW  75
09EC:  BSF    03.6
09ED:  MOVWF  0D
09EE:  MOVLW  01
09EF:  MOVWF  0F
09F0:  BCF    0A.3
09F1:  BCF    03.6
09F2:  CALL   38D
09F3:  BSF    0A.3
....................             output_high(BUZZER_PIN); 
09F4:  BSF    03.5
09F5:  BCF    05.1
09F6:  BCF    03.5
09F7:  BSF    05.1
....................             delay_ms(200); 
09F8:  MOVLW  C8
09F9:  BSF    03.5
09FA:  MOVWF  45
09FB:  BCF    0A.3
09FC:  BCF    03.5
09FD:  CALL   184
09FE:  BSF    0A.3
....................             output_low(BUZZER_PIN); 
09FF:  BSF    03.5
0A00:  BCF    05.1
0A01:  BCF    03.5
0A02:  BCF    05.1
....................  
....................             while (!input(BTN_HARD_RESET)) 
0A03:  BSF    03.5
0A04:  BSF    06.4
0A05:  BCF    03.5
0A06:  BTFSS  06.4
0A07:  GOTO   203
....................                 ; 
....................  
....................             int8 i; 
....................             for (i = 0; i < 100; i++) 
0A08:  BSF    03.5
0A09:  CLRF   3C
0A0A:  MOVF   3C,W
0A0B:  SUBLW  63
0A0C:  BTFSS  03.0
0A0D:  GOTO   22A
....................             { 
....................                 write_eeprom(i, 0); 
0A0E:  BCF    03.5
0A0F:  MOVF   0B,W
0A10:  MOVWF  77
0A11:  BCF    0B.7
0A12:  BSF    03.5
0A13:  MOVF   3C,W
0A14:  BCF    03.5
0A15:  BSF    03.6
0A16:  MOVWF  0D
0A17:  CLRF   0C
0A18:  BSF    03.5
0A19:  BCF    0C.7
0A1A:  BSF    0C.2
0A1B:  MOVLW  55
0A1C:  MOVWF  0D
0A1D:  MOVLW  AA
0A1E:  MOVWF  0D
0A1F:  BSF    0C.1
0A20:  BTFSC  0C.1
0A21:  GOTO   220
0A22:  BCF    0C.2
0A23:  MOVF   77,W
0A24:  BCF    03.5
0A25:  BCF    03.6
0A26:  IORWF  0B,F
0A27:  BSF    03.5
0A28:  INCF   3C,F
0A29:  GOTO   20A
....................             } 
....................  
....................             text_index = 0; 
0A2A:  BCF    03.5
0A2B:  CLRF   4D
....................             text_buffer[0] = '\0'; 
0A2C:  CLRF   37
....................             morse_index = 0; 
0A2D:  CLRF   4C
....................             morse_buffer[0] = '\0'; 
0A2E:  CLRF   2D
....................             rx_display_buffer[0] = '\0'; 
0A2F:  BSF    03.5
0A30:  CLRF   20
....................  
....................             lcd_putc('\f'); 
0A31:  MOVLW  0C
0A32:  MOVWF  44
0A33:  BCF    0A.3
0A34:  BCF    03.5
0A35:  CALL   353
0A36:  BSF    0A.3
....................             lcd_locate(1, 1); 
0A37:  MOVLW  01
0A38:  BSF    03.5
0A39:  MOVWF  41
0A3A:  MOVWF  42
0A3B:  BCF    0A.3
0A3C:  BCF    03.5
0A3D:  CALL   311
0A3E:  BSF    0A.3
....................             printf(lcd_putc, "MOD: YAZIM"); 
0A3F:  MOVLW  7E
0A40:  BSF    03.6
0A41:  MOVWF  0D
0A42:  MOVLW  01
0A43:  MOVWF  0F
0A44:  BCF    0A.3
0A45:  BCF    03.6
0A46:  CALL   38D
0A47:  BSF    0A.3
....................             update_lcd(); 
0A48:  BCF    0A.3
0A49:  CALL   470
0A4A:  BSF    0A.3
....................  
....................             output_high(BUZZER_PIN); 
0A4B:  BSF    03.5
0A4C:  BCF    05.1
0A4D:  BCF    03.5
0A4E:  BSF    05.1
....................             delay_ms(50); 
0A4F:  MOVLW  32
0A50:  BSF    03.5
0A51:  MOVWF  45
0A52:  BCF    0A.3
0A53:  BCF    03.5
0A54:  CALL   184
0A55:  BSF    0A.3
....................             output_low(BUZZER_PIN); 
0A56:  BSF    03.5
0A57:  BCF    05.1
0A58:  BCF    03.5
0A59:  BCF    05.1
....................             delay_ms(50); 
0A5A:  MOVLW  32
0A5B:  BSF    03.5
0A5C:  MOVWF  45
0A5D:  BCF    0A.3
0A5E:  BCF    03.5
0A5F:  CALL   184
0A60:  BSF    0A.3
....................             output_high(BUZZER_PIN); 
0A61:  BSF    03.5
0A62:  BCF    05.1
0A63:  BCF    03.5
0A64:  BSF    05.1
....................             delay_ms(50); 
0A65:  MOVLW  32
0A66:  BSF    03.5
0A67:  MOVWF  45
0A68:  BCF    0A.3
0A69:  BCF    03.5
0A6A:  CALL   184
0A6B:  BSF    0A.3
....................             output_low(BUZZER_PIN); 
0A6C:  BSF    03.5
0A6D:  BCF    05.1
0A6E:  BCF    03.5
0A6F:  BCF    05.1
....................         } 
0A70:  GOTO   094
....................     } 
.................... } 
0A71:  SLEEP

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
