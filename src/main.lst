CCS PCM C Compiler, Version 5.007, 61971               19-Ara-25 16:20

               Filename:   C:\Users\Alihan\Desktop\DERS\Pic_Telegraph\src\main.lst

               ROM used:   1457 words (18%)
                           Largest free fragment is 2048
               RAM used:   58 (16%) at main() level
                           79 (21%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   454
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.0
001A:  GOTO   01D
001B:  BTFSC  0C.0
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   08C
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
0031:  BCF    0A.0
0032:  BCF    0A.1
0033:  BCF    0A.2
0034:  ADDWF  02,F
0035:  RETLW  28
0036:  RETLW  0C
0037:  RETLW  01
0038:  RETLW  06
0039:  BCF    0A.0
003A:  BCF    0A.1
003B:  BCF    0A.2
003C:  ADDWF  02,F
003D:  RETLW  00
003E:  RETLW  00
003F:  RETLW  45
0040:  RETLW  54
0041:  RETLW  49
0042:  RETLW  41
0043:  RETLW  4E
0044:  RETLW  4D
0045:  RETLW  53
0046:  RETLW  55
0047:  RETLW  52
0048:  RETLW  57
0049:  RETLW  44
004A:  RETLW  4B
004B:  RETLW  47
004C:  RETLW  4F
004D:  RETLW  48
004E:  RETLW  56
004F:  RETLW  46
0050:  RETLW  00
0051:  RETLW  4C
0052:  RETLW  00
0053:  RETLW  50
0054:  RETLW  4A
0055:  RETLW  42
0056:  RETLW  58
0057:  RETLW  43
0058:  RETLW  59
0059:  RETLW  5A
005A:  RETLW  51
005B:  RETLW  00
005C:  RETLW  00
005D:  RETLW  35
005E:  RETLW  34
005F:  RETLW  00
0060:  RETLW  33
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  32
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  RETLW  00
0069:  RETLW  00
006A:  RETLW  00
006B:  RETLW  00
006C:  RETLW  31
006D:  RETLW  36
006E:  RETLW  00
006F:  RETLW  00
0070:  RETLW  00
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  00
0074:  RETLW  00
0075:  RETLW  37
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  38
007A:  RETLW  00
007B:  RETLW  39
007C:  RETLW  30
007D:  DATA 20,10
007E:  DATA 00,00
007F:  DATA D5,2C
0080:  DATA CB,2A
0081:  DATA A0,26
0082:  DATA 4F,22
0083:  DATA 55,17
0084:  DATA 2E,17
0085:  DATA 00,01
0086:  DATA CD,27
0087:  DATA 44,1D
0088:  DATA A0,2C
0089:  DATA 41,2D
008A:  DATA C9,26
008B:  DATA 00,00
*
00E6:  DATA CD,37
00E7:  DATA F2,39
00E8:  DATA 20,2A
00E9:  DATA 65,36
00EA:  DATA 67,39
00EB:  DATA 61,33
00EC:  DATA 00,01
00ED:  DATA CD,27
00EE:  DATA 44,1D
00EF:  DATA A0,2C
00F0:  DATA 41,2D
00F1:  DATA C9,26
00F2:  DATA 00,01
00F3:  DATA C6,27
00F4:  DATA D2,26
00F5:  DATA 41,2A
00F6:  DATA A0,20
00F7:  DATA D4,24
00F8:  DATA CC,24
00F9:  DATA D9,27
00FA:  DATA D2,10
00FB:  DATA 00,01
00FC:  DATA CD,27
00FD:  DATA 44,1D
00FE:  DATA A0,2C
00FF:  DATA 41,2D
0100:  DATA C9,26
0101:  DATA 00,00
*
029A:  MOVF   0B,W
029B:  MOVWF  58
029C:  BCF    0B.7
029D:  BSF    03.5
029E:  BSF    03.6
029F:  BSF    0C.7
02A0:  BSF    0C.0
02A1:  NOP
02A2:  NOP
02A3:  BCF    03.5
02A4:  MOVF   0C,W
02A5:  ANDLW  7F
02A6:  BTFSC  03.2
02A7:  GOTO   2E1
02A8:  BCF    03.6
02A9:  MOVWF  59
02AA:  BSF    03.6
02AB:  MOVF   0D,W
02AC:  BCF    03.6
02AD:  MOVWF  5A
02AE:  BSF    03.6
02AF:  MOVF   0F,W
02B0:  BCF    03.6
02B1:  MOVWF  5B
02B2:  MOVF   59,W
02B3:  MOVWF  5C
02B4:  CALL   26E
02B5:  MOVF   5A,W
02B6:  BSF    03.6
02B7:  MOVWF  0D
02B8:  BCF    03.6
02B9:  MOVF   5B,W
02BA:  BSF    03.6
02BB:  MOVWF  0F
02BC:  BSF    03.5
02BD:  BSF    0C.7
02BE:  BSF    0C.0
02BF:  NOP
02C0:  NOP
02C1:  BCF    03.5
02C2:  RLF    0C,W
02C3:  RLF    0E,W
02C4:  ANDLW  7F
02C5:  BTFSC  03.2
02C6:  GOTO   2E1
02C7:  BCF    03.6
02C8:  MOVWF  59
02C9:  BSF    03.6
02CA:  MOVF   0D,W
02CB:  BCF    03.6
02CC:  MOVWF  5A
02CD:  BSF    03.6
02CE:  MOVF   0F,W
02CF:  BCF    03.6
02D0:  MOVWF  5B
02D1:  MOVF   59,W
02D2:  MOVWF  5C
02D3:  CALL   26E
02D4:  MOVF   5A,W
02D5:  BSF    03.6
02D6:  MOVWF  0D
02D7:  BCF    03.6
02D8:  MOVF   5B,W
02D9:  BSF    03.6
02DA:  MOVWF  0F
02DB:  INCF   0D,F
02DC:  BTFSC  03.2
02DD:  INCF   0F,F
02DE:  BCF    03.6
02DF:  GOTO   29D
02E0:  BSF    03.6
02E1:  BCF    03.6
02E2:  BTFSC  58.7
02E3:  BSF    0B.7
02E4:  RETURN
02E5:  MOVF   00,F
02E6:  BTFSC  03.2
02E7:  GOTO   2FA
02E8:  CLRF   59
02E9:  MOVF   04,W
02EA:  MOVWF  58
02EB:  BCF    59.0
02EC:  BTFSC  03.7
02ED:  BSF    59.0
02EE:  MOVF   00,W
02EF:  MOVWF  5C
02F0:  CALL   26E
02F1:  MOVF   58,W
02F2:  MOVWF  04
02F3:  BCF    03.7
02F4:  BTFSC  59.0
02F5:  BSF    03.7
02F6:  INCF   04,F
02F7:  BTFSC  03.2
02F8:  INCF   05,F
02F9:  GOTO   2E5
02FA:  RETURN
....................  
.................... #list 
....................  
.................... // WDT Eklendi 
.................... #fuses INTRC_IO, WDT, NOPROTECT, NOLVP, NOBROWNOUT, NOPUT, NOMCLR 
.................... #use delay(clock = 8000000) 
*
0102:  MOVLW  5D
0103:  MOVWF  04
0104:  BCF    03.7
0105:  MOVF   00,W
0106:  BTFSC  03.2
0107:  GOTO   115
0108:  MOVLW  02
0109:  MOVWF  78
010A:  CLRF   77
010B:  DECFSZ 77,F
010C:  GOTO   10B
010D:  DECFSZ 78,F
010E:  GOTO   10A
010F:  MOVLW  97
0110:  MOVWF  77
0111:  DECFSZ 77,F
0112:  GOTO   111
0113:  DECFSZ 00,F
0114:  GOTO   108
0115:  RETURN
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0473:  BCF    03.6
0474:  CLRF   27
0475:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
02FB:  MOVF   5E,W
02FC:  MOVWF  60
02FD:  MOVF   5D,W
02FE:  MOVWF  5F
02FF:  MOVF   60,W
0300:  MOVWF  7A
0301:  MOVF   5F,W
0302:  MOVWF  04
0303:  BCF    03.7
0304:  BTFSC  7A.0
0305:  BSF    03.7
0306:  MOVF   00,F
0307:  BTFSC  03.2
0308:  GOTO   30D
0309:  INCF   5F,F
030A:  BTFSC  03.2
030B:  INCF   60,F
030C:  GOTO   2FF
....................    return(sc - s); 
030D:  MOVF   5D,W
030E:  SUBWF  5F,W
030F:  MOVWF  77
0310:  MOVF   60,W
0311:  MOVWF  7A
0312:  MOVF   5E,W
0313:  BTFSS  03.0
0314:  INCFSZ 5E,W
0315:  SUBWF  7A,F
0316:  MOVF   77,W
0317:  MOVWF  78
0318:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LCD_RS_PIN PIN_D1 
.................... #define LCD_RW_PIN PIN_D2 
.................... #define LCD_ENABLE_PIN PIN_D3 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... #include <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
017B:  BSF    08.4
....................    output_float(LCD_DATA5); 
017C:  BSF    08.5
....................    output_float(LCD_DATA6); 
017D:  BSF    08.6
....................    output_float(LCD_DATA7); 
017E:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
017F:  BCF    03.5
0180:  BSF    08.2
0181:  BSF    03.5
0182:  BCF    08.2
....................    delay_cycles(1); 
0183:  NOP
....................    lcd_output_enable(1); 
0184:  BCF    03.5
0185:  BSF    08.3
0186:  BSF    03.5
0187:  BCF    08.3
....................    delay_cycles(1); 
0188:  NOP
....................    high = lcd_read_nibble(); 
0189:  BCF    03.5
018A:  CALL   142
018B:  MOVF   78,W
018C:  MOVWF  64
....................        
....................    lcd_output_enable(0); 
018D:  BCF    08.3
018E:  BSF    03.5
018F:  BCF    08.3
....................    delay_cycles(1); 
0190:  NOP
....................    lcd_output_enable(1); 
0191:  BCF    03.5
0192:  BSF    08.3
0193:  BSF    03.5
0194:  BCF    08.3
....................    delay_us(1); 
0195:  GOTO   196
....................    low = lcd_read_nibble(); 
0196:  BCF    03.5
0197:  CALL   142
0198:  MOVF   78,W
0199:  MOVWF  63
....................        
....................    lcd_output_enable(0); 
019A:  BCF    08.3
019B:  BSF    03.5
019C:  BCF    08.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
019D:  BCF    08.4
....................    output_drive(LCD_DATA5); 
019E:  BCF    08.5
....................    output_drive(LCD_DATA6); 
019F:  BCF    08.6
....................    output_drive(LCD_DATA7); 
01A0:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01A1:  BCF    03.5
01A2:  SWAPF  64,W
01A3:  MOVWF  77
01A4:  MOVLW  F0
01A5:  ANDWF  77,F
01A6:  MOVF   77,W
01A7:  IORWF  63,W
01A8:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0142:  CLRF   65
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0143:  BSF    03.5
0144:  BSF    08.4
0145:  MOVLW  00
0146:  BCF    03.5
0147:  BTFSC  08.4
0148:  MOVLW  01
0149:  IORWF  65,F
....................    n |= input(LCD_DATA5) << 1; 
014A:  BSF    03.5
014B:  BSF    08.5
014C:  MOVLW  00
014D:  BCF    03.5
014E:  BTFSC  08.5
014F:  MOVLW  01
0150:  MOVWF  77
0151:  BCF    03.0
0152:  RLF    77,F
0153:  MOVF   77,W
0154:  IORWF  65,F
....................    n |= input(LCD_DATA6) << 2; 
0155:  BSF    03.5
0156:  BSF    08.6
0157:  MOVLW  00
0158:  BCF    03.5
0159:  BTFSC  08.6
015A:  MOVLW  01
015B:  MOVWF  77
015C:  RLF    77,F
015D:  RLF    77,F
015E:  MOVLW  FC
015F:  ANDWF  77,F
0160:  MOVF   77,W
0161:  IORWF  65,F
....................    n |= input(LCD_DATA7) << 3; 
0162:  BSF    03.5
0163:  BSF    08.7
0164:  MOVLW  00
0165:  BCF    03.5
0166:  BTFSC  08.7
0167:  MOVLW  01
0168:  MOVWF  77
0169:  RLF    77,F
016A:  RLF    77,F
016B:  RLF    77,F
016C:  MOVLW  F8
016D:  ANDWF  77,F
016E:  MOVF   77,W
016F:  IORWF  65,F
....................     
....................    return(n); 
0170:  MOVF   65,W
0171:  MOVWF  78
....................   #else 
0172:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0116:  BTFSC  64.0
0117:  GOTO   11A
0118:  BCF    08.4
0119:  GOTO   11B
011A:  BSF    08.4
011B:  BSF    03.5
011C:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
011D:  BCF    03.5
011E:  BTFSC  64.1
011F:  GOTO   122
0120:  BCF    08.5
0121:  GOTO   123
0122:  BSF    08.5
0123:  BSF    03.5
0124:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0125:  BCF    03.5
0126:  BTFSC  64.2
0127:  GOTO   12A
0128:  BCF    08.6
0129:  GOTO   12B
012A:  BSF    08.6
012B:  BSF    03.5
012C:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
012D:  BCF    03.5
012E:  BTFSC  64.3
012F:  GOTO   132
0130:  BCF    08.7
0131:  GOTO   133
0132:  BSF    08.7
0133:  BSF    03.5
0134:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0135:  NOP
....................    lcd_output_enable(1); 
0136:  BCF    03.5
0137:  BSF    08.3
0138:  BSF    03.5
0139:  BCF    08.3
....................    delay_us(2); 
013A:  GOTO   13B
013B:  GOTO   13C
....................    lcd_output_enable(0); 
013C:  BCF    03.5
013D:  BCF    08.3
013E:  BSF    03.5
013F:  BCF    08.3
0140:  BCF    03.5
0141:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0173:  BSF    03.5
0174:  BCF    08.3
....................    lcd_rs_tris(); 
0175:  BCF    08.1
....................    lcd_rw_tris(); 
0176:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0177:  BCF    03.5
0178:  BCF    08.1
0179:  BSF    03.5
017A:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01A9:  MOVF   78,W
01AA:  MOVWF  63
01AB:  BTFSS  63.7
01AC:  GOTO   1AF
01AD:  BSF    03.5
01AE:  GOTO   17B
....................    lcd_output_rs(address); 
01AF:  MOVF   61,F
01B0:  BTFSS  03.2
01B1:  GOTO   1B4
01B2:  BCF    08.1
01B3:  GOTO   1B5
01B4:  BSF    08.1
01B5:  BSF    03.5
01B6:  BCF    08.1
....................    delay_cycles(1); 
01B7:  NOP
....................    lcd_output_rw(0); 
01B8:  BCF    03.5
01B9:  BCF    08.2
01BA:  BSF    03.5
01BB:  BCF    08.2
....................    delay_cycles(1); 
01BC:  NOP
....................    lcd_output_enable(0); 
01BD:  BCF    03.5
01BE:  BCF    08.3
01BF:  BSF    03.5
01C0:  BCF    08.3
....................    lcd_send_nibble(n >> 4); 
01C1:  BCF    03.5
01C2:  SWAPF  62,W
01C3:  MOVWF  63
01C4:  MOVLW  0F
01C5:  ANDWF  63,F
01C6:  MOVF   63,W
01C7:  MOVWF  64
01C8:  CALL   116
....................    lcd_send_nibble(n & 0xf); 
01C9:  MOVF   62,W
01CA:  ANDLW  0F
01CB:  MOVWF  63
01CC:  MOVWF  64
01CD:  CALL   116
01CE:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01CF:  BSF    03.5
01D0:  BCF    08.4
....................    output_drive(LCD_DATA5); 
01D1:  BCF    08.5
....................    output_drive(LCD_DATA6); 
01D2:  BCF    08.6
....................    output_drive(LCD_DATA7); 
01D3:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01D4:  BCF    08.3
....................    lcd_rs_tris(); 
01D5:  BCF    08.1
....................    lcd_rw_tris(); 
01D6:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
01D7:  BCF    03.5
01D8:  BCF    08.1
01D9:  BSF    03.5
01DA:  BCF    08.1
....................    lcd_output_rw(0); 
01DB:  BCF    03.5
01DC:  BCF    08.2
01DD:  BSF    03.5
01DE:  BCF    08.2
....................    lcd_output_enable(0); 
01DF:  BCF    03.5
01E0:  BCF    08.3
01E1:  BSF    03.5
01E2:  BCF    08.3
....................      
....................    delay_ms(15); 
01E3:  MOVLW  0F
01E4:  BCF    03.5
01E5:  MOVWF  5D
01E6:  CALL   102
....................    for(i=1;i<=3;++i) 
01E7:  MOVLW  01
01E8:  MOVWF  55
01E9:  MOVF   55,W
01EA:  SUBLW  03
01EB:  BTFSS  03.0
01EC:  GOTO   1F5
....................    { 
....................        lcd_send_nibble(3); 
01ED:  MOVLW  03
01EE:  MOVWF  64
01EF:  CALL   116
....................        delay_ms(5); 
01F0:  MOVLW  05
01F1:  MOVWF  5D
01F2:  CALL   102
01F3:  INCF   55,F
01F4:  GOTO   1E9
....................    } 
....................     
....................    lcd_send_nibble(2); 
01F5:  MOVLW  02
01F6:  MOVWF  64
01F7:  CALL   116
....................    delay_ms(5); 
01F8:  MOVLW  05
01F9:  MOVWF  5D
01FA:  CALL   102
....................    for(i=0;i<=3;++i) 
01FB:  CLRF   55
01FC:  MOVF   55,W
01FD:  SUBLW  03
01FE:  BTFSS  03.0
01FF:  GOTO   209
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0200:  MOVF   55,W
0201:  CALL   031
0202:  MOVWF  56
0203:  CLRF   61
0204:  MOVF   56,W
0205:  MOVWF  62
0206:  CALL   173
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0207:  INCF   55,F
0208:  GOTO   1FC
0209:  RETURN
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
025C:  DECFSZ 5E,W
025D:  GOTO   25F
025E:  GOTO   262
....................       address=LCD_LINE_TWO; 
025F:  MOVLW  40
0260:  MOVWF  5F
0261:  GOTO   263
....................    else 
....................       address=0; 
0262:  CLRF   5F
....................       
....................    address+=x-1; 
0263:  MOVLW  01
0264:  SUBWF  5D,W
0265:  ADDWF  5F,F
....................    lcd_send_byte(0,0x80|address); 
0266:  MOVF   5F,W
0267:  IORLW  80
0268:  MOVWF  60
0269:  CLRF   61
026A:  MOVF   60,W
026B:  MOVWF  62
026C:  CALL   173
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
026D:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
026E:  MOVF   5C,W
026F:  XORLW  07
0270:  BTFSC  03.2
0271:  GOTO   27C
0272:  XORLW  0B
0273:  BTFSC  03.2
0274:  GOTO   281
0275:  XORLW  06
0276:  BTFSC  03.2
0277:  GOTO   289
0278:  XORLW  02
0279:  BTFSC  03.2
027A:  GOTO   28F
027B:  GOTO   294
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
027C:  MOVLW  01
027D:  MOVWF  5D
027E:  MOVWF  5E
027F:  CALL   25C
0280:  GOTO   299
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0281:  CLRF   61
0282:  MOVLW  01
0283:  MOVWF  62
0284:  CALL   173
....................                      delay_ms(2); 
0285:  MOVLW  02
0286:  MOVWF  5D
0287:  CALL   102
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0288:  GOTO   299
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0289:  MOVLW  01
028A:  MOVWF  5D
028B:  MOVLW  02
028C:  MOVWF  5E
028D:  CALL   25C
028E:  GOTO   299
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
028F:  CLRF   61
0290:  MOVLW  10
0291:  MOVWF  62
0292:  CALL   173
0293:  GOTO   299
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0294:  MOVLW  01
0295:  MOVWF  61
0296:  MOVF   5C,W
0297:  MOVWF  62
0298:  CALL   173
....................      #endif 
....................    } 
0299:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define LED_PIN PIN_A0 
.................... #define BUZZER_PIN PIN_A1 
....................  
.................... #define BTN_SIGNAL PIN_B0 
.................... #define BTN_UPLOAD PIN_B1 
.................... #define BTN_DELETE PIN_B2 
.................... #define BTN_RESET PIN_B3 
.................... #define BTN_HARD_RESET PIN_B4 // YEN: Hard Reset Pini 
....................  
.................... char morse_buffer[10]; 
.................... char text_buffer[21]; 
.................... int8 morse_index = 0; 
.................... int8 text_index = 0; 
....................  
.................... volatile int16 press_counter = 0; 
.................... volatile int16 idle_counter = 0; 
.................... #define SLEEP_TIMEOUT 3000 
....................  
.................... int1 btn_prev_state = 0; 
.................... int1 update_needed = 0; 
....................  
.................... const char morse_tree[64] = { 
....................     0, 0, 'E', 'T', 'I', 'A', 'N', 'M', 'S', 'U', 'R', 'W', 'D', 'K', 'G', 'O', 
....................     'H', 'V', 'F', 0, 'L', 0, 'P', 'J', 'B', 'X', 'C', 'Y', 'Z', 'Q', 0, 0, 
....................     '5', '4', 0, '3', 0, 0, 0, '2', 0, 0, 0, 0, 0, 0, 0, '1', 
....................     '6', 0, 0, 0, 0, 0, 0, 0, '7', 0, 0, 0, '8', 0, '9', '0'}; 
....................  
.................... void save_text_to_eeprom() 
.................... { 
....................     int8 i; 
....................     write_eeprom(0, text_index); 
*
0412:  MOVF   0B,W
0413:  MOVWF  77
0414:  BCF    0B.7
0415:  BSF    03.6
0416:  CLRF   0D
0417:  BCF    03.6
0418:  MOVF   4D,W
0419:  BSF    03.6
041A:  MOVWF  0C
041B:  BSF    03.5
041C:  BCF    0C.7
041D:  BSF    0C.2
041E:  MOVLW  55
041F:  MOVWF  0D
0420:  MOVLW  AA
0421:  MOVWF  0D
0422:  BSF    0C.1
0423:  BTFSC  0C.1
0424:  GOTO   423
0425:  BCF    0C.2
0426:  MOVF   77,W
0427:  BCF    03.5
0428:  BCF    03.6
0429:  IORWF  0B,F
....................     for (i = 0; i < text_index; i++) 
042A:  CLRF   55
042B:  MOVF   4D,W
042C:  SUBWF  55,W
042D:  BTFSC  03.0
042E:  GOTO   453
....................     { 
....................         write_eeprom(i + 1, text_buffer[i]); 
042F:  MOVLW  01
0430:  ADDWF  55,W
0431:  MOVWF  56
0432:  MOVLW  37
0433:  ADDWF  55,W
0434:  MOVWF  04
0435:  BCF    03.7
0436:  MOVF   00,W
0437:  MOVWF  57
0438:  MOVF   0B,W
0439:  MOVWF  77
043A:  BCF    0B.7
043B:  MOVF   56,W
043C:  BSF    03.6
043D:  MOVWF  0D
043E:  BCF    03.6
043F:  MOVF   57,W
0440:  BSF    03.6
0441:  MOVWF  0C
0442:  BSF    03.5
0443:  BCF    0C.7
0444:  BSF    0C.2
0445:  MOVLW  55
0446:  MOVWF  0D
0447:  MOVLW  AA
0448:  MOVWF  0D
0449:  BSF    0C.1
044A:  BTFSC  0C.1
044B:  GOTO   44A
044C:  BCF    0C.2
044D:  MOVF   77,W
044E:  BCF    03.5
044F:  BCF    03.6
0450:  IORWF  0B,F
0451:  INCF   55,F
0452:  GOTO   42B
....................     } 
0453:  RETURN
.................... } 
....................  
.................... void load_text_from_eeprom() 
.................... { 
....................     int8 i; 
....................     text_index = read_eeprom(0); 
*
020A:  BSF    03.6
020B:  CLRF   0D
020C:  BSF    03.5
020D:  BCF    0C.7
020E:  BSF    0C.0
020F:  BCF    03.5
0210:  MOVF   0C,W
0211:  BCF    03.6
0212:  MOVWF  4D
....................     if (text_index > 20) 
0213:  MOVF   4D,W
0214:  SUBLW  14
0215:  BTFSS  03.0
....................         text_index = 0; 
0216:  CLRF   4D
....................     for (i = 0; i < text_index; i++) 
0217:  CLRF   55
0218:  MOVF   4D,W
0219:  SUBWF  55,W
021A:  BTFSC  03.0
021B:  GOTO   22F
....................     { 
....................         text_buffer[i] = read_eeprom(i + 1); 
021C:  MOVLW  37
021D:  ADDWF  55,W
021E:  MOVWF  04
021F:  BCF    03.7
0220:  MOVLW  01
0221:  ADDWF  55,W
0222:  MOVWF  58
0223:  MOVF   58,W
0224:  BSF    03.6
0225:  MOVWF  0D
0226:  BSF    03.5
0227:  BCF    0C.7
0228:  BSF    0C.0
0229:  BCF    03.5
022A:  MOVF   0C,W
022B:  MOVWF  00
022C:  BCF    03.6
022D:  INCF   55,F
022E:  GOTO   218
....................     } 
....................     text_buffer[text_index] = '\0'; 
022F:  MOVLW  37
0230:  ADDWF  4D,W
0231:  MOVWF  04
0232:  BCF    03.7
0233:  CLRF   00
0234:  BCF    0A.3
0235:  BCF    0A.4
0236:  GOTO   49B (RETURN)
.................... } 
....................  
.................... char decode_morse(char *code) 
*
0319:  MOVLW  01
031A:  MOVWF  5C
.................... { 
....................     int8 i, len; 
....................     int8 index = 1; 
....................     len = strlen(code); 
031B:  MOVF   59,W
031C:  MOVWF  5E
031D:  MOVF   58,W
031E:  MOVWF  5D
031F:  CALL   2FB
0320:  MOVF   78,W
0321:  MOVWF  5B
....................     if (len == 0) 
0322:  MOVF   5B,F
0323:  BTFSS  03.2
0324:  GOTO   328
....................         return ' '; 
0325:  MOVLW  20
0326:  MOVWF  78
0327:  GOTO   34E
....................  
....................     for (i = 0; i < len; i++) 
0328:  CLRF   5A
0329:  MOVF   5B,W
032A:  SUBWF  5A,W
032B:  BTFSC  03.0
032C:  GOTO   342
....................     { 
....................         index = index << 1; 
032D:  BCF    03.0
032E:  RLF    5C,F
....................         if (code[i] == '-') 
032F:  MOVF   5A,W
0330:  ADDWF  58,W
0331:  MOVWF  04
0332:  BCF    03.7
0333:  BTFSC  59.0
0334:  BSF    03.7
0335:  MOVF   00,W
0336:  SUBLW  2D
0337:  BTFSC  03.2
....................             index |= 1; 
0338:  BSF    5C.0
....................         if (index >= 64) 
0339:  MOVF   5C,W
033A:  SUBLW  3F
033B:  BTFSC  03.0
033C:  GOTO   340
....................             return '?'; 
033D:  MOVLW  3F
033E:  MOVWF  78
033F:  GOTO   34E
0340:  INCF   5A,F
0341:  GOTO   329
....................     } 
....................     if (morse_tree[index] == 0) 
0342:  MOVF   5C,W
0343:  CALL   039
0344:  XORLW  00
0345:  BTFSS  03.2
0346:  GOTO   34A
....................         return '?'; 
0347:  MOVLW  3F
0348:  MOVWF  78
0349:  GOTO   34E
....................     return morse_tree[index]; 
034A:  MOVF   5C,W
034B:  CALL   039
034C:  MOVWF  78
034D:  MOVWF  78
034E:  RETURN
.................... } 
....................  
.................... void lcd_locate(int8 x, int8 y) 
.................... { 
....................     int8 address; 
....................     switch (y) 
*
0237:  MOVF   59,W
0238:  XORLW  01
0239:  BTFSC  03.2
023A:  GOTO   245
023B:  XORLW  03
023C:  BTFSC  03.2
023D:  GOTO   247
023E:  XORLW  01
023F:  BTFSC  03.2
0240:  GOTO   24A
0241:  XORLW  07
0242:  BTFSC  03.2
0243:  GOTO   24D
0244:  GOTO   250
....................     { 
....................     case 1: 
....................         address = 0x00; 
0245:  CLRF   5A
....................         break; 
0246:  GOTO   251
....................     case 2: 
....................         address = 0x40; 
0247:  MOVLW  40
0248:  MOVWF  5A
....................         break; 
0249:  GOTO   251
....................     case 3: 
....................         address = 0x14; 
024A:  MOVLW  14
024B:  MOVWF  5A
....................         break; 
024C:  GOTO   251
....................     case 4: 
....................         address = 0x54; 
024D:  MOVLW  54
024E:  MOVWF  5A
....................         break; 
024F:  GOTO   251
....................     default: 
....................         address = 0x00; 
0250:  CLRF   5A
....................         break; 
....................     } 
....................     address += x - 1; 
0251:  MOVLW  01
0252:  SUBWF  58,W
0253:  ADDWF  5A,F
....................     lcd_send_byte(0, 0x80 | address); 
0254:  MOVF   5A,W
0255:  IORLW  80
0256:  MOVWF  5B
0257:  CLRF   61
0258:  MOVF   5B,W
0259:  MOVWF  62
025A:  CALL   173
025B:  RETURN
.................... } 
....................  
.................... void update_lcd() 
.................... { 
....................     int8 i, len; 
....................     char preview_char; 
....................  
....................     lcd_locate(1, 2); 
*
034F:  MOVLW  01
0350:  MOVWF  58
0351:  MOVLW  02
0352:  MOVWF  59
0353:  CALL   237
....................     printf(lcd_putc, "%s", text_buffer); 
0354:  MOVLW  37
0355:  MOVWF  04
0356:  BCF    03.7
0357:  CALL   2E5
....................  
....................     if (morse_index > 0) 
0358:  MOVF   4C,F
0359:  BTFSC  03.2
035A:  GOTO   368
....................     { 
....................         preview_char = decode_morse(morse_buffer); 
035B:  CLRF   59
035C:  MOVLW  2D
035D:  MOVWF  58
035E:  CALL   319
035F:  MOVF   78,W
0360:  MOVWF  57
....................         lcd_putc(preview_char); 
0361:  MOVF   57,W
0362:  MOVWF  5C
0363:  CALL   26E
....................         lcd_putc('<'); 
0364:  MOVLW  3C
0365:  MOVWF  5C
0366:  CALL   26E
....................     } 
0367:  GOTO   36F
....................     else 
....................     { 
....................         lcd_putc("  "); 
0368:  MOVLW  7D
0369:  BSF    03.6
036A:  MOVWF  0D
036B:  MOVLW  00
036C:  MOVWF  0F
036D:  BCF    03.6
036E:  CALL   29A
....................     } 
....................  
....................     len = strlen(text_buffer) + (morse_index > 0 ? 2 : 0); 
036F:  CLRF   5E
0370:  MOVLW  37
0371:  MOVWF  5D
0372:  CALL   2FB
0373:  MOVF   78,W
0374:  MOVWF  58
0375:  MOVF   4C,F
0376:  BTFSC  03.2
0377:  GOTO   37B
0378:  CLRF   7A
0379:  MOVLW  02
037A:  GOTO   37D
037B:  CLRF   7A
037C:  MOVLW  00
037D:  ADDWF  58,W
037E:  MOVWF  56
....................     for (i = len; i < 20; i++) 
037F:  MOVF   56,W
0380:  MOVWF  55
0381:  MOVF   55,W
0382:  SUBLW  13
0383:  BTFSS  03.0
0384:  GOTO   38A
....................         lcd_putc(' '); 
0385:  MOVLW  20
0386:  MOVWF  5C
0387:  CALL   26E
0388:  INCF   55,F
0389:  GOTO   381
....................  
....................     lcd_locate(1, 3); 
038A:  MOVLW  01
038B:  MOVWF  58
038C:  MOVLW  03
038D:  MOVWF  59
038E:  CALL   237
....................     printf(lcd_putc, "%s", morse_buffer); 
038F:  MOVLW  2D
0390:  MOVWF  04
0391:  BCF    03.7
0392:  CALL   2E5
....................     len = strlen(morse_buffer); 
0393:  CLRF   5E
0394:  MOVLW  2D
0395:  MOVWF  5D
0396:  CALL   2FB
0397:  MOVF   78,W
0398:  MOVWF  56
....................     for (i = len; i < 20; i++) 
0399:  MOVF   56,W
039A:  MOVWF  55
039B:  MOVF   55,W
039C:  SUBLW  13
039D:  BTFSS  03.0
039E:  GOTO   3A4
....................         lcd_putc(' '); 
039F:  MOVLW  20
03A0:  MOVWF  5C
03A1:  CALL   26E
03A2:  INCF   55,F
03A3:  GOTO   39B
03A4:  RETURN
.................... } 
....................  
.................... void enter_sleep_mode() 
.................... { 
....................     lcd_putc('\f'); 
03A5:  MOVLW  0C
03A6:  MOVWF  5C
03A7:  CALL   26E
....................     lcd_locate(1, 1); 
03A8:  MOVLW  01
03A9:  MOVWF  58
03AA:  MOVWF  59
03AB:  CALL   237
....................     printf(lcd_putc, "UYKU MODU..."); 
03AC:  MOVLW  7F
03AD:  BSF    03.6
03AE:  MOVWF  0D
03AF:  MOVLW  00
03B0:  MOVWF  0F
03B1:  BCF    03.6
03B2:  CALL   29A
....................     delay_ms(500); 
03B3:  MOVLW  02
03B4:  MOVWF  55
03B5:  MOVLW  FA
03B6:  MOVWF  5D
03B7:  CALL   102
03B8:  DECFSZ 55,F
03B9:  GOTO   3B5
....................     lcd_send_byte(0, 0x08); 
03BA:  CLRF   61
03BB:  MOVLW  08
03BC:  MOVWF  62
03BD:  CALL   173
....................  
....................     output_low(LED_PIN); 
03BE:  BSF    03.5
03BF:  BCF    05.0
03C0:  BCF    03.5
03C1:  BCF    05.0
....................     output_low(BUZZER_PIN); 
03C2:  BSF    03.5
03C3:  BCF    05.1
03C4:  BCF    03.5
03C5:  BCF    05.1
....................  
....................     while (TRUE) 
....................     { 
....................         setup_wdt(WDT_2304MS); 
03C6:  MOVLW  09
03C7:  BSF    03.6
03C8:  MOVWF  05
03C9:  MOVLW  0F
03CA:  MOVWF  77
03CB:  BCF    03.6
03CC:  CLRF   01
03CD:  MOVLW  81
03CE:  MOVWF  04
03CF:  BCF    03.7
03D0:  MOVF   00,W
03D1:  ANDLW  F0
03D2:  IORLW  07
03D3:  MOVWF  00
03D4:  CLRWDT
03D5:  MOVF   00,W
03D6:  ANDLW  F7
03D7:  BTFSC  77.3
03D8:  ANDLW  F0
03D9:  IORWF  77,W
03DA:  MOVWF  00
....................         sleep(); 
03DB:  SLEEP
....................         // B4 de uyandrma tuu olarak eklendi 
....................         if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_HARD_RESET)) 
03DC:  BSF    03.5
03DD:  BSF    06.0
03DE:  BCF    03.5
03DF:  BTFSS  06.0
03E0:  GOTO   3F4
03E1:  BSF    03.5
03E2:  BSF    06.1
03E3:  BCF    03.5
03E4:  BTFSS  06.1
03E5:  GOTO   3F4
03E6:  BSF    03.5
03E7:  BSF    06.2
03E8:  BCF    03.5
03E9:  BTFSS  06.2
03EA:  GOTO   3F4
03EB:  BSF    03.5
03EC:  BSF    06.3
03ED:  BCF    03.5
03EE:  BTFSS  06.3
03EF:  GOTO   3F4
03F0:  BSF    03.5
03F1:  BSF    06.4
03F2:  BCF    03.5
03F3:  BTFSS  06.4
....................         { 
....................             break; 
03F4:  GOTO   3F6
....................         } 
03F5:  GOTO   3C6
....................     } 
....................  
....................     setup_wdt(WDT_18MS); 
03F6:  MOVLW  09
03F7:  BSF    03.6
03F8:  MOVWF  05
03F9:  BSF    03.5
03FA:  BCF    03.6
03FB:  MOVF   01,W
03FC:  ANDLW  F0
03FD:  MOVWF  01
03FE:  CLRWDT
....................     lcd_init(); 
03FF:  BCF    03.5
0400:  CALL   1CF
....................     lcd_locate(1, 1); 
0401:  MOVLW  01
0402:  MOVWF  58
0403:  MOVWF  59
0404:  CALL   237
....................     printf(lcd_putc, "MOD: YAZIM"); 
0405:  MOVLW  86
0406:  BSF    03.6
0407:  MOVWF  0D
0408:  MOVLW  00
0409:  MOVWF  0F
040A:  BCF    03.6
040B:  CALL   29A
....................     update_lcd(); 
040C:  CALL   34F
....................     idle_counter = 0; 
040D:  CLRF   51
040E:  CLRF   50
040F:  BCF    0A.3
0410:  BCF    0A.4
0411:  GOTO   4D5 (RETURN)
.................... } 
....................  
.................... #INT_TIMER1 
.................... void timer1_isr() 
.................... { 
....................     set_timer1(63036); 
*
008C:  CLRF   0E
008D:  MOVLW  F6
008E:  MOVWF  0F
008F:  MOVLW  3C
0090:  MOVWF  0E
....................  
....................     if (idle_counter < 32000) 
0091:  MOVF   51,W
0092:  SUBLW  7C
0093:  BTFSS  03.0
0094:  GOTO   098
....................     { 
....................         idle_counter++; 
0095:  INCF   50,F
0096:  BTFSC  03.2
0097:  INCF   51,F
....................     } 
....................  
....................     int1 btn_current = !input(BTN_SIGNAL); 
0098:  BSF    03.5
0099:  BSF    06.0
009A:  BCF    03.5
009B:  BCF    67.0
009C:  BTFSS  06.0
009D:  BSF    67.0
....................  
....................     if (btn_current) 
009E:  BTFSS  67.0
009F:  GOTO   0AE
....................     { 
....................         idle_counter = 0; 
00A0:  CLRF   51
00A1:  CLRF   50
....................         press_counter++; 
00A2:  INCF   4E,F
00A3:  BTFSC  03.2
00A4:  INCF   4F,F
....................         output_high(LED_PIN); 
00A5:  BSF    03.5
00A6:  BCF    05.0
00A7:  BCF    03.5
00A8:  BSF    05.0
....................         output_high(BUZZER_PIN); 
00A9:  BSF    03.5
00AA:  BCF    05.1
00AB:  BCF    03.5
00AC:  BSF    05.1
....................     } 
00AD:  GOTO   0DF
....................     else 
....................     { 
....................         output_low(LED_PIN); 
00AE:  BSF    03.5
00AF:  BCF    05.0
00B0:  BCF    03.5
00B1:  BCF    05.0
....................         output_low(BUZZER_PIN); 
00B2:  BSF    03.5
00B3:  BCF    05.1
00B4:  BCF    03.5
00B5:  BCF    05.1
....................         if (btn_prev_state == 1) 
00B6:  BTFSS  52.0
00B7:  GOTO   0DF
....................         { 
....................             idle_counter = 0; 
00B8:  CLRF   51
00B9:  CLRF   50
....................             if (press_counter > 2) 
00BA:  MOVF   4F,F
00BB:  BTFSS  03.2
00BC:  GOTO   0C1
00BD:  MOVF   4E,W
00BE:  SUBLW  02
00BF:  BTFSC  03.0
00C0:  GOTO   0DD
....................             { 
....................                 if (press_counter < 30) 
00C1:  MOVF   4F,F
00C2:  BTFSS  03.2
00C3:  GOTO   0D0
00C4:  MOVF   4E,W
00C5:  SUBLW  1D
00C6:  BTFSS  03.0
00C7:  GOTO   0D0
....................                     morse_buffer[morse_index++] = '.'; 
00C8:  MOVF   4C,W
00C9:  INCF   4C,F
00CA:  ADDLW  2D
00CB:  MOVWF  04
00CC:  BCF    03.7
00CD:  MOVLW  2E
00CE:  MOVWF  00
00CF:  GOTO   0D7
....................                 else 
....................                     morse_buffer[morse_index++] = '-'; 
00D0:  MOVF   4C,W
00D1:  INCF   4C,F
00D2:  ADDLW  2D
00D3:  MOVWF  04
00D4:  BCF    03.7
00D5:  MOVLW  2D
00D6:  MOVWF  00
....................  
....................                 morse_buffer[morse_index] = '\0'; 
00D7:  MOVLW  2D
00D8:  ADDWF  4C,W
00D9:  MOVWF  04
00DA:  BCF    03.7
00DB:  CLRF   00
....................                 update_needed = 1; 
00DC:  BSF    52.1
....................             } 
....................             press_counter = 0; 
00DD:  CLRF   4F
00DE:  CLRF   4E
....................         } 
....................     } 
....................     btn_prev_state = btn_current; 
00DF:  BCF    52.0
00E0:  BTFSC  67.0
00E1:  BSF    52.0
00E2:  BCF    0C.0
00E3:  BCF    0A.3
00E4:  BCF    0A.4
00E5:  GOTO   01D
.................... } 
....................  
.................... void main() 
*
0454:  MOVLW  71
0455:  BSF    03.5
0456:  MOVWF  0F
0457:  MOVF   0F,W
0458:  BCF    03.5
0459:  CLRF   4C
045A:  CLRF   4D
045B:  CLRF   4F
045C:  CLRF   4E
045D:  CLRF   51
045E:  CLRF   50
045F:  BCF    52.0
0460:  BCF    52.1
0461:  BSF    03.5
0462:  BSF    03.6
0463:  MOVF   09,W
0464:  ANDLW  C0
0465:  MOVWF  09
0466:  BCF    03.6
0467:  BCF    1F.4
0468:  BCF    1F.5
0469:  MOVLW  00
046A:  BSF    03.6
046B:  MOVWF  08
046C:  BCF    03.5
046D:  CLRF   07
046E:  CLRF   08
046F:  CLRF   09
0470:  BCF    03.7
0471:  MOVLW  1F
0472:  ANDWF  03,F
.................... { 
....................     setup_wdt(WDT_2304MS); 
*
0476:  MOVLW  09
0477:  BSF    03.6
0478:  MOVWF  05
0479:  MOVLW  0F
047A:  MOVWF  77
047B:  BCF    03.6
047C:  CLRF   01
047D:  MOVLW  81
047E:  MOVWF  04
047F:  BCF    03.7
0480:  MOVF   00,W
0481:  ANDLW  F0
0482:  IORLW  07
0483:  MOVWF  00
0484:  CLRWDT
0485:  MOVF   00,W
0486:  ANDLW  F7
0487:  BTFSC  77.3
0488:  ANDLW  F0
0489:  IORWF  77,W
048A:  MOVWF  00
....................  
....................     set_tris_b(0xFF); 
048B:  MOVLW  FF
048C:  BSF    03.5
048D:  MOVWF  06
....................     port_b_pullups(TRUE); 
048E:  MOVLW  01
048F:  MOVWF  15
0490:  BCF    01.7
....................     output_drive(LED_PIN); 
0491:  BCF    05.0
....................     output_drive(BUZZER_PIN); 
0492:  BCF    05.1
....................  
....................     restart_wdt(); 
0493:  CLRWDT
....................     lcd_init(); 
0494:  BCF    03.5
0495:  CALL   1CF
....................     restart_wdt(); 
0496:  CLRWDT
....................     delay_ms(100); 
0497:  MOVLW  64
0498:  MOVWF  5D
0499:  CALL   102
....................  
....................     load_text_from_eeprom(); 
049A:  GOTO   20A
....................  
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
049B:  MOVLW  35
049C:  MOVWF  10
....................     set_timer1(63036); 
049D:  CLRF   0E
049E:  MOVLW  F6
049F:  MOVWF  0F
04A0:  MOVLW  3C
04A1:  MOVWF  0E
....................     enable_interrupts(INT_TIMER1); 
04A2:  BSF    03.5
04A3:  BSF    0C.0
....................     enable_interrupts(GLOBAL); 
04A4:  MOVLW  C0
04A5:  BCF    03.5
04A6:  IORWF  0B,F
....................  
....................     lcd_locate(1, 1); 
04A7:  MOVLW  01
04A8:  MOVWF  58
04A9:  MOVWF  59
04AA:  CALL   237
....................     printf(lcd_putc, "Mors Telgraf"); 
04AB:  MOVLW  E6
04AC:  BSF    03.6
04AD:  MOVWF  0D
04AE:  MOVLW  00
04AF:  MOVWF  0F
04B0:  BCF    03.6
04B1:  CALL   29A
....................     restart_wdt(); 
04B2:  CLRWDT
....................     delay_ms(1000); 
04B3:  MOVLW  04
04B4:  MOVWF  55
04B5:  MOVLW  FA
04B6:  MOVWF  5D
04B7:  CALL   102
04B8:  DECFSZ 55,F
04B9:  GOTO   4B5
....................  
....................     lcd_putc('\f'); 
04BA:  MOVLW  0C
04BB:  MOVWF  5C
04BC:  CALL   26E
....................     lcd_locate(1, 1); 
04BD:  MOVLW  01
04BE:  MOVWF  58
04BF:  MOVWF  59
04C0:  CALL   237
....................     printf(lcd_putc, "MOD: YAZIM"); 
04C1:  MOVLW  ED
04C2:  BSF    03.6
04C3:  MOVWF  0D
04C4:  MOVLW  00
04C5:  MOVWF  0F
04C6:  BCF    03.6
04C7:  CALL   29A
....................     update_lcd(); 
04C8:  CALL   34F
....................  
....................     while (TRUE) 
....................     { 
....................         restart_wdt(); 
04C9:  CLRWDT
....................  
....................         if (idle_counter > SLEEP_TIMEOUT) 
04CA:  MOVF   51,W
04CB:  SUBLW  0A
04CC:  BTFSC  03.0
04CD:  GOTO   4D5
04CE:  XORLW  FF
04CF:  BTFSS  03.2
04D0:  GOTO   4D4
04D1:  MOVF   50,W
04D2:  SUBLW  B8
04D3:  BTFSS  03.0
....................         { 
....................             enter_sleep_mode(); 
04D4:  GOTO   3A5
....................         } 
....................  
....................         if (update_needed) 
04D5:  BTFSS  52.1
04D6:  GOTO   4D9
....................         { 
....................             update_lcd(); 
04D7:  CALL   34F
....................             update_needed = 0; 
04D8:  BCF    52.1
....................         } 
....................  
....................         if (!input(BTN_UPLOAD)) 
04D9:  BSF    03.5
04DA:  BSF    06.1
04DB:  BCF    03.5
04DC:  BTFSC  06.1
04DD:  GOTO   508
....................         { 
....................             idle_counter = 0; 
04DE:  CLRF   51
04DF:  CLRF   50
....................             while (!input(BTN_UPLOAD)) 
04E0:  BSF    03.5
04E1:  BSF    06.1
04E2:  BCF    03.5
04E3:  BTFSC  06.1
04E4:  GOTO   4E7
....................             { 
....................                 restart_wdt(); 
04E5:  CLRWDT
04E6:  GOTO   4E0
....................             } 
....................  
....................             if (morse_index > 0) 
04E7:  MOVF   4C,F
04E8:  BTFSC  03.2
04E9:  GOTO   508
....................             { 
....................                 char final_char = decode_morse(morse_buffer); 
04EA:  CLRF   59
04EB:  MOVLW  2D
04EC:  MOVWF  58
04ED:  CALL   319
04EE:  MOVF   78,W
04EF:  MOVWF  53
....................                 if (text_index < 20 && final_char != '?') 
04F0:  MOVF   4D,W
04F1:  SUBLW  13
04F2:  BTFSS  03.0
04F3:  GOTO   505
04F4:  MOVF   53,W
04F5:  SUBLW  3F
04F6:  BTFSC  03.2
04F7:  GOTO   505
....................                 { 
....................                     text_buffer[text_index++] = final_char; 
04F8:  MOVF   4D,W
04F9:  INCF   4D,F
04FA:  ADDLW  37
04FB:  MOVWF  04
04FC:  BCF    03.7
04FD:  MOVF   53,W
04FE:  MOVWF  00
....................                     text_buffer[text_index] = '\0'; 
04FF:  MOVLW  37
0500:  ADDWF  4D,W
0501:  MOVWF  04
0502:  BCF    03.7
0503:  CLRF   00
....................                     save_text_to_eeprom(); 
0504:  CALL   412
....................                 } 
....................                 morse_index = 0; 
0505:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0506:  CLRF   2D
....................                 update_lcd(); 
0507:  CALL   34F
....................             } 
....................         } 
....................  
....................         if (!input(BTN_DELETE)) 
0508:  BSF    03.5
0509:  BSF    06.2
050A:  BCF    03.5
050B:  BTFSC  06.2
050C:  GOTO   52B
....................         { 
....................             idle_counter = 0; 
050D:  CLRF   51
050E:  CLRF   50
....................             while (!input(BTN_DELETE)) 
050F:  BSF    03.5
0510:  BSF    06.2
0511:  BCF    03.5
0512:  BTFSC  06.2
0513:  GOTO   516
....................             { 
....................                 restart_wdt(); 
0514:  CLRWDT
0515:  GOTO   50F
....................             } 
....................  
....................             if (morse_index > 0) 
0516:  MOVF   4C,F
0517:  BTFSC  03.2
0518:  GOTO   520
....................                 morse_buffer[--morse_index] = '\0'; 
0519:  DECF   4C,F
051A:  MOVLW  2D
051B:  ADDWF  4C,W
051C:  MOVWF  04
051D:  BCF    03.7
051E:  CLRF   00
051F:  GOTO   52A
....................             else if (text_index > 0) 
0520:  MOVF   4D,F
0521:  BTFSC  03.2
0522:  GOTO   52A
....................             { 
....................                 text_buffer[--text_index] = '\0'; 
0523:  DECF   4D,F
0524:  MOVLW  37
0525:  ADDWF  4D,W
0526:  MOVWF  04
0527:  BCF    03.7
0528:  CLRF   00
....................                 save_text_to_eeprom(); 
0529:  CALL   412
....................             } 
....................             update_lcd(); 
052A:  CALL   34F
....................         } 
....................  
....................         // --- NORMAL RESET (Sadece ekran temizler) --- 
....................         if (!input(BTN_RESET)) 
052B:  BSF    03.5
052C:  BSF    06.3
052D:  BCF    03.5
052E:  BTFSC  06.3
052F:  GOTO   53E
....................         { 
....................             idle_counter = 0; 
0530:  CLRF   51
0531:  CLRF   50
....................             while (!input(BTN_RESET)) 
0532:  BSF    03.5
0533:  BSF    06.3
0534:  BCF    03.5
0535:  BTFSC  06.3
0536:  GOTO   539
....................             { 
....................                 restart_wdt(); 
0537:  CLRWDT
0538:  GOTO   532
....................             } 
....................  
....................             text_index = 0; 
0539:  CLRF   4D
....................             text_buffer[0] = '\0'; 
053A:  CLRF   37
....................             morse_index = 0; 
053B:  CLRF   4C
....................             morse_buffer[0] = '\0'; 
053C:  CLRF   2D
....................             // Not: Normal reset sadece RAM'i siler, EEPROM'u ellemiyor (eski kodun gibi) 
....................             // Eer normal resette de eeprom silinsin istiyorsan buraya save_text_to_eeprom(); ekle 
....................             update_lcd(); 
053D:  CALL   34F
....................         } 
....................  
....................         // --- HARD RESET (B4 - EEPROM TEMZLEME) --- 
....................         if (!input(BTN_HARD_RESET)) 
053E:  BSF    03.5
053F:  BSF    06.4
0540:  BCF    03.5
0541:  BTFSC  06.4
0542:  GOTO   5AF
....................         { 
....................             idle_counter = 0; 
0543:  CLRF   51
0544:  CLRF   50
....................  
....................             // Kullancya bilgi ver 
....................             lcd_putc('\f'); 
0545:  MOVLW  0C
0546:  MOVWF  5C
0547:  CALL   26E
....................             lcd_locate(1, 1); 
0548:  MOVLW  01
0549:  MOVWF  58
054A:  MOVWF  59
054B:  CALL   237
....................             printf(lcd_putc, "FORMAT ATILIYOR!"); 
054C:  MOVLW  F3
054D:  BSF    03.6
054E:  MOVWF  0D
054F:  MOVLW  00
0550:  MOVWF  0F
0551:  BCF    03.6
0552:  CALL   29A
....................             output_high(BUZZER_PIN); // Sesli uyar 
0553:  BSF    03.5
0554:  BCF    05.1
0555:  BCF    03.5
0556:  BSF    05.1
....................             delay_ms(200); 
0557:  MOVLW  C8
0558:  MOVWF  5D
0559:  CALL   102
....................             output_low(BUZZER_PIN); 
055A:  BSF    03.5
055B:  BCF    05.1
055C:  BCF    03.5
055D:  BCF    05.1
....................  
....................             // Tu braklana kadar bekle 
....................             while (!input(BTN_HARD_RESET)) 
055E:  BSF    03.5
055F:  BSF    06.4
0560:  BCF    03.5
0561:  BTFSC  06.4
0562:  GOTO   565
....................             { 
....................                 restart_wdt(); 
0563:  CLRWDT
0564:  GOTO   55E
....................             } 
....................  
....................             // EEPROM TEMZL 
....................             int8 i; 
....................             // lk 30 adresi 0 yapyoruz (text uzunluu ve karakterler) 
....................             for (i = 0; i < 30; i++) 
0565:  CLRF   54
0566:  MOVF   54,W
0567:  SUBLW  1D
0568:  BTFSS  03.0
0569:  GOTO   583
....................             { 
....................                 write_eeprom(i, 0); 
056A:  MOVF   0B,W
056B:  MOVWF  77
056C:  BCF    0B.7
056D:  MOVF   54,W
056E:  BSF    03.6
056F:  MOVWF  0D
0570:  CLRF   0C
0571:  BSF    03.5
0572:  BCF    0C.7
0573:  BSF    0C.2
0574:  MOVLW  55
0575:  MOVWF  0D
0576:  MOVLW  AA
0577:  MOVWF  0D
0578:  BSF    0C.1
0579:  BTFSC  0C.1
057A:  GOTO   579
057B:  BCF    0C.2
057C:  MOVF   77,W
057D:  BCF    03.5
057E:  BCF    03.6
057F:  IORWF  0B,F
....................                 restart_wdt(); // Yazma ilemi srasnda WDT resetle 
0580:  CLRWDT
0581:  INCF   54,F
0582:  GOTO   566
....................             } 
....................  
....................             // Deikenleri sfrla 
....................             text_index = 0; 
0583:  CLRF   4D
....................             text_buffer[0] = '\0'; 
0584:  CLRF   37
....................             morse_index = 0; 
0585:  CLRF   4C
....................             morse_buffer[0] = '\0'; 
0586:  CLRF   2D
....................  
....................             // Ekran gncelle 
....................             lcd_putc('\f'); 
0587:  MOVLW  0C
0588:  MOVWF  5C
0589:  CALL   26E
....................             lcd_locate(1, 1); 
058A:  MOVLW  01
058B:  MOVWF  58
058C:  MOVWF  59
058D:  CALL   237
....................             printf(lcd_putc, "MOD: YAZIM"); 
058E:  MOVLW  FC
058F:  BSF    03.6
0590:  MOVWF  0D
0591:  MOVLW  00
0592:  MOVWF  0F
0593:  BCF    03.6
0594:  CALL   29A
....................             update_lcd(); 
0595:  CALL   34F
....................  
....................             // lem bitti sesi 
....................             output_high(BUZZER_PIN); 
0596:  BSF    03.5
0597:  BCF    05.1
0598:  BCF    03.5
0599:  BSF    05.1
....................             delay_ms(50); 
059A:  MOVLW  32
059B:  MOVWF  5D
059C:  CALL   102
....................             output_low(BUZZER_PIN); 
059D:  BSF    03.5
059E:  BCF    05.1
059F:  BCF    03.5
05A0:  BCF    05.1
....................             delay_ms(50); 
05A1:  MOVLW  32
05A2:  MOVWF  5D
05A3:  CALL   102
....................             output_high(BUZZER_PIN); 
05A4:  BSF    03.5
05A5:  BCF    05.1
05A6:  BCF    03.5
05A7:  BSF    05.1
....................             delay_ms(50); 
05A8:  MOVLW  32
05A9:  MOVWF  5D
05AA:  CALL   102
....................             output_low(BUZZER_PIN); 
05AB:  BSF    03.5
05AC:  BCF    05.1
05AD:  BCF    03.5
05AE:  BCF    05.1
....................         } 
05AF:  GOTO   4C9
....................     } 
.................... } 
05B0:  SLEEP

Configuration Fuses:
   Word  1: 2CDC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
