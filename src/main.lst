CCS PCM C Compiler, Version 5.007, 61971               20-Ara-25 10:42

               Filename:   C:\Users\Alihan\Desktop\DERS\Pic_Telegraph\src\main.lst

               ROM used:   2549 words (31%)
                           Largest free fragment is 2048
               RAM used:   111 (30%) at main() level
                           139 (38%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   038
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.0
0020:  GOTO   023
0021:  BTFSC  0C.0
0022:  GOTO   03B
0023:  BTFSS  0B.5
0024:  GOTO   027
0025:  BTFSC  0B.2
0026:  GOTO   03E
0027:  MOVF   22,W
0028:  MOVWF  04
0029:  MOVF   23,W
002A:  MOVWF  77
002B:  MOVF   24,W
002C:  MOVWF  78
002D:  MOVF   25,W
002E:  MOVWF  79
002F:  MOVF   26,W
0030:  MOVWF  7A
0031:  MOVF   20,W
0032:  MOVWF  0A
0033:  SWAPF  21,W
0034:  MOVWF  03
0035:  SWAPF  7F,F
0036:  SWAPF  7F,W
0037:  RETFIE
0038:  BCF    0A.3
0039:  BCF    0A.4
003A:  GOTO   0CA
003B:  BCF    0A.3
003C:  BCF    0A.4
003D:  GOTO   119
003E:  BCF    0A.3
003F:  BCF    0A.4
0040:  GOTO   183
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
0041:  BCF    0A.0
0042:  BCF    0A.1
0043:  BCF    0A.2
0044:  ADDWF  02,F
0045:  RETLW  28
0046:  RETLW  0C
0047:  RETLW  01
0048:  RETLW  06
0049:  BCF    0A.0
004A:  BCF    0A.1
004B:  BCF    0A.2
004C:  ADDWF  02,F
004D:  RETLW  00
004E:  RETLW  00
004F:  RETLW  45
0050:  RETLW  54
0051:  RETLW  49
0052:  RETLW  41
0053:  RETLW  4E
0054:  RETLW  4D
0055:  RETLW  53
0056:  RETLW  55
0057:  RETLW  52
0058:  RETLW  57
0059:  RETLW  44
005A:  RETLW  4B
005B:  RETLW  47
005C:  RETLW  4F
005D:  RETLW  48
005E:  RETLW  56
005F:  RETLW  46
0060:  RETLW  00
0061:  RETLW  4C
0062:  RETLW  00
0063:  RETLW  50
0064:  RETLW  4A
0065:  RETLW  42
0066:  RETLW  58
0067:  RETLW  43
0068:  RETLW  59
0069:  RETLW  5A
006A:  RETLW  51
006B:  RETLW  00
006C:  RETLW  00
006D:  RETLW  35
006E:  RETLW  34
006F:  RETLW  00
0070:  RETLW  33
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  00
0074:  RETLW  32
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  00
007B:  RETLW  00
007C:  RETLW  31
007D:  RETLW  36
007E:  RETLW  00
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  00
0082:  RETLW  00
0083:  RETLW  00
0084:  RETLW  00
0085:  RETLW  37
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  00
0089:  RETLW  38
008A:  RETLW  00
008B:  RETLW  39
008C:  RETLW  30
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 20,10
0091:  DATA 20,10
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA 00,00
0098:  DATA CD,27
0099:  DATA 44,1D
009A:  DATA A0,26
009B:  DATA C5,29
009C:  DATA 41,25
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 00,01
00A3:  DATA CD,27
00A4:  DATA 44,1D
00A5:  DATA A0,25
00A6:  DATA CF,26
00A7:  DATA 55,2A
00A8:  DATA 20,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 00,01
00AE:  DATA 20,10
00AF:  DATA 00,01
00B0:  DATA 20,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,10
00BA:  DATA 00,00
00BB:  DATA D5,2C
00BC:  DATA CB,2A
00BD:  DATA A0,26
00BE:  DATA 4F,22
00BF:  DATA 55,17
00C0:  DATA 2E,17
00C1:  DATA 00,00
00C2:  DATA C8,22
00C3:  DATA D0,29
00C4:  DATA 49,10
00C5:  DATA D3,24
00C6:  DATA CC,24
00C7:  DATA CE,24
00C8:  DATA D9,27
00C9:  DATA 52,00
*
018E:  DATA CD,37
018F:  DATA F2,39
0190:  DATA 20,2A
0191:  DATA 65,36
0192:  DATA 67,39
0193:  DATA 61,33
0194:  DATA 00,01
0195:  DATA D6,22
0196:  DATA D2,24
0197:  DATA A0,23
0198:  DATA 4F,27
0199:  DATA C4,22
019A:  DATA D2,24
019B:  DATA 4C,22
019C:  DATA 49,00
*
03A8:  MOVF   0B,W
03A9:  BSF    03.5
03AA:  MOVWF  42
03AB:  BCF    03.5
03AC:  BCF    0B.7
03AD:  BSF    03.5
03AE:  BSF    03.6
03AF:  BSF    0C.7
03B0:  BSF    0C.0
03B1:  NOP
03B2:  NOP
03B3:  BCF    03.5
03B4:  MOVF   0C,W
03B5:  ANDLW  7F
03B6:  BTFSC  03.2
03B7:  GOTO   405
03B8:  BSF    03.5
03B9:  BCF    03.6
03BA:  MOVWF  43
03BB:  BCF    03.5
03BC:  BSF    03.6
03BD:  MOVF   0D,W
03BE:  BSF    03.5
03BF:  BCF    03.6
03C0:  MOVWF  44
03C1:  BCF    03.5
03C2:  BSF    03.6
03C3:  MOVF   0F,W
03C4:  BSF    03.5
03C5:  BCF    03.6
03C6:  MOVWF  45
03C7:  MOVF   43,W
03C8:  MOVWF  46
03C9:  BCF    03.5
03CA:  CALL   36E
03CB:  BSF    03.5
03CC:  MOVF   44,W
03CD:  BCF    03.5
03CE:  BSF    03.6
03CF:  MOVWF  0D
03D0:  BSF    03.5
03D1:  BCF    03.6
03D2:  MOVF   45,W
03D3:  BCF    03.5
03D4:  BSF    03.6
03D5:  MOVWF  0F
03D6:  BSF    03.5
03D7:  BSF    0C.7
03D8:  BSF    0C.0
03D9:  NOP
03DA:  NOP
03DB:  BCF    03.5
03DC:  RLF    0C,W
03DD:  RLF    0E,W
03DE:  ANDLW  7F
03DF:  BTFSC  03.2
03E0:  GOTO   405
03E1:  BSF    03.5
03E2:  BCF    03.6
03E3:  MOVWF  43
03E4:  BCF    03.5
03E5:  BSF    03.6
03E6:  MOVF   0D,W
03E7:  BSF    03.5
03E8:  BCF    03.6
03E9:  MOVWF  44
03EA:  BCF    03.5
03EB:  BSF    03.6
03EC:  MOVF   0F,W
03ED:  BSF    03.5
03EE:  BCF    03.6
03EF:  MOVWF  45
03F0:  MOVF   43,W
03F1:  MOVWF  46
03F2:  BCF    03.5
03F3:  CALL   36E
03F4:  BSF    03.5
03F5:  MOVF   44,W
03F6:  BCF    03.5
03F7:  BSF    03.6
03F8:  MOVWF  0D
03F9:  BSF    03.5
03FA:  BCF    03.6
03FB:  MOVF   45,W
03FC:  BCF    03.5
03FD:  BSF    03.6
03FE:  MOVWF  0F
03FF:  INCF   0D,F
0400:  BTFSC  03.2
0401:  INCF   0F,F
0402:  BCF    03.6
0403:  GOTO   3AD
0404:  BSF    03.6
0405:  BSF    03.5
0406:  BCF    03.6
0407:  BTFSS  42.7
0408:  GOTO   40C
0409:  BCF    03.5
040A:  BSF    0B.7
040B:  BSF    03.5
040C:  BCF    03.5
040D:  RETURN
040E:  MOVF   00,F
040F:  BTFSC  03.2
0410:  GOTO   42A
0411:  BSF    03.5
0412:  CLRF   42
0413:  MOVF   04,W
0414:  MOVWF  41
0415:  BCF    42.0
0416:  BTFSC  03.7
0417:  BSF    42.0
0418:  MOVF   00,W
0419:  MOVWF  46
041A:  BCF    03.5
041B:  CALL   36E
041C:  BSF    03.5
041D:  MOVF   41,W
041E:  MOVWF  04
041F:  BCF    03.7
0420:  BTFSC  42.0
0421:  BSF    03.7
0422:  INCF   04,F
0423:  BTFSS  03.2
0424:  GOTO   428
0425:  BCF    03.5
0426:  INCF   05,F
0427:  BSF    03.5
0428:  BCF    03.5
0429:  GOTO   40E
042A:  RETURN
*
0554:  MOVF   45,W
0555:  CLRF   78
0556:  SUBWF  44,W
0557:  BTFSC  03.0
0558:  GOTO   55C
0559:  MOVF   44,W
055A:  MOVWF  77
055B:  GOTO   568
055C:  CLRF   77
055D:  MOVLW  08
055E:  MOVWF  46
055F:  RLF    44,F
0560:  RLF    77,F
0561:  MOVF   45,W
0562:  SUBWF  77,W
0563:  BTFSC  03.0
0564:  MOVWF  77
0565:  RLF    78,F
0566:  DECFSZ 46,F
0567:  GOTO   55F
*
06B2:  BTFSC  44.7
06B3:  GOTO   6C7
06B4:  MOVLW  0F
06B5:  MOVWF  77
06B6:  SWAPF  43,W
06B7:  ANDWF  77,F
06B8:  MOVLW  0A
06B9:  SUBWF  77,W
06BA:  BTFSC  03.0
06BB:  GOTO   6BF
06BC:  MOVLW  30
06BD:  ADDWF  77,F
06BE:  GOTO   6C1
06BF:  MOVF   44,W
06C0:  ADDWF  77,F
06C1:  MOVF   77,W
06C2:  BCF    03.5
06C3:  BTFSS  0C.4
06C4:  GOTO   6C3
06C5:  MOVWF  19
06C6:  BSF    03.5
06C7:  MOVLW  0F
06C8:  ANDWF  43,F
06C9:  MOVLW  0A
06CA:  SUBWF  43,W
06CB:  BTFSC  03.0
06CC:  GOTO   6CF
06CD:  MOVLW  30
06CE:  GOTO   6D1
06CF:  BCF    44.7
06D0:  MOVF   44,W
06D1:  ADDWF  43,F
06D2:  MOVF   43,W
06D3:  BCF    03.5
06D4:  BTFSS  0C.4
06D5:  GOTO   6D4
06D6:  MOVWF  19
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOWDT, NOPROTECT, NOLVP, NOBROWNOUT, PUT, NOMCLR 
.................... #use delay(clock = 8000000) 
*
019D:  MOVLW  C7
019E:  MOVWF  04
019F:  BCF    03.7
01A0:  MOVF   00,W
01A1:  BTFSC  03.2
01A2:  GOTO   1B0
01A3:  MOVLW  02
01A4:  MOVWF  78
01A5:  CLRF   77
01A6:  DECFSZ 77,F
01A7:  GOTO   1A6
01A8:  DECFSZ 78,F
01A9:  GOTO   1A5
01AA:  MOVLW  97
01AB:  MOVWF  77
01AC:  DECFSZ 77,F
01AD:  GOTO   1AC
01AE:  DECFSZ 00,F
01AF:  GOTO   1A3
01B0:  RETURN
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = BT_MODUL) 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
082E:  BCF    03.6
082F:  CLRF   27
0830:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
042B:  BSF    03.5
042C:  MOVF   47,W
042D:  MOVWF  49
042E:  MOVF   46,W
042F:  MOVWF  48
0430:  MOVF   49,W
0431:  MOVWF  7A
0432:  MOVF   48,W
0433:  MOVWF  04
0434:  BCF    03.7
0435:  BTFSC  7A.0
0436:  BSF    03.7
0437:  MOVF   00,F
0438:  BTFSC  03.2
0439:  GOTO   43E
043A:  INCF   48,F
043B:  BTFSC  03.2
043C:  INCF   49,F
043D:  GOTO   430
....................    return(sc - s); 
043E:  MOVF   46,W
043F:  SUBWF  48,W
0440:  MOVWF  77
0441:  MOVF   49,W
0442:  MOVWF  7A
0443:  MOVF   47,W
0444:  BTFSS  03.0
0445:  INCFSZ 47,W
0446:  SUBWF  7A,F
0447:  MOVF   77,W
0448:  MOVWF  78
0449:  BCF    03.5
044A:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LCD_RS_PIN PIN_D1 
.................... #define LCD_RW_PIN PIN_D2 
.................... #define LCD_ENABLE_PIN PIN_D3 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... #include <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0222:  BSF    08.4
....................    output_float(LCD_DATA5); 
0223:  BSF    08.5
....................    output_float(LCD_DATA6); 
0224:  BSF    08.6
....................    output_float(LCD_DATA7); 
0225:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0226:  BCF    03.5
0227:  BSF    08.2
0228:  BSF    03.5
0229:  BCF    08.2
....................    delay_cycles(1); 
022A:  NOP
....................    lcd_output_enable(1); 
022B:  BCF    03.5
022C:  BSF    08.3
022D:  BSF    03.5
022E:  BCF    08.3
....................    delay_cycles(1); 
022F:  NOP
....................    high = lcd_read_nibble(); 
0230:  BCF    03.5
0231:  CALL   1E7
0232:  MOVF   78,W
0233:  BSF    03.5
0234:  MOVWF  4E
....................        
....................    lcd_output_enable(0); 
0235:  BCF    03.5
0236:  BCF    08.3
0237:  BSF    03.5
0238:  BCF    08.3
....................    delay_cycles(1); 
0239:  NOP
....................    lcd_output_enable(1); 
023A:  BCF    03.5
023B:  BSF    08.3
023C:  BSF    03.5
023D:  BCF    08.3
....................    delay_us(1); 
023E:  GOTO   23F
....................    low = lcd_read_nibble(); 
023F:  BCF    03.5
0240:  CALL   1E7
0241:  MOVF   78,W
0242:  BSF    03.5
0243:  MOVWF  4D
....................        
....................    lcd_output_enable(0); 
0244:  BCF    03.5
0245:  BCF    08.3
0246:  BSF    03.5
0247:  BCF    08.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0248:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0249:  BCF    08.5
....................    output_drive(LCD_DATA6); 
024A:  BCF    08.6
....................    output_drive(LCD_DATA7); 
024B:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
024C:  SWAPF  4E,W
024D:  MOVWF  77
024E:  MOVLW  F0
024F:  ANDWF  77,F
0250:  MOVF   77,W
0251:  IORWF  4D,W
0252:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01E7:  BSF    03.5
01E8:  CLRF   4F
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01E9:  BSF    08.4
01EA:  MOVLW  00
01EB:  BCF    03.5
01EC:  BTFSC  08.4
01ED:  MOVLW  01
01EE:  BSF    03.5
01EF:  IORWF  4F,F
....................    n |= input(LCD_DATA5) << 1; 
01F0:  BSF    08.5
01F1:  MOVLW  00
01F2:  BCF    03.5
01F3:  BTFSC  08.5
01F4:  MOVLW  01
01F5:  MOVWF  77
01F6:  BCF    03.0
01F7:  RLF    77,F
01F8:  MOVF   77,W
01F9:  BSF    03.5
01FA:  IORWF  4F,F
....................    n |= input(LCD_DATA6) << 2; 
01FB:  BSF    08.6
01FC:  MOVLW  00
01FD:  BCF    03.5
01FE:  BTFSC  08.6
01FF:  MOVLW  01
0200:  MOVWF  77
0201:  RLF    77,F
0202:  RLF    77,F
0203:  MOVLW  FC
0204:  ANDWF  77,F
0205:  MOVF   77,W
0206:  BSF    03.5
0207:  IORWF  4F,F
....................    n |= input(LCD_DATA7) << 3; 
0208:  BSF    08.7
0209:  MOVLW  00
020A:  BCF    03.5
020B:  BTFSC  08.7
020C:  MOVLW  01
020D:  MOVWF  77
020E:  RLF    77,F
020F:  RLF    77,F
0210:  RLF    77,F
0211:  MOVLW  F8
0212:  ANDWF  77,F
0213:  MOVF   77,W
0214:  BSF    03.5
0215:  IORWF  4F,F
....................     
....................    return(n); 
0216:  MOVF   4F,W
0217:  MOVWF  78
....................   #else 
0218:  BCF    03.5
0219:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
01B1:  BSF    03.5
01B2:  BTFSC  4E.0
01B3:  GOTO   1B8
01B4:  BCF    03.5
01B5:  BCF    08.4
01B6:  GOTO   1BA
01B7:  BSF    03.5
01B8:  BCF    03.5
01B9:  BSF    08.4
01BA:  BSF    03.5
01BB:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
01BC:  BTFSC  4E.1
01BD:  GOTO   1C2
01BE:  BCF    03.5
01BF:  BCF    08.5
01C0:  GOTO   1C4
01C1:  BSF    03.5
01C2:  BCF    03.5
01C3:  BSF    08.5
01C4:  BSF    03.5
01C5:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
01C6:  BTFSC  4E.2
01C7:  GOTO   1CC
01C8:  BCF    03.5
01C9:  BCF    08.6
01CA:  GOTO   1CE
01CB:  BSF    03.5
01CC:  BCF    03.5
01CD:  BSF    08.6
01CE:  BSF    03.5
01CF:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01D0:  BTFSC  4E.3
01D1:  GOTO   1D6
01D2:  BCF    03.5
01D3:  BCF    08.7
01D4:  GOTO   1D8
01D5:  BSF    03.5
01D6:  BCF    03.5
01D7:  BSF    08.7
01D8:  BSF    03.5
01D9:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01DA:  NOP
....................    lcd_output_enable(1); 
01DB:  BCF    03.5
01DC:  BSF    08.3
01DD:  BSF    03.5
01DE:  BCF    08.3
....................    delay_us(2); 
01DF:  GOTO   1E0
01E0:  GOTO   1E1
....................    lcd_output_enable(0); 
01E1:  BCF    03.5
01E2:  BCF    08.3
01E3:  BSF    03.5
01E4:  BCF    08.3
01E5:  BCF    03.5
01E6:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
021A:  BSF    03.5
021B:  BCF    08.3
....................    lcd_rs_tris(); 
021C:  BCF    08.1
....................    lcd_rw_tris(); 
021D:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
021E:  BCF    03.5
021F:  BCF    08.1
0220:  BSF    03.5
0221:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0253:  MOVF   78,W
0254:  MOVWF  4D
0255:  BTFSC  4D.7
0256:  GOTO   222
....................    lcd_output_rs(address); 
0257:  MOVF   4B,F
0258:  BTFSS  03.2
0259:  GOTO   25E
025A:  BCF    03.5
025B:  BCF    08.1
025C:  GOTO   260
025D:  BSF    03.5
025E:  BCF    03.5
025F:  BSF    08.1
0260:  BSF    03.5
0261:  BCF    08.1
....................    delay_cycles(1); 
0262:  NOP
....................    lcd_output_rw(0); 
0263:  BCF    03.5
0264:  BCF    08.2
0265:  BSF    03.5
0266:  BCF    08.2
....................    delay_cycles(1); 
0267:  NOP
....................    lcd_output_enable(0); 
0268:  BCF    03.5
0269:  BCF    08.3
026A:  BSF    03.5
026B:  BCF    08.3
....................    lcd_send_nibble(n >> 4); 
026C:  SWAPF  4C,W
026D:  MOVWF  4D
026E:  MOVLW  0F
026F:  ANDWF  4D,F
0270:  MOVF   4D,W
0271:  MOVWF  4E
0272:  BCF    03.5
0273:  CALL   1B1
....................    lcd_send_nibble(n & 0xf); 
0274:  BSF    03.5
0275:  MOVF   4C,W
0276:  ANDLW  0F
0277:  MOVWF  4D
0278:  MOVWF  4E
0279:  BCF    03.5
027A:  CALL   1B1
027B:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
027C:  BSF    03.5
027D:  BCF    08.4
....................    output_drive(LCD_DATA5); 
027E:  BCF    08.5
....................    output_drive(LCD_DATA6); 
027F:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0280:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0281:  BCF    08.3
....................    lcd_rs_tris(); 
0282:  BCF    08.1
....................    lcd_rw_tris(); 
0283:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0284:  BCF    03.5
0285:  BCF    08.1
0286:  BSF    03.5
0287:  BCF    08.1
....................    lcd_output_rw(0); 
0288:  BCF    03.5
0289:  BCF    08.2
028A:  BSF    03.5
028B:  BCF    08.2
....................    lcd_output_enable(0); 
028C:  BCF    03.5
028D:  BCF    08.3
028E:  BSF    03.5
028F:  BCF    08.3
....................      
....................    delay_ms(15); 
0290:  MOVLW  0F
0291:  MOVWF  47
0292:  BCF    03.5
0293:  CALL   19D
....................    for(i=1;i<=3;++i) 
0294:  MOVLW  01
0295:  BSF    03.5
0296:  MOVWF  3E
0297:  MOVF   3E,W
0298:  SUBLW  03
0299:  BTFSS  03.0
029A:  GOTO   2A7
....................    { 
....................        lcd_send_nibble(3); 
029B:  MOVLW  03
029C:  MOVWF  4E
029D:  BCF    03.5
029E:  CALL   1B1
....................        delay_ms(5); 
029F:  MOVLW  05
02A0:  BSF    03.5
02A1:  MOVWF  47
02A2:  BCF    03.5
02A3:  CALL   19D
02A4:  BSF    03.5
02A5:  INCF   3E,F
02A6:  GOTO   297
....................    } 
....................     
....................    lcd_send_nibble(2); 
02A7:  MOVLW  02
02A8:  MOVWF  4E
02A9:  BCF    03.5
02AA:  CALL   1B1
....................    delay_ms(5); 
02AB:  MOVLW  05
02AC:  BSF    03.5
02AD:  MOVWF  47
02AE:  BCF    03.5
02AF:  CALL   19D
....................    for(i=0;i<=3;++i) 
02B0:  BSF    03.5
02B1:  CLRF   3E
02B2:  MOVF   3E,W
02B3:  SUBLW  03
02B4:  BTFSS  03.0
02B5:  GOTO   2C3
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02B6:  MOVF   3E,W
02B7:  BCF    03.5
02B8:  CALL   041
02B9:  BSF    03.5
02BA:  MOVWF  3F
02BB:  CLRF   4B
02BC:  MOVF   3F,W
02BD:  MOVWF  4C
02BE:  BCF    03.5
02BF:  CALL   21A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02C0:  BSF    03.5
02C1:  INCF   3E,F
02C2:  GOTO   2B2
02C3:  BCF    03.5
02C4:  RETURN
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
035A:  BSF    03.5
035B:  DECFSZ 48,W
035C:  GOTO   35E
035D:  GOTO   361
....................       address=LCD_LINE_TWO; 
035E:  MOVLW  40
035F:  MOVWF  49
0360:  GOTO   362
....................    else 
....................       address=0; 
0361:  CLRF   49
....................       
....................    address+=x-1; 
0362:  MOVLW  01
0363:  SUBWF  47,W
0364:  ADDWF  49,F
....................    lcd_send_byte(0,0x80|address); 
0365:  MOVF   49,W
0366:  IORLW  80
0367:  MOVWF  4A
0368:  CLRF   4B
0369:  MOVF   4A,W
036A:  MOVWF  4C
036B:  BCF    03.5
036C:  CALL   21A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
036D:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
036E:  BSF    03.5
036F:  MOVF   46,W
0370:  XORLW  07
0371:  BCF    03.5
0372:  BTFSC  03.2
0373:  GOTO   37E
0374:  XORLW  0B
0375:  BTFSC  03.2
0376:  GOTO   385
0377:  XORLW  06
0378:  BTFSC  03.2
0379:  GOTO   391
037A:  XORLW  02
037B:  BTFSC  03.2
037C:  GOTO   399
037D:  GOTO   3A0
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
037E:  MOVLW  01
037F:  BSF    03.5
0380:  MOVWF  47
0381:  MOVWF  48
0382:  BCF    03.5
0383:  CALL   35A
0384:  GOTO   3A7
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0385:  BSF    03.5
0386:  CLRF   4B
0387:  MOVLW  01
0388:  MOVWF  4C
0389:  BCF    03.5
038A:  CALL   21A
....................                      delay_ms(2); 
038B:  MOVLW  02
038C:  BSF    03.5
038D:  MOVWF  47
038E:  BCF    03.5
038F:  CALL   19D
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0390:  GOTO   3A7
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0391:  MOVLW  01
0392:  BSF    03.5
0393:  MOVWF  47
0394:  MOVLW  02
0395:  MOVWF  48
0396:  BCF    03.5
0397:  CALL   35A
0398:  GOTO   3A7
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0399:  BSF    03.5
039A:  CLRF   4B
039B:  MOVLW  10
039C:  MOVWF  4C
039D:  BCF    03.5
039E:  CALL   21A
039F:  GOTO   3A7
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03A0:  MOVLW  01
03A1:  BSF    03.5
03A2:  MOVWF  4B
03A3:  MOVF   46,W
03A4:  MOVWF  4C
03A5:  BCF    03.5
03A6:  CALL   21A
....................      #endif 
....................    } 
03A7:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define LED_PIN PIN_A0 
.................... #define BUZZER_PIN PIN_A1 
....................  
.................... #define BTN_SIGNAL PIN_B0 
.................... #define BTN_UPLOAD PIN_B1 
.................... #define BTN_DELETE PIN_B2 
.................... #define BTN_RESET PIN_B3 
.................... #define BTN_MODE PIN_B4 
....................  
.................... char morse_buffer[10]; 
.................... char text_buffer[21]; 
.................... int8 morse_index = 0; 
.................... int8 text_index = 0; 
....................  
.................... char rx_temp_buffer[25]; 
.................... char rx_display_buffer[25]; 
.................... int8 rx_temp_index = 0; 
.................... int1 rx_data_ready = 0; 
....................  
.................... volatile int16 press_counter = 0; 
.................... volatile int16 idle_counter = 0; 
.................... #define SLEEP_TIMEOUT 3000 
....................  
.................... int1 btn_prev_state = 0; 
.................... int1 update_needed = 0; 
....................  
.................... volatile int8 scroll_tick = 0; 
.................... int1 scroll_now = 0; 
.................... int8 scroll_pos = 0; 
....................  
.................... int1 app_mode = 0; 
....................  
.................... const char morse_tree[64] = { 
....................     0, 0, 'E', 'T', 'I', 'A', 'N', 'M', 'S', 'U', 'R', 'W', 'D', 'K', 'G', 'O', 
....................     'H', 'V', 'F', 0, 'L', 0, 'P', 'J', 'B', 'X', 'C', 'Y', 'Z', 'Q', 0, 0, 
....................     '5', '4', 0, '3', 0, 0, 0, '2', 0, 0, 0, 0, 0, 0, 0, '1', 
....................     '6', 0, 0, 0, 0, 0, 0, 0, '7', 0, 0, 0, '8', 0, '9', '0'}; 
....................  
.................... void wdt_delay_ms(int16 time) 
.................... { 
....................     int16 i; 
....................     for (i = 0; i < time; i++) 
*
05DE:  BSF    03.5
05DF:  CLRF   41
05E0:  CLRF   40
05E1:  MOVF   41,W
05E2:  SUBWF  3F,W
05E3:  BTFSS  03.0
05E4:  GOTO   5F5
05E5:  BTFSS  03.2
05E6:  GOTO   5EB
05E7:  MOVF   3E,W
05E8:  SUBWF  40,W
05E9:  BTFSC  03.0
05EA:  GOTO   5F5
....................     { 
....................         delay_ms(1); 
05EB:  MOVLW  01
05EC:  MOVWF  47
05ED:  BCF    03.5
05EE:  CALL   19D
....................         restart_wdt(); 
05EF:  CLRWDT
05F0:  BSF    03.5
05F1:  INCF   40,F
05F2:  BTFSC  03.2
05F3:  INCF   41,F
05F4:  GOTO   5E1
....................     } 
05F5:  BCF    03.5
05F6:  RETURN
.................... } 
....................  
.................... void save_text_to_eeprom() 
.................... { 
....................     int8 i; 
....................     write_eeprom(0, text_index); 
*
06E2:  MOVF   0B,W
06E3:  MOVWF  77
06E4:  BCF    0B.7
06E5:  BSF    03.6
06E6:  CLRF   0D
06E7:  BCF    03.6
06E8:  MOVF   4D,W
06E9:  BSF    03.6
06EA:  MOVWF  0C
06EB:  BSF    03.5
06EC:  BCF    0C.7
06ED:  BSF    0C.2
06EE:  MOVLW  55
06EF:  MOVWF  0D
06F0:  MOVLW  AA
06F1:  MOVWF  0D
06F2:  BSF    0C.1
06F3:  BTFSC  0C.1
06F4:  GOTO   6F3
06F5:  BCF    0C.2
06F6:  MOVF   77,W
06F7:  BCF    03.5
06F8:  BCF    03.6
06F9:  IORWF  0B,F
....................     for (i = 0; i < text_index; i++) 
06FA:  BSF    03.5
06FB:  CLRF   3E
06FC:  BCF    03.5
06FD:  MOVF   4D,W
06FE:  BSF    03.5
06FF:  SUBWF  3E,W
0700:  BTFSC  03.0
0701:  GOTO   72D
....................     { 
....................         write_eeprom(i + 1, text_buffer[i]); 
0702:  MOVLW  01
0703:  ADDWF  3E,W
0704:  MOVWF  3F
0705:  MOVLW  37
0706:  ADDWF  3E,W
0707:  MOVWF  04
0708:  BCF    03.7
0709:  MOVF   00,W
070A:  MOVWF  40
070B:  BCF    03.5
070C:  MOVF   0B,W
070D:  MOVWF  77
070E:  BCF    0B.7
070F:  BSF    03.5
0710:  MOVF   3F,W
0711:  BCF    03.5
0712:  BSF    03.6
0713:  MOVWF  0D
0714:  BSF    03.5
0715:  BCF    03.6
0716:  MOVF   40,W
0717:  BCF    03.5
0718:  BSF    03.6
0719:  MOVWF  0C
071A:  BSF    03.5
071B:  BCF    0C.7
071C:  BSF    0C.2
071D:  MOVLW  55
071E:  MOVWF  0D
071F:  MOVLW  AA
0720:  MOVWF  0D
0721:  BSF    0C.1
0722:  BTFSC  0C.1
0723:  GOTO   722
0724:  BCF    0C.2
0725:  MOVF   77,W
0726:  BCF    03.5
0727:  BCF    03.6
0728:  IORWF  0B,F
....................         restart_wdt(); 
0729:  CLRWDT
072A:  BSF    03.5
072B:  INCF   3E,F
072C:  GOTO   6FC
....................     } 
072D:  BCF    03.5
072E:  RETURN
.................... } 
....................  
.................... void load_text_from_eeprom() 
.................... { 
....................     int8 i; 
....................     text_index = read_eeprom(0); 
*
02C5:  BSF    03.6
02C6:  CLRF   0D
02C7:  BSF    03.5
02C8:  BCF    0C.7
02C9:  BSF    0C.0
02CA:  BCF    03.5
02CB:  MOVF   0C,W
02CC:  BCF    03.6
02CD:  MOVWF  4D
....................     if (text_index > 20) 
02CE:  MOVF   4D,W
02CF:  SUBLW  14
02D0:  BTFSS  03.0
....................         text_index = 0; 
02D1:  CLRF   4D
....................     for (i = 0; i < text_index; i++) 
02D2:  BSF    03.5
02D3:  CLRF   3E
02D4:  BCF    03.5
02D5:  MOVF   4D,W
02D6:  BSF    03.5
02D7:  SUBWF  3E,W
02D8:  BTFSC  03.0
02D9:  GOTO   2F0
....................     { 
....................         text_buffer[i] = read_eeprom(i + 1); 
02DA:  MOVLW  37
02DB:  ADDWF  3E,W
02DC:  MOVWF  04
02DD:  BCF    03.7
02DE:  MOVLW  01
02DF:  ADDWF  3E,W
02E0:  MOVWF  41
02E1:  MOVF   41,W
02E2:  BCF    03.5
02E3:  BSF    03.6
02E4:  MOVWF  0D
02E5:  BSF    03.5
02E6:  BCF    0C.7
02E7:  BSF    0C.0
02E8:  BCF    03.5
02E9:  MOVF   0C,W
02EA:  MOVWF  00
....................         restart_wdt(); 
02EB:  CLRWDT
02EC:  BSF    03.5
02ED:  BCF    03.6
02EE:  INCF   3E,F
02EF:  GOTO   2D4
....................     } 
....................     text_buffer[text_index] = '\0'; 
02F0:  MOVLW  37
02F1:  BCF    03.5
02F2:  ADDWF  4D,W
02F3:  MOVWF  04
02F4:  BCF    03.7
02F5:  CLRF   00
02F6:  BSF    0A.3
02F7:  BCF    0A.4
02F8:  GOTO   056 (RETURN)
.................... } 
....................  
.................... void save_bt_to_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = strlen(rx_display_buffer); 
*
0584:  BSF    03.5
0585:  CLRF   47
0586:  MOVLW  A0
0587:  MOVWF  46
0588:  BCF    03.5
0589:  CALL   42B
058A:  MOVF   78,W
058B:  BSF    03.5
058C:  MOVWF  3F
....................     write_eeprom(50, len); 
058D:  BCF    03.5
058E:  MOVF   0B,W
058F:  MOVWF  77
0590:  BCF    0B.7
0591:  MOVLW  32
0592:  BSF    03.6
0593:  MOVWF  0D
0594:  BSF    03.5
0595:  BCF    03.6
0596:  MOVF   3F,W
0597:  BCF    03.5
0598:  BSF    03.6
0599:  MOVWF  0C
059A:  BSF    03.5
059B:  BCF    0C.7
059C:  BSF    0C.2
059D:  MOVLW  55
059E:  MOVWF  0D
059F:  MOVLW  AA
05A0:  MOVWF  0D
05A1:  BSF    0C.1
05A2:  BTFSC  0C.1
05A3:  GOTO   5A2
05A4:  BCF    0C.2
05A5:  MOVF   77,W
05A6:  BCF    03.5
05A7:  BCF    03.6
05A8:  IORWF  0B,F
....................     for (i = 0; i < len; i++) 
05A9:  BSF    03.5
05AA:  CLRF   3E
05AB:  MOVF   3F,W
05AC:  SUBWF  3E,W
05AD:  BTFSC  03.0
05AE:  GOTO   5DA
....................     { 
....................         write_eeprom(51 + i, rx_display_buffer[i]); 
05AF:  MOVLW  33
05B0:  ADDWF  3E,W
05B1:  MOVWF  40
05B2:  MOVLW  A0
05B3:  ADDWF  3E,W
05B4:  MOVWF  04
05B5:  BCF    03.7
05B6:  MOVF   00,W
05B7:  MOVWF  41
05B8:  BCF    03.5
05B9:  MOVF   0B,W
05BA:  MOVWF  77
05BB:  BCF    0B.7
05BC:  BSF    03.5
05BD:  MOVF   40,W
05BE:  BCF    03.5
05BF:  BSF    03.6
05C0:  MOVWF  0D
05C1:  BSF    03.5
05C2:  BCF    03.6
05C3:  MOVF   41,W
05C4:  BCF    03.5
05C5:  BSF    03.6
05C6:  MOVWF  0C
05C7:  BSF    03.5
05C8:  BCF    0C.7
05C9:  BSF    0C.2
05CA:  MOVLW  55
05CB:  MOVWF  0D
05CC:  MOVLW  AA
05CD:  MOVWF  0D
05CE:  BSF    0C.1
05CF:  BTFSC  0C.1
05D0:  GOTO   5CF
05D1:  BCF    0C.2
05D2:  MOVF   77,W
05D3:  BCF    03.5
05D4:  BCF    03.6
05D5:  IORWF  0B,F
....................         restart_wdt(); 
05D6:  CLRWDT
05D7:  BSF    03.5
05D8:  INCF   3E,F
05D9:  GOTO   5AB
....................     } 
05DA:  BCF    03.5
05DB:  BSF    0A.3
05DC:  BCF    0A.4
05DD:  GOTO   0BC (RETURN)
.................... } 
....................  
.................... void load_bt_from_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = read_eeprom(50); 
*
02F9:  MOVLW  32
02FA:  BSF    03.6
02FB:  MOVWF  0D
02FC:  BSF    03.5
02FD:  BCF    0C.7
02FE:  BSF    0C.0
02FF:  BCF    03.5
0300:  MOVF   0C,W
0301:  BSF    03.5
0302:  BCF    03.6
0303:  MOVWF  3F
....................     if (len > 20) 
0304:  MOVF   3F,W
0305:  SUBLW  14
0306:  BTFSS  03.0
....................         len = 0; 
0307:  CLRF   3F
....................  
....................     for (i = 0; i < len; i++) 
0308:  CLRF   3E
0309:  MOVF   3F,W
030A:  SUBWF  3E,W
030B:  BTFSC  03.0
030C:  GOTO   323
....................     { 
....................         rx_display_buffer[i] = read_eeprom(51 + i); 
030D:  MOVLW  A0
030E:  ADDWF  3E,W
030F:  MOVWF  04
0310:  BCF    03.7
0311:  MOVLW  33
0312:  ADDWF  3E,W
0313:  MOVWF  42
0314:  MOVF   42,W
0315:  BCF    03.5
0316:  BSF    03.6
0317:  MOVWF  0D
0318:  BSF    03.5
0319:  BCF    0C.7
031A:  BSF    0C.0
031B:  BCF    03.5
031C:  MOVF   0C,W
031D:  MOVWF  00
....................         restart_wdt(); 
031E:  CLRWDT
031F:  BSF    03.5
0320:  BCF    03.6
0321:  INCF   3E,F
0322:  GOTO   309
....................     } 
....................     rx_display_buffer[len] = '\0'; 
0323:  MOVLW  A0
0324:  ADDWF  3F,W
0325:  MOVWF  04
0326:  BCF    03.7
0327:  CLRF   00
0328:  BCF    03.5
0329:  BSF    0A.3
032A:  BCF    0A.4
032B:  GOTO   059 (RETURN)
.................... } 
....................  
.................... char decode_morse(char *code) 
*
044B:  MOVLW  01
044C:  BSF    03.5
044D:  MOVWF  45
.................... { 
....................     int8 i, len; 
....................     int8 index = 1; 
....................     len = strlen(code); 
044E:  MOVF   42,W
044F:  MOVWF  47
0450:  MOVF   41,W
0451:  MOVWF  46
0452:  BCF    03.5
0453:  CALL   42B
0454:  MOVF   78,W
0455:  BSF    03.5
0456:  MOVWF  44
....................     if (len == 0) 
0457:  MOVF   44,F
0458:  BTFSS  03.2
0459:  GOTO   45D
....................         return ' '; 
045A:  MOVLW  20
045B:  MOVWF  78
045C:  GOTO   489
....................  
....................     for (i = 0; i < len; i++) 
045D:  CLRF   43
045E:  MOVF   44,W
045F:  SUBWF  43,W
0460:  BTFSC  03.0
0461:  GOTO   477
....................     { 
....................         index = index << 1; 
0462:  BCF    03.0
0463:  RLF    45,F
....................         if (code[i] == '-') 
0464:  MOVF   43,W
0465:  ADDWF  41,W
0466:  MOVWF  04
0467:  BCF    03.7
0468:  BTFSC  42.0
0469:  BSF    03.7
046A:  MOVF   00,W
046B:  SUBLW  2D
046C:  BTFSC  03.2
....................             index |= 1; 
046D:  BSF    45.0
....................         if (index >= 64) 
046E:  MOVF   45,W
046F:  SUBLW  3F
0470:  BTFSC  03.0
0471:  GOTO   475
....................             return '?'; 
0472:  MOVLW  3F
0473:  MOVWF  78
0474:  GOTO   489
0475:  INCF   43,F
0476:  GOTO   45E
....................     } 
....................     if (morse_tree[index] == 0) 
0477:  MOVF   45,W
0478:  BCF    03.5
0479:  CALL   049
047A:  XORLW  00
047B:  BTFSS  03.2
047C:  GOTO   482
....................         return '?'; 
047D:  MOVLW  3F
047E:  MOVWF  78
047F:  BSF    03.5
0480:  GOTO   489
0481:  BCF    03.5
....................     return morse_tree[index]; 
0482:  BSF    03.5
0483:  MOVF   45,W
0484:  BCF    03.5
0485:  CALL   049
0486:  MOVWF  78
0487:  MOVWF  78
0488:  BSF    03.5
0489:  BCF    03.5
048A:  RETURN
.................... } 
....................  
.................... void lcd_locate(int8 x, int8 y) 
.................... { 
....................     int8 address; 
....................     switch (y) 
*
032C:  BSF    03.5
032D:  MOVF   43,W
032E:  XORLW  01
032F:  BCF    03.5
0330:  BTFSC  03.2
0331:  GOTO   33C
0332:  XORLW  03
0333:  BTFSC  03.2
0334:  GOTO   33F
0335:  XORLW  01
0336:  BTFSC  03.2
0337:  GOTO   343
0338:  XORLW  07
0339:  BTFSC  03.2
033A:  GOTO   347
033B:  GOTO   34C
....................     { 
....................     case 1: 
....................         address = 0x00; 
033C:  BSF    03.5
033D:  CLRF   44
....................         break; 
033E:  GOTO   34E
....................     case 2: 
....................         address = 0x40; 
033F:  MOVLW  40
0340:  BSF    03.5
0341:  MOVWF  44
....................         break; 
0342:  GOTO   34E
....................     case 3: 
....................         address = 0x14; 
0343:  MOVLW  14
0344:  BSF    03.5
0345:  MOVWF  44
....................         break; 
0346:  GOTO   34E
....................     case 4: 
....................         address = 0x54; 
0347:  MOVLW  54
0348:  BSF    03.5
0349:  MOVWF  44
....................         break; 
034A:  GOTO   34E
034B:  BCF    03.5
....................     default: 
....................         address = 0x00; 
034C:  BSF    03.5
034D:  CLRF   44
....................         break; 
....................     } 
....................     address += x - 1; 
034E:  MOVLW  01
034F:  SUBWF  42,W
0350:  ADDWF  44,F
....................     lcd_send_byte(0, 0x80 | address); 
0351:  MOVF   44,W
0352:  IORLW  80
0353:  MOVWF  45
0354:  CLRF   4B
0355:  MOVF   45,W
0356:  MOVWF  4C
0357:  BCF    03.5
0358:  CALL   21A
0359:  RETURN
.................... } 
....................  
.................... void update_scroll_line() 
*
051F:  MOVLW  04
0520:  BSF    03.5
0521:  MOVWF  41
.................... { 
....................     int8 len, i, current_char_idx; 
....................     int8 gap_size = 4; 
....................  
....................     if (rx_display_buffer[0] == '\0') 
0522:  MOVF   20,F
0523:  BTFSS  03.2
0524:  GOTO   534
....................     { 
....................         lcd_locate(1, 4); 
0525:  MOVLW  01
0526:  MOVWF  42
0527:  MOVLW  04
0528:  MOVWF  43
0529:  BCF    03.5
052A:  CALL   32C
....................         printf(lcd_putc, "                    "); 
052B:  MOVLW  8D
052C:  BSF    03.6
052D:  MOVWF  0D
052E:  MOVLW  00
052F:  MOVWF  0F
0530:  BCF    03.6
0531:  CALL   3A8
....................         return; 
0532:  GOTO   581
0533:  BSF    03.5
....................     } 
....................  
....................     len = strlen(rx_display_buffer); 
0534:  CLRF   47
0535:  MOVLW  A0
0536:  MOVWF  46
0537:  BCF    03.5
0538:  CALL   42B
0539:  MOVF   78,W
053A:  BSF    03.5
053B:  MOVWF  3E
....................     lcd_locate(1, 4); 
053C:  MOVLW  01
053D:  MOVWF  42
053E:  MOVLW  04
053F:  MOVWF  43
0540:  BCF    03.5
0541:  CALL   32C
....................  
....................     for (i = 0; i < 20; i++) 
0542:  BSF    03.5
0543:  CLRF   3F
0544:  MOVF   3F,W
0545:  SUBLW  13
0546:  BTFSS  03.0
0547:  GOTO   580
....................     { 
....................         current_char_idx = (scroll_pos + i) % (len + gap_size); 
0548:  MOVF   3F,W
0549:  BCF    03.5
054A:  ADDWF  6E,W
054B:  BSF    03.5
054C:  MOVWF  42
054D:  MOVF   41,W
054E:  ADDWF  3E,W
054F:  MOVWF  43
0550:  MOVF   42,W
0551:  MOVWF  44
0552:  MOVF   43,W
0553:  MOVWF  45
*
0568:  MOVF   77,W
0569:  MOVWF  40
....................         if (current_char_idx < len) 
056A:  MOVF   3E,W
056B:  SUBWF  40,W
056C:  BTFSC  03.0
056D:  GOTO   579
....................             lcd_putc(rx_display_buffer[current_char_idx]); 
056E:  MOVLW  A0
056F:  ADDWF  40,W
0570:  MOVWF  04
0571:  BCF    03.7
0572:  MOVF   00,W
0573:  MOVWF  42
0574:  MOVWF  46
0575:  BCF    03.5
0576:  CALL   36E
0577:  GOTO   57D
0578:  BSF    03.5
....................         else 
....................             lcd_putc(' '); 
0579:  MOVLW  20
057A:  MOVWF  46
057B:  BCF    03.5
057C:  CALL   36E
057D:  BSF    03.5
057E:  INCF   3F,F
057F:  GOTO   544
0580:  BCF    03.5
....................     } 
0581:  BSF    0A.3
0582:  BCF    0A.4
0583:  GOTO   0B5 (RETURN)
.................... } 
....................  
.................... void update_lcd() 
.................... { 
....................     int8 i, len; 
....................     char preview_char; 
....................  
....................     lcd_locate(1, 1); 
*
048B:  MOVLW  01
048C:  BSF    03.5
048D:  MOVWF  42
048E:  MOVWF  43
048F:  BCF    03.5
0490:  CALL   32C
....................     if (app_mode == 0) 
0491:  BTFSC  68.4
0492:  GOTO   49B
....................         printf(lcd_putc, "MOD: MESAJ          "); 
0493:  MOVLW  98
0494:  BSF    03.6
0495:  MOVWF  0D
0496:  MOVLW  00
0497:  MOVWF  0F
0498:  BCF    03.6
0499:  CALL   3A8
049A:  GOTO   4A2
....................     else 
....................         printf(lcd_putc, "MOD: KOMUT          "); 
049B:  MOVLW  A3
049C:  BSF    03.6
049D:  MOVWF  0D
049E:  MOVLW  00
049F:  MOVWF  0F
04A0:  BCF    03.6
04A1:  CALL   3A8
....................  
....................     lcd_locate(1, 2); 
04A2:  MOVLW  01
04A3:  BSF    03.5
04A4:  MOVWF  42
04A5:  MOVLW  02
04A6:  MOVWF  43
04A7:  BCF    03.5
04A8:  CALL   32C
....................     printf(lcd_putc, "%s", text_buffer); 
04A9:  MOVLW  37
04AA:  MOVWF  04
04AB:  BCF    03.7
04AC:  CALL   40E
....................  
....................     if (morse_index > 0) 
04AD:  MOVF   4C,F
04AE:  BTFSC  03.2
04AF:  GOTO   4C3
....................     { 
....................         preview_char = decode_morse(morse_buffer); 
04B0:  BSF    03.5
04B1:  CLRF   42
04B2:  MOVLW  2D
04B3:  MOVWF  41
04B4:  BCF    03.5
04B5:  CALL   44B
04B6:  MOVF   78,W
04B7:  BSF    03.5
04B8:  MOVWF  40
....................         lcd_putc(preview_char); 
04B9:  MOVF   40,W
04BA:  MOVWF  46
04BB:  BCF    03.5
04BC:  CALL   36E
....................         lcd_putc('<'); 
04BD:  MOVLW  3C
04BE:  BSF    03.5
04BF:  MOVWF  46
04C0:  BCF    03.5
04C1:  CALL   36E
....................     } 
04C2:  GOTO   4CA
....................     else 
....................     { 
....................         lcd_putc("  "); 
04C3:  MOVLW  AE
04C4:  BSF    03.6
04C5:  MOVWF  0D
04C6:  MOVLW  00
04C7:  MOVWF  0F
04C8:  BCF    03.6
04C9:  CALL   3A8
....................     } 
....................  
....................     len = strlen(text_buffer) + (morse_index > 0 ? 2 : 0); 
04CA:  BSF    03.5
04CB:  CLRF   47
04CC:  MOVLW  37
04CD:  MOVWF  46
04CE:  BCF    03.5
04CF:  CALL   42B
04D0:  MOVF   78,W
04D1:  BSF    03.5
04D2:  MOVWF  41
04D3:  BCF    03.5
04D4:  MOVF   4C,F
04D5:  BTFSC  03.2
04D6:  GOTO   4DA
04D7:  CLRF   7A
04D8:  MOVLW  02
04D9:  GOTO   4DC
04DA:  CLRF   7A
04DB:  MOVLW  00
04DC:  BSF    03.5
04DD:  ADDWF  41,W
04DE:  MOVWF  3F
....................     for (i = len; i < 20; i++) 
04DF:  MOVF   3F,W
04E0:  MOVWF  3E
04E1:  MOVF   3E,W
04E2:  SUBLW  13
04E3:  BTFSS  03.0
04E4:  GOTO   4EC
....................         lcd_putc(' '); 
04E5:  MOVLW  20
04E6:  MOVWF  46
04E7:  BCF    03.5
04E8:  CALL   36E
04E9:  BSF    03.5
04EA:  INCF   3E,F
04EB:  GOTO   4E1
....................  
....................     lcd_locate(1, 3); 
04EC:  MOVLW  01
04ED:  MOVWF  42
04EE:  MOVLW  03
04EF:  MOVWF  43
04F0:  BCF    03.5
04F1:  CALL   32C
....................     printf(lcd_putc, "%s", morse_buffer); 
04F2:  MOVLW  2D
04F3:  MOVWF  04
04F4:  BCF    03.7
04F5:  CALL   40E
....................     len = strlen(morse_buffer); 
04F6:  BSF    03.5
04F7:  CLRF   47
04F8:  MOVLW  2D
04F9:  MOVWF  46
04FA:  BCF    03.5
04FB:  CALL   42B
04FC:  MOVF   78,W
04FD:  BSF    03.5
04FE:  MOVWF  3F
....................     for (i = len; i < 20; i++) 
04FF:  MOVF   3F,W
0500:  MOVWF  3E
0501:  MOVF   3E,W
0502:  SUBLW  13
0503:  BTFSS  03.0
0504:  GOTO   50C
....................         lcd_putc(' '); 
0505:  MOVLW  20
0506:  MOVWF  46
0507:  BCF    03.5
0508:  CALL   36E
0509:  BSF    03.5
050A:  INCF   3E,F
050B:  GOTO   501
....................  
....................     if (rx_display_buffer[0] == '\0') 
050C:  MOVF   20,F
050D:  BTFSS  03.2
050E:  GOTO   51D
....................     { 
....................         lcd_locate(1, 4); 
050F:  MOVLW  01
0510:  MOVWF  42
0511:  MOVLW  04
0512:  MOVWF  43
0513:  BCF    03.5
0514:  CALL   32C
....................         printf(lcd_putc, "                    "); 
0515:  MOVLW  B0
0516:  BSF    03.6
0517:  MOVWF  0D
0518:  MOVLW  00
0519:  MOVWF  0F
051A:  BCF    03.6
051B:  CALL   3A8
051C:  BSF    03.5
....................     } 
051D:  BCF    03.5
051E:  RETURN
.................... } 
....................  
.................... void send_nmea_packet() 
*
065D:  BSF    03.5
065E:  CLRF   3F
.................... { 
....................     char type_char; 
....................     int8 checksum = 0; 
....................     int8 i, len; 
....................     char char_to_send; 
....................  
....................     if (app_mode == 0) 
065F:  BCF    03.5
0660:  BTFSC  68.4
0661:  GOTO   667
....................         type_char = 'M'; 
0662:  MOVLW  4D
0663:  BSF    03.5
0664:  MOVWF  3E
0665:  GOTO   66A
0666:  BCF    03.5
....................     else 
....................         type_char = 'K'; 
0667:  MOVLW  4B
0668:  BSF    03.5
0669:  MOVWF  3E
....................  
....................     fprintf(BT_MODUL, "$%c,", type_char); 
066A:  MOVLW  24
066B:  BCF    03.5
066C:  BTFSS  0C.4
066D:  GOTO   66C
066E:  MOVWF  19
066F:  BSF    03.5
0670:  MOVF   3E,W
0671:  BCF    03.5
0672:  BTFSS  0C.4
0673:  GOTO   672
0674:  MOVWF  19
0675:  MOVLW  2C
0676:  BTFSS  0C.4
0677:  GOTO   676
0678:  MOVWF  19
....................     checksum = type_char ^ ','; 
0679:  BSF    03.5
067A:  MOVF   3E,W
067B:  XORLW  2C
067C:  MOVWF  3F
....................  
....................     len = strlen(text_buffer); 
067D:  CLRF   47
067E:  MOVLW  37
067F:  MOVWF  46
0680:  BCF    03.5
0681:  CALL   42B
0682:  MOVF   78,W
0683:  BSF    03.5
0684:  MOVWF  41
....................     for (i = 0; i < len; i++) 
0685:  CLRF   40
0686:  MOVF   41,W
0687:  SUBWF  40,W
0688:  BTFSC  03.0
0689:  GOTO   6A8
....................     { 
....................         char_to_send = text_buffer[i]; 
068A:  MOVLW  37
068B:  ADDWF  40,W
068C:  MOVWF  04
068D:  BCF    03.7
068E:  MOVF   00,W
068F:  MOVWF  42
....................         if (app_mode == 1 && char_to_send == ' ') 
0690:  BCF    03.5
0691:  BTFSS  68.4
0692:  GOTO   69D
0693:  BSF    03.5
0694:  MOVF   42,W
0695:  SUBLW  20
0696:  BTFSC  03.2
0697:  GOTO   69A
0698:  BCF    03.5
0699:  GOTO   69D
....................             char_to_send = ','; 
069A:  MOVLW  2C
069B:  MOVWF  42
069C:  BCF    03.5
....................         fputc(char_to_send, BT_MODUL); 
069D:  BSF    03.5
069E:  MOVF   42,W
069F:  BCF    03.5
06A0:  BTFSS  0C.4
06A1:  GOTO   6A0
06A2:  MOVWF  19
....................         checksum ^= char_to_send; 
06A3:  BSF    03.5
06A4:  MOVF   42,W
06A5:  XORWF  3F,F
06A6:  INCF   40,F
06A7:  GOTO   686
....................     } 
....................     fprintf(BT_MODUL, ",%X\r\n", checksum); 
06A8:  MOVLW  2C
06A9:  BCF    03.5
06AA:  BTFSS  0C.4
06AB:  GOTO   6AA
06AC:  MOVWF  19
06AD:  BSF    03.5
06AE:  MOVF   3F,W
06AF:  MOVWF  43
06B0:  MOVLW  37
06B1:  MOVWF  44
*
06D7:  MOVLW  0D
06D8:  BTFSS  0C.4
06D9:  GOTO   6D8
06DA:  MOVWF  19
06DB:  MOVLW  0A
06DC:  BTFSS  0C.4
06DD:  GOTO   6DC
06DE:  MOVWF  19
06DF:  BSF    0A.3
06E0:  BCF    0A.4
06E1:  GOTO   15A (RETURN)
.................... } 
....................  
.................... void enter_sleep_mode() 
.................... { 
....................     lcd_putc('\f'); 
*
05F7:  MOVLW  0C
05F8:  BSF    03.5
05F9:  MOVWF  46
05FA:  BCF    03.5
05FB:  CALL   36E
....................     lcd_locate(1, 1); 
05FC:  MOVLW  01
05FD:  BSF    03.5
05FE:  MOVWF  42
05FF:  MOVWF  43
0600:  BCF    03.5
0601:  CALL   32C
....................     printf(lcd_putc, "UYKU MODU..."); 
0602:  MOVLW  BB
0603:  BSF    03.6
0604:  MOVWF  0D
0605:  MOVLW  00
0606:  MOVWF  0F
0607:  BCF    03.6
0608:  CALL   3A8
....................     wdt_delay_ms(500); 
0609:  MOVLW  01
060A:  BSF    03.5
060B:  MOVWF  3F
060C:  MOVLW  F4
060D:  MOVWF  3E
060E:  BCF    03.5
060F:  CALL   5DE
....................     lcd_send_byte(0, 0x08); 
0610:  BSF    03.5
0611:  CLRF   4B
0612:  MOVLW  08
0613:  MOVWF  4C
0614:  BCF    03.5
0615:  CALL   21A
....................  
....................     output_low(LED_PIN); 
0616:  BSF    03.5
0617:  BCF    05.0
0618:  BCF    03.5
0619:  BCF    05.0
....................     output_low(BUZZER_PIN); 
061A:  BSF    03.5
061B:  BCF    05.1
061C:  BCF    03.5
061D:  BCF    05.1
....................  
....................     while (TRUE) 
....................     { 
....................         restart_wdt(); 
061E:  CLRWDT
....................         sleep(); 
061F:  SLEEP
....................  
....................         if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_MODE)) 
0620:  BSF    03.5
0621:  BSF    06.0
0622:  BCF    03.5
0623:  BTFSS  06.0
0624:  GOTO   639
0625:  BSF    03.5
0626:  BSF    06.1
0627:  BCF    03.5
0628:  BTFSS  06.1
0629:  GOTO   639
062A:  BSF    03.5
062B:  BSF    06.2
062C:  BCF    03.5
062D:  BTFSS  06.2
062E:  GOTO   639
062F:  BSF    03.5
0630:  BSF    06.3
0631:  BCF    03.5
0632:  BTFSS  06.3
0633:  GOTO   639
0634:  BSF    03.5
0635:  BSF    06.4
0636:  BCF    03.5
0637:  BTFSC  06.4
0638:  GOTO   657
....................         { 
....................             delay_ms(20); 
0639:  MOVLW  14
063A:  BSF    03.5
063B:  MOVWF  47
063C:  BCF    03.5
063D:  CALL   19D
....................             if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_MODE)) 
063E:  BSF    03.5
063F:  BSF    06.0
0640:  BCF    03.5
0641:  BTFSS  06.0
0642:  GOTO   656
0643:  BSF    03.5
0644:  BSF    06.1
0645:  BCF    03.5
0646:  BTFSS  06.1
0647:  GOTO   656
0648:  BSF    03.5
0649:  BSF    06.2
064A:  BCF    03.5
064B:  BTFSS  06.2
064C:  GOTO   656
064D:  BSF    03.5
064E:  BSF    06.3
064F:  BCF    03.5
0650:  BTFSS  06.3
0651:  GOTO   656
0652:  BSF    03.5
0653:  BSF    06.4
0654:  BCF    03.5
0655:  BTFSS  06.4
....................             { 
....................                 break; 
0656:  GOTO   658
....................             } 
....................         } 
0657:  GOTO   61E
....................     } 
....................  
....................     lcd_init(); 
0658:  CALL   27C
....................     update_lcd(); 
0659:  CALL   48B
....................     idle_counter = 0; 
065A:  CLRF   6C
065B:  CLRF   6B
065C:  RETURN
.................... } 
....................  
.................... void full_wipe_reset() 
.................... { 
....................     lcd_putc('\f'); 
*
072F:  MOVLW  0C
0730:  BSF    03.5
0731:  MOVWF  46
0732:  BCF    03.5
0733:  CALL   36E
....................     lcd_locate(1, 1); 
0734:  MOVLW  01
0735:  BSF    03.5
0736:  MOVWF  42
0737:  MOVWF  43
0738:  BCF    03.5
0739:  CALL   32C
....................     printf(lcd_putc, "HEPSI SILINIYOR"); 
073A:  MOVLW  C2
073B:  BSF    03.6
073C:  MOVWF  0D
073D:  MOVLW  00
073E:  MOVWF  0F
073F:  BCF    03.6
0740:  CALL   3A8
....................     output_high(BUZZER_PIN); 
0741:  BSF    03.5
0742:  BCF    05.1
0743:  BCF    03.5
0744:  BSF    05.1
....................     wdt_delay_ms(500); 
0745:  MOVLW  01
0746:  BSF    03.5
0747:  MOVWF  3F
0748:  MOVLW  F4
0749:  MOVWF  3E
074A:  BCF    03.5
074B:  CALL   5DE
....................     output_low(BUZZER_PIN); 
074C:  BSF    03.5
074D:  BCF    05.1
074E:  BCF    03.5
074F:  BCF    05.1
....................  
....................     write_eeprom(0, 0); 
0750:  MOVF   0B,W
0751:  MOVWF  77
0752:  BCF    0B.7
0753:  BSF    03.6
0754:  CLRF   0D
0755:  CLRF   0C
0756:  BSF    03.5
0757:  BCF    0C.7
0758:  BSF    0C.2
0759:  MOVLW  55
075A:  MOVWF  0D
075B:  MOVLW  AA
075C:  MOVWF  0D
075D:  BSF    0C.1
075E:  BTFSC  0C.1
075F:  GOTO   75E
0760:  BCF    0C.2
0761:  MOVF   77,W
0762:  BCF    03.5
0763:  BCF    03.6
0764:  IORWF  0B,F
....................     write_eeprom(50, 0); 
0765:  MOVF   0B,W
0766:  MOVWF  77
0767:  BCF    0B.7
0768:  MOVLW  32
0769:  BSF    03.6
076A:  MOVWF  0D
076B:  CLRF   0C
076C:  BSF    03.5
076D:  BCF    0C.7
076E:  BSF    0C.2
076F:  MOVLW  55
0770:  MOVWF  0D
0771:  MOVLW  AA
0772:  MOVWF  0D
0773:  BSF    0C.1
0774:  BTFSC  0C.1
0775:  GOTO   774
0776:  BCF    0C.2
0777:  MOVF   77,W
0778:  BCF    03.5
0779:  BCF    03.6
077A:  IORWF  0B,F
....................  
....................     text_index = 0; 
077B:  CLRF   4D
....................     text_buffer[0] = '\0'; 
077C:  CLRF   37
....................  
....................     morse_index = 0; 
077D:  CLRF   4C
....................     morse_buffer[0] = '\0'; 
077E:  CLRF   2D
....................  
....................     rx_display_buffer[0] = '\0'; 
077F:  BSF    03.5
0780:  CLRF   20
....................     scroll_pos = 0; 
0781:  BCF    03.5
0782:  CLRF   6E
....................  
....................     lcd_putc('\f'); 
0783:  MOVLW  0C
0784:  BSF    03.5
0785:  MOVWF  46
0786:  BCF    03.5
0787:  CALL   36E
....................     update_lcd(); 
0788:  CALL   48B
0789:  BSF    0A.3
078A:  BCF    0A.4
078B:  GOTO   23B (RETURN)
.................... } 
....................  
.................... #INT_RDA 
.................... void serial_isr() 
.................... { 
....................     char incoming; 
....................     if (kbhit(BT_MODUL)) 
*
00CA:  BTFSS  0C.5
00CB:  GOTO   115
....................     { 
....................         incoming = fgetc(BT_MODUL); 
00CC:  BTFSS  0C.5
00CD:  GOTO   0CC
00CE:  MOVF   1A,W
00CF:  BSF    03.5
00D0:  MOVWF  51
....................         if (incoming == '\\' || incoming == '\n' || incoming == '\r') 
00D1:  MOVF   51,W
00D2:  SUBLW  5C
00D3:  BTFSC  03.2
00D4:  GOTO   0DD
00D5:  MOVF   51,W
00D6:  SUBLW  0A
00D7:  BTFSC  03.2
00D8:  GOTO   0DD
00D9:  MOVF   51,W
00DA:  SUBLW  0D
00DB:  BTFSS  03.2
00DC:  GOTO   107
....................         { 
....................             if (rx_temp_index > 0) 
00DD:  BCF    03.5
00DE:  MOVF   67,F
00DF:  BTFSC  03.2
00E0:  GOTO   105
....................             { 
....................                 rx_temp_buffer[rx_temp_index] = '\0'; 
00E1:  MOVLW  4E
00E2:  ADDWF  67,W
00E3:  MOVWF  04
00E4:  BCF    03.7
00E5:  CLRF   00
....................                 strcpy(rx_display_buffer, rx_temp_buffer); 
00E6:  BSF    03.5
00E7:  CLRF   55
00E8:  MOVLW  4E
00E9:  MOVWF  54
00EA:  CLRF   53
00EB:  MOVLW  A0
00EC:  MOVWF  52
00ED:  MOVF   54,W
00EE:  MOVWF  04
00EF:  BCF    03.7
00F0:  BTFSC  55.0
00F1:  BSF    03.7
00F2:  MOVF   00,W
00F3:  MOVWF  56
00F4:  MOVF   52,W
00F5:  MOVWF  04
00F6:  BCF    03.7
00F7:  BTFSC  53.0
00F8:  BSF    03.7
00F9:  MOVF   56,W
00FA:  MOVWF  00
00FB:  MOVF   00,F
00FC:  BTFSC  03.2
00FD:  GOTO   101
00FE:  INCF   52,F
00FF:  INCF   54,F
0100:  GOTO   0ED
....................                 rx_data_ready = 1; 
0101:  BCF    03.5
0102:  BSF    68.0
....................                 rx_temp_index = 0; 
0103:  CLRF   67
....................                 scroll_pos = 0; 
0104:  CLRF   6E
....................             } 
....................         } 
0105:  GOTO   115
0106:  BSF    03.5
....................         else 
....................         { 
....................             if (rx_temp_index < 20) 
0107:  BCF    03.5
0108:  MOVF   67,W
0109:  SUBLW  13
010A:  BTFSS  03.0
010B:  GOTO   115
....................                 rx_temp_buffer[rx_temp_index++] = incoming; 
010C:  MOVF   67,W
010D:  INCF   67,F
010E:  ADDLW  4E
010F:  MOVWF  04
0110:  BCF    03.7
0111:  BSF    03.5
0112:  MOVF   51,W
0113:  MOVWF  00
0114:  BCF    03.5
....................         } 
....................     } 
.................... } 
....................  
0115:  BCF    0C.5
0116:  BCF    0A.3
0117:  BCF    0A.4
0118:  GOTO   027
.................... #INT_TIMER1 
.................... void timer1_isr() 
.................... { 
....................     set_timer1(63036); 
0119:  CLRF   0E
011A:  MOVLW  F6
011B:  MOVWF  0F
011C:  MOVLW  3C
011D:  MOVWF  0E
....................     if (idle_counter < 32000) 
011E:  MOVF   6C,W
011F:  SUBLW  7C
0120:  BTFSS  03.0
0121:  GOTO   125
....................         idle_counter++; 
0122:  INCF   6B,F
0123:  BTFSC  03.2
0124:  INCF   6C,F
....................  
....................     int1 btn_current = !input(BTN_SIGNAL); 
0125:  BSF    03.5
0126:  BSF    06.0
0127:  BCF    51.0
0128:  BCF    03.5
0129:  BTFSC  06.0
012A:  GOTO   12E
012B:  BSF    03.5
012C:  BSF    51.0
012D:  BCF    03.5
....................  
....................     if (btn_current) 
012E:  BSF    03.5
012F:  BTFSS  51.0
0130:  GOTO   141
....................     { 
....................         idle_counter = 0; 
0131:  BCF    03.5
0132:  CLRF   6C
0133:  CLRF   6B
....................         press_counter++; 
0134:  INCF   69,F
0135:  BTFSC  03.2
0136:  INCF   6A,F
....................         output_high(LED_PIN); 
0137:  BSF    03.5
0138:  BCF    05.0
0139:  BCF    03.5
013A:  BSF    05.0
....................         output_high(BUZZER_PIN); 
013B:  BSF    03.5
013C:  BCF    05.1
013D:  BCF    03.5
013E:  BSF    05.1
....................     } 
013F:  GOTO   177
0140:  BSF    03.5
....................     else 
....................     { 
....................         output_low(LED_PIN); 
0141:  BCF    05.0
0142:  BCF    03.5
0143:  BCF    05.0
....................         output_low(BUZZER_PIN); 
0144:  BSF    03.5
0145:  BCF    05.1
0146:  BCF    03.5
0147:  BCF    05.1
....................         if (btn_prev_state == 1) 
0148:  BTFSS  68.1
0149:  GOTO   177
....................         { 
....................             idle_counter = 0; 
014A:  CLRF   6C
014B:  CLRF   6B
....................             if (press_counter > 2) 
014C:  MOVF   6A,F
014D:  BTFSS  03.2
014E:  GOTO   153
014F:  MOVF   69,W
0150:  SUBLW  02
0151:  BTFSC  03.0
0152:  GOTO   175
....................             { 
....................                 if (press_counter < 30) 
0153:  MOVF   6A,F
0154:  BTFSS  03.2
0155:  GOTO   162
0156:  MOVF   69,W
0157:  SUBLW  1D
0158:  BTFSS  03.0
0159:  GOTO   162
....................                     morse_buffer[morse_index++] = '.'; 
015A:  MOVF   4C,W
015B:  INCF   4C,F
015C:  ADDLW  2D
015D:  MOVWF  04
015E:  BCF    03.7
015F:  MOVLW  2E
0160:  MOVWF  00
0161:  GOTO   169
....................                 else 
....................                     morse_buffer[morse_index++] = '-'; 
0162:  MOVF   4C,W
0163:  INCF   4C,F
0164:  ADDLW  2D
0165:  MOVWF  04
0166:  BCF    03.7
0167:  MOVLW  2D
0168:  MOVWF  00
....................  
....................                 if (morse_index > 9) 
0169:  MOVF   4C,W
016A:  SUBLW  09
016B:  BTFSC  03.0
016C:  GOTO   16F
....................                     morse_index = 9; 
016D:  MOVLW  09
016E:  MOVWF  4C
....................  
....................                 morse_buffer[morse_index] = '\0'; 
016F:  MOVLW  2D
0170:  ADDWF  4C,W
0171:  MOVWF  04
0172:  BCF    03.7
0173:  CLRF   00
....................                 update_needed = 1; 
0174:  BSF    68.2
....................             } 
....................             press_counter = 0; 
0175:  CLRF   6A
0176:  CLRF   69
....................         } 
....................     } 
....................     btn_prev_state = btn_current; 
0177:  BCF    68.1
0178:  BSF    03.5
0179:  BTFSS  51.0
017A:  GOTO   17E
017B:  BCF    03.5
017C:  BSF    68.1
017D:  BSF    03.5
.................... } 
....................  
017E:  BCF    03.5
017F:  BCF    0C.0
0180:  BCF    0A.3
0181:  BCF    0A.4
0182:  GOTO   027
.................... #INT_TIMER0 
.................... void timer0_isr() 
.................... { 
....................     scroll_tick++; 
0183:  INCF   6D,F
....................     if (scroll_tick > 60) 
0184:  MOVF   6D,W
0185:  SUBLW  3C
0186:  BTFSC  03.0
0187:  GOTO   18A
....................     { 
....................         scroll_tick = 0; 
0188:  CLRF   6D
....................         scroll_now = 1; 
0189:  BSF    68.3
....................     } 
018A:  BCF    0B.2
018B:  BCF    0A.3
018C:  BCF    0A.4
018D:  GOTO   027
.................... } 
....................  
.................... void main() 
*
0800:  MOVLW  71
0801:  BSF    03.5
0802:  MOVWF  0F
0803:  MOVF   0F,W
0804:  BSF    03.6
0805:  BCF    07.3
0806:  MOVLW  0C
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  A2
080A:  MOVWF  18
080B:  MOVLW  90
080C:  BCF    03.5
080D:  MOVWF  18
080E:  CLRF   4C
080F:  CLRF   4D
0810:  CLRF   67
0811:  BCF    68.0
0812:  CLRF   6A
0813:  CLRF   69
0814:  CLRF   6C
0815:  CLRF   6B
0816:  BCF    68.1
0817:  BCF    68.2
0818:  CLRF   6D
0819:  BCF    68.3
081A:  CLRF   6E
081B:  BCF    68.4
081C:  BSF    03.5
081D:  BSF    03.6
081E:  MOVF   09,W
081F:  ANDLW  C0
0820:  MOVWF  09
0821:  BCF    03.6
0822:  BCF    1F.4
0823:  BCF    1F.5
0824:  MOVLW  00
0825:  BSF    03.6
0826:  MOVWF  08
0827:  BCF    03.5
0828:  CLRF   07
0829:  CLRF   08
082A:  CLRF   09
082B:  BCF    03.7
082C:  MOVLW  1F
082D:  ANDWF  03,F
.................... { 
....................     setup_wdt(WDT_OFF); 
*
0831:  BSF    03.6
0832:  BCF    05.0
....................  
....................     set_tris_b(0xFF); 
0833:  MOVLW  FF
0834:  BSF    03.5
0835:  BCF    03.6
0836:  MOVWF  06
....................     port_b_pullups(TRUE); 
0837:  MOVLW  01
0838:  MOVWF  15
0839:  BCF    01.7
....................     output_drive(LED_PIN); 
083A:  BCF    05.0
....................     output_drive(BUZZER_PIN); 
083B:  BCF    05.1
....................  
....................     output_high(BUZZER_PIN); 
083C:  BCF    05.1
083D:  BCF    03.5
083E:  BSF    05.1
....................     delay_ms(50); 
083F:  MOVLW  32
0840:  BSF    03.5
0841:  MOVWF  47
0842:  BCF    0A.3
0843:  BCF    03.5
0844:  CALL   19D
0845:  BSF    0A.3
....................     output_low(BUZZER_PIN); 
0846:  BSF    03.5
0847:  BCF    05.1
0848:  BCF    03.5
0849:  BCF    05.1
....................  
....................     lcd_init(); 
084A:  BCF    0A.3
084B:  CALL   27C
084C:  BSF    0A.3
....................     delay_ms(100); 
084D:  MOVLW  64
084E:  BSF    03.5
084F:  MOVWF  47
0850:  BCF    0A.3
0851:  BCF    03.5
0852:  CALL   19D
0853:  BSF    0A.3
....................  
....................     load_text_from_eeprom(); 
0854:  BCF    0A.3
0855:  GOTO   2C5
0856:  BSF    0A.3
....................     load_bt_from_eeprom(); 
0857:  BCF    0A.3
0858:  GOTO   2F9
0859:  BSF    0A.3
....................  
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
085A:  MOVLW  35
085B:  MOVWF  10
....................     set_timer1(63036); 
085C:  CLRF   0E
085D:  MOVLW  F6
085E:  MOVWF  0F
085F:  MOVLW  3C
0860:  MOVWF  0E
....................     setup_timer_0(T0_INTERNAL | T0_DIV_256); 
0861:  BSF    03.5
0862:  MOVF   01,W
0863:  ANDLW  C0
0864:  IORLW  07
0865:  MOVWF  01
....................  
....................     enable_interrupts(INT_TIMER1); 
0866:  BSF    0C.0
....................     enable_interrupts(INT_TIMER0); 
0867:  BCF    03.5
0868:  BSF    0B.5
....................     enable_interrupts(INT_RDA); 
0869:  BSF    03.5
086A:  BSF    0C.5
....................     enable_interrupts(GLOBAL); 
086B:  MOVLW  C0
086C:  BCF    03.5
086D:  IORWF  0B,F
....................  
....................     lcd_locate(1, 1); 
086E:  MOVLW  01
086F:  BSF    03.5
0870:  MOVWF  42
0871:  MOVWF  43
0872:  BCF    0A.3
0873:  BCF    03.5
0874:  CALL   32C
0875:  BSF    0A.3
....................     printf(lcd_putc, "Mors Telgraf"); 
0876:  MOVLW  8E
0877:  BSF    03.6
0878:  MOVWF  0D
0879:  MOVLW  01
087A:  MOVWF  0F
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   3A8
087E:  BSF    0A.3
....................     delay_ms(1000); 
087F:  MOVLW  04
0880:  BSF    03.5
0881:  MOVWF  3E
0882:  MOVLW  FA
0883:  MOVWF  47
0884:  BCF    0A.3
0885:  BCF    03.5
0886:  CALL   19D
0887:  BSF    0A.3
0888:  BSF    03.5
0889:  DECFSZ 3E,F
088A:  GOTO   082
....................  
....................     lcd_putc('\f'); 
088B:  MOVLW  0C
088C:  MOVWF  46
088D:  BCF    0A.3
088E:  BCF    03.5
088F:  CALL   36E
0890:  BSF    0A.3
....................     update_lcd(); 
0891:  BCF    0A.3
0892:  CALL   48B
0893:  BSF    0A.3
....................  
....................     setup_wdt(WDT_2304MS); 
0894:  MOVLW  09
0895:  BSF    03.6
0896:  MOVWF  05
0897:  MOVLW  0F
0898:  MOVWF  77
0899:  BCF    03.6
089A:  CLRF   01
089B:  MOVLW  81
089C:  MOVWF  04
089D:  BCF    03.7
089E:  MOVF   00,W
089F:  ANDLW  F0
08A0:  IORLW  07
08A1:  MOVWF  00
08A2:  CLRWDT
08A3:  MOVF   00,W
08A4:  ANDLW  F7
08A5:  BTFSC  77.3
08A6:  ANDLW  F0
08A7:  IORWF  77,W
08A8:  MOVWF  00
....................  
....................     while (TRUE) 
....................     { 
....................         restart_wdt(); 
08A9:  CLRWDT
....................  
....................         if (scroll_now) 
08AA:  BTFSS  68.3
08AB:  GOTO   0B6
....................         { 
....................             scroll_now = 0; 
08AC:  BCF    68.3
....................             if (rx_display_buffer[0] != '\0') 
08AD:  BSF    03.5
08AE:  MOVF   20,F
08AF:  BTFSC  03.2
08B0:  GOTO   0B7
....................             { 
....................                 scroll_pos++; 
08B1:  BCF    03.5
08B2:  INCF   6E,F
....................                 update_scroll_line(); 
08B3:  BCF    0A.3
08B4:  GOTO   51F
08B5:  BSF    0A.3
08B6:  BSF    03.5
....................             } 
....................         } 
....................  
....................         if (rx_data_ready) 
08B7:  BCF    03.5
08B8:  BTFSS  68.0
08B9:  GOTO   0C3
....................         { 
....................             save_bt_to_eeprom(); 
08BA:  BCF    0A.3
08BB:  GOTO   584
08BC:  BSF    0A.3
....................             rx_data_ready = 0; 
08BD:  BCF    68.0
....................             update_lcd(); 
08BE:  BCF    0A.3
08BF:  CALL   48B
08C0:  BSF    0A.3
....................             idle_counter = 0; 
08C1:  CLRF   6C
08C2:  CLRF   6B
....................         } 
....................  
....................         if (idle_counter > SLEEP_TIMEOUT) 
08C3:  MOVF   6C,W
08C4:  SUBLW  0A
08C5:  BTFSC  03.0
08C6:  GOTO   0D1
08C7:  XORLW  FF
08C8:  BTFSS  03.2
08C9:  GOTO   0CE
08CA:  MOVF   6B,W
08CB:  SUBLW  B8
08CC:  BTFSC  03.0
08CD:  GOTO   0D1
....................         { 
....................             enter_sleep_mode(); 
08CE:  BCF    0A.3
08CF:  CALL   5F7
08D0:  BSF    0A.3
....................         } 
....................  
....................         if (update_needed) 
08D1:  BTFSS  68.2
08D2:  GOTO   0D7
....................         { 
....................             update_lcd(); 
08D3:  BCF    0A.3
08D4:  CALL   48B
08D5:  BSF    0A.3
....................             update_needed = 0; 
08D6:  BCF    68.2
....................         } 
....................  
....................         if (!input(BTN_MODE) && !input(BTN_RESET)) 
08D7:  BSF    03.5
08D8:  BSF    06.4
08D9:  BCF    03.5
08DA:  BTFSC  06.4
08DB:  GOTO   101
08DC:  BSF    03.5
08DD:  BSF    06.3
08DE:  BCF    03.5
08DF:  BTFSC  06.3
08E0:  GOTO   101
....................         { 
....................             delay_ms(50); 
08E1:  MOVLW  32
08E2:  BSF    03.5
08E3:  MOVWF  47
08E4:  BCF    0A.3
08E5:  BCF    03.5
08E6:  CALL   19D
08E7:  BSF    0A.3
....................             if (!input(BTN_MODE) && !input(BTN_RESET)) 
08E8:  BSF    03.5
08E9:  BSF    06.4
08EA:  BCF    03.5
08EB:  BTFSC  06.4
08EC:  GOTO   101
08ED:  BSF    03.5
08EE:  BSF    06.3
08EF:  BCF    03.5
08F0:  BTFSC  06.3
08F1:  GOTO   101
....................             { 
....................                 enter_sleep_mode(); 
08F2:  BCF    0A.3
08F3:  CALL   5F7
08F4:  BSF    0A.3
....................                 while (!input(BTN_MODE) || !input(BTN_RESET)) 
08F5:  BSF    03.5
08F6:  BSF    06.4
08F7:  BCF    03.5
08F8:  BTFSS  06.4
08F9:  GOTO   0FF
08FA:  BSF    03.5
08FB:  BSF    06.3
08FC:  BCF    03.5
08FD:  BTFSC  06.3
08FE:  GOTO   101
....................                     restart_wdt(); 
08FF:  CLRWDT
0900:  GOTO   0F5
....................             } 
....................         } 
....................  
....................         if (!input(BTN_MODE) && input(BTN_RESET)) 
0901:  BSF    03.5
0902:  BSF    06.4
0903:  BCF    03.5
0904:  BTFSC  06.4
0905:  GOTO   125
0906:  BSF    03.5
0907:  BSF    06.3
0908:  BCF    03.5
0909:  BTFSS  06.3
090A:  GOTO   125
....................         { 
....................             idle_counter = 0; 
090B:  CLRF   6C
090C:  CLRF   6B
....................             delay_ms(50); 
090D:  MOVLW  32
090E:  BSF    03.5
090F:  MOVWF  47
0910:  BCF    0A.3
0911:  BCF    03.5
0912:  CALL   19D
0913:  BSF    0A.3
....................             if (!input(BTN_MODE)) 
0914:  BSF    03.5
0915:  BSF    06.4
0916:  BCF    03.5
0917:  BTFSC  06.4
0918:  GOTO   125
....................             { 
....................                 app_mode = !app_mode; 
0919:  MOVLW  10
091A:  XORWF  68,F
....................                 update_lcd(); 
091B:  BCF    0A.3
091C:  CALL   48B
091D:  BSF    0A.3
....................                 while (!input(BTN_MODE)) 
091E:  BSF    03.5
091F:  BSF    06.4
0920:  BCF    03.5
0921:  BTFSC  06.4
0922:  GOTO   125
....................                     restart_wdt(); 
0923:  CLRWDT
0924:  GOTO   11E
....................             } 
....................         } 
....................  
....................         if (!input(BTN_UPLOAD)) 
0925:  BSF    03.5
0926:  BSF    06.1
0927:  BCF    03.5
0928:  BTFSC  06.1
0929:  GOTO   1DF
....................         { 
....................             idle_counter = 0; 
092A:  CLRF   6C
092B:  CLRF   6B
....................             int16 hold_counter = 0; 
092C:  BSF    03.5
092D:  CLRF   3A
092E:  CLRF   39
....................  
....................             while (!input(BTN_UPLOAD) && hold_counter < 50) 
092F:  BSF    06.1
0930:  BCF    03.5
0931:  BTFSC  06.1
0932:  GOTO   14C
0933:  BSF    03.5
0934:  MOVF   3A,F
0935:  BTFSC  03.2
0936:  GOTO   139
0937:  BCF    03.5
0938:  GOTO   14C
0939:  MOVF   39,W
093A:  SUBLW  31
093B:  BTFSC  03.0
093C:  GOTO   13F
093D:  BCF    03.5
093E:  GOTO   14C
....................             { 
....................                 delay_ms(10); 
093F:  MOVLW  0A
0940:  MOVWF  47
0941:  BCF    0A.3
0942:  BCF    03.5
0943:  CALL   19D
0944:  BSF    0A.3
....................                 restart_wdt(); 
0945:  CLRWDT
....................                 hold_counter++; 
0946:  BSF    03.5
0947:  INCF   39,F
0948:  BTFSC  03.2
0949:  INCF   3A,F
094A:  GOTO   12F
094B:  BCF    03.5
....................             } 
....................  
....................             if (hold_counter >= 50) 
094C:  BSF    03.5
094D:  MOVF   3A,F
094E:  BTFSS  03.2
094F:  GOTO   154
0950:  MOVF   39,W
0951:  SUBLW  31
0952:  BTFSC  03.0
0953:  GOTO   1A6
....................             { 
....................                 if (text_index > 0) 
0954:  BCF    03.5
0955:  MOVF   4D,F
0956:  BTFSC  03.2
0957:  GOTO   16B
....................                 { 
....................                     send_nmea_packet(); 
0958:  BCF    0A.3
0959:  GOTO   65D
095A:  BSF    0A.3
....................                     output_high(BUZZER_PIN); 
095B:  BSF    03.5
095C:  BCF    05.1
095D:  BCF    03.5
095E:  BSF    05.1
....................                     wdt_delay_ms(100); 
095F:  BSF    03.5
0960:  CLRF   3F
0961:  MOVLW  64
0962:  MOVWF  3E
0963:  BCF    0A.3
0964:  BCF    03.5
0965:  CALL   5DE
0966:  BSF    0A.3
....................                     output_low(BUZZER_PIN); 
0967:  BSF    03.5
0968:  BCF    05.1
0969:  BCF    03.5
096A:  BCF    05.1
....................                 } 
....................                 while (!input(BTN_UPLOAD)) 
096B:  BSF    03.5
096C:  BSF    06.1
096D:  BCF    03.5
096E:  BTFSC  06.1
096F:  GOTO   172
....................                     restart_wdt(); 
0970:  CLRWDT
0971:  GOTO   16B
....................  
....................                 text_index = 0; 
0972:  CLRF   4D
....................                 text_buffer[0] = '\0'; 
0973:  CLRF   37
....................                 morse_index = 0; 
0974:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0975:  CLRF   2D
....................                 save_text_to_eeprom(); 
0976:  BCF    0A.3
0977:  CALL   6E2
0978:  BSF    0A.3
....................  
....................                 lcd_putc('\f'); 
0979:  MOVLW  0C
097A:  BSF    03.5
097B:  MOVWF  46
097C:  BCF    0A.3
097D:  BCF    03.5
097E:  CALL   36E
097F:  BSF    0A.3
....................                 lcd_locate(1, 1); 
0980:  MOVLW  01
0981:  BSF    03.5
0982:  MOVWF  42
0983:  MOVWF  43
0984:  BCF    0A.3
0985:  BCF    03.5
0986:  CALL   32C
0987:  BSF    0A.3
....................                 printf(lcd_putc, "VERI GONDERILDI"); 
0988:  MOVLW  95
0989:  BSF    03.6
098A:  MOVWF  0D
098B:  MOVLW  01
098C:  MOVWF  0F
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   3A8
0990:  BSF    0A.3
....................                 wdt_delay_ms(1000); 
0991:  MOVLW  03
0992:  BSF    03.5
0993:  MOVWF  3F
0994:  MOVLW  E8
0995:  MOVWF  3E
0996:  BCF    0A.3
0997:  BCF    03.5
0998:  CALL   5DE
0999:  BSF    0A.3
....................                 lcd_putc('\f'); 
099A:  MOVLW  0C
099B:  BSF    03.5
099C:  MOVWF  46
099D:  BCF    0A.3
099E:  BCF    03.5
099F:  CALL   36E
09A0:  BSF    0A.3
....................                 update_lcd(); 
09A1:  BCF    0A.3
09A2:  CALL   48B
09A3:  BSF    0A.3
....................             } 
09A4:  GOTO   1DF
09A5:  BSF    03.5
....................             else 
....................             { 
....................                 while (!input(BTN_UPLOAD)) 
09A6:  BSF    06.1
09A7:  BCF    03.5
09A8:  BTFSC  06.1
09A9:  GOTO   1AE
....................                     restart_wdt(); 
09AA:  CLRWDT
09AB:  BSF    03.5
09AC:  GOTO   1A6
09AD:  BCF    03.5
....................                 if (morse_index > 0) 
09AE:  MOVF   4C,F
09AF:  BTFSC  03.2
09B0:  GOTO   1DF
....................                 { 
....................                     char final_char = decode_morse(morse_buffer); 
09B1:  BSF    03.5
09B2:  CLRF   42
09B3:  MOVLW  2D
09B4:  MOVWF  41
09B5:  BCF    0A.3
09B6:  BCF    03.5
09B7:  CALL   44B
09B8:  BSF    0A.3
09B9:  MOVF   78,W
09BA:  BSF    03.5
09BB:  MOVWF  3B
....................                     if (text_index < 20 && final_char != '?') 
09BC:  BCF    03.5
09BD:  MOVF   4D,W
09BE:  SUBLW  13
09BF:  BTFSS  03.0
09C0:  GOTO   1DA
09C1:  BSF    03.5
09C2:  MOVF   3B,W
09C3:  SUBLW  3F
09C4:  BTFSS  03.2
09C5:  GOTO   1C8
09C6:  BCF    03.5
09C7:  GOTO   1DA
....................                     { 
....................                         text_buffer[text_index++] = final_char; 
09C8:  BCF    03.5
09C9:  MOVF   4D,W
09CA:  INCF   4D,F
09CB:  ADDLW  37
09CC:  MOVWF  04
09CD:  BCF    03.7
09CE:  BSF    03.5
09CF:  MOVF   3B,W
09D0:  MOVWF  00
....................                         text_buffer[text_index] = '\0'; 
09D1:  MOVLW  37
09D2:  BCF    03.5
09D3:  ADDWF  4D,W
09D4:  MOVWF  04
09D5:  BCF    03.7
09D6:  CLRF   00
....................                         save_text_to_eeprom(); 
09D7:  BCF    0A.3
09D8:  CALL   6E2
09D9:  BSF    0A.3
....................                     } 
....................                     morse_index = 0; 
09DA:  CLRF   4C
....................                     morse_buffer[0] = '\0'; 
09DB:  CLRF   2D
....................                     update_lcd(); 
09DC:  BCF    0A.3
09DD:  CALL   48B
09DE:  BSF    0A.3
....................                 } 
....................             } 
....................         } 
....................  
....................         if (!input(BTN_DELETE)) 
09DF:  BSF    03.5
09E0:  BSF    06.2
09E1:  BCF    03.5
09E2:  BTFSC  06.2
09E3:  GOTO   212
....................         { 
....................             delay_ms(20); 
09E4:  MOVLW  14
09E5:  BSF    03.5
09E6:  MOVWF  47
09E7:  BCF    0A.3
09E8:  BCF    03.5
09E9:  CALL   19D
09EA:  BSF    0A.3
....................             if (!input(BTN_DELETE)) 
09EB:  BSF    03.5
09EC:  BSF    06.2
09ED:  BCF    03.5
09EE:  BTFSC  06.2
09EF:  GOTO   212
....................             { 
....................                 idle_counter = 0; 
09F0:  CLRF   6C
09F1:  CLRF   6B
....................                 if (morse_index > 0) 
09F2:  MOVF   4C,F
09F3:  BTFSC  03.2
09F4:  GOTO   1FC
....................                     morse_buffer[--morse_index] = '\0'; 
09F5:  DECF   4C,F
09F6:  MOVLW  2D
09F7:  ADDWF  4C,W
09F8:  MOVWF  04
09F9:  BCF    03.7
09FA:  CLRF   00
09FB:  GOTO   208
....................                 else if (text_index > 0) 
09FC:  MOVF   4D,F
09FD:  BTFSC  03.2
09FE:  GOTO   208
....................                 { 
....................                     text_buffer[--text_index] = '\0'; 
09FF:  DECF   4D,F
0A00:  MOVLW  37
0A01:  ADDWF  4D,W
0A02:  MOVWF  04
0A03:  BCF    03.7
0A04:  CLRF   00
....................                     save_text_to_eeprom(); 
0A05:  BCF    0A.3
0A06:  CALL   6E2
0A07:  BSF    0A.3
....................                 } 
....................                 update_lcd(); 
0A08:  BCF    0A.3
0A09:  CALL   48B
0A0A:  BSF    0A.3
....................                 while (!input(BTN_DELETE)) 
0A0B:  BSF    03.5
0A0C:  BSF    06.2
0A0D:  BCF    03.5
0A0E:  BTFSC  06.2
0A0F:  GOTO   212
....................                     restart_wdt(); 
0A10:  CLRWDT
0A11:  GOTO   20B
....................             } 
....................         } 
....................  
....................         if (!input(BTN_RESET) && input(BTN_MODE)) 
0A12:  BSF    03.5
0A13:  BSF    06.3
0A14:  BCF    03.5
0A15:  BTFSC  06.3
0A16:  GOTO   265
0A17:  BSF    03.5
0A18:  BSF    06.4
0A19:  BCF    03.5
0A1A:  BTFSS  06.4
0A1B:  GOTO   265
....................         { 
....................             idle_counter = 0; 
0A1C:  CLRF   6C
0A1D:  CLRF   6B
....................             int16 reset_hold = 0; 
0A1E:  BSF    03.5
0A1F:  CLRF   3D
0A20:  CLRF   3C
....................  
....................             while (!input(BTN_RESET)) 
0A21:  BSF    06.3
0A22:  BCF    03.5
0A23:  BTFSC  06.3
0A24:  GOTO   247
....................             { 
....................                 delay_ms(10); 
0A25:  MOVLW  0A
0A26:  BSF    03.5
0A27:  MOVWF  47
0A28:  BCF    0A.3
0A29:  BCF    03.5
0A2A:  CALL   19D
0A2B:  BSF    0A.3
....................                 restart_wdt(); 
0A2C:  CLRWDT
....................                 reset_hold++; 
0A2D:  BSF    03.5
0A2E:  INCF   3C,F
0A2F:  BTFSC  03.2
0A30:  INCF   3D,F
....................  
....................                 if (reset_hold > 200) 
0A31:  MOVF   3D,F
0A32:  BTFSS  03.2
0A33:  GOTO   238
0A34:  MOVF   3C,W
0A35:  SUBLW  C8
0A36:  BTFSC  03.0
0A37:  GOTO   245
....................                 { 
....................                     full_wipe_reset(); 
0A38:  BCF    0A.3
0A39:  BCF    03.5
0A3A:  GOTO   72F
0A3B:  BSF    0A.3
....................                     while (!input(BTN_RESET)) 
0A3C:  BSF    03.5
0A3D:  BSF    06.3
0A3E:  BCF    03.5
0A3F:  BTFSC  06.3
0A40:  GOTO   243
....................                         restart_wdt(); 
0A41:  CLRWDT
0A42:  GOTO   23C
....................                     break; 
0A43:  GOTO   247
0A44:  BSF    03.5
....................                 } 
0A45:  GOTO   221
0A46:  BCF    03.5
....................             } 
....................  
....................             if (reset_hold > 5 && reset_hold <= 200) 
0A47:  BSF    03.5
0A48:  MOVF   3D,F
0A49:  BTFSS  03.2
0A4A:  GOTO   24F
0A4B:  MOVF   3C,W
0A4C:  SUBLW  05
0A4D:  BTFSC  03.0
0A4E:  GOTO   266
0A4F:  MOVF   3D,F
0A50:  BTFSS  03.2
0A51:  GOTO   266
0A52:  MOVF   3C,W
0A53:  SUBLW  C8
0A54:  BTFSS  03.0
0A55:  GOTO   266
....................             { 
....................                 text_index = 0; 
0A56:  BCF    03.5
0A57:  CLRF   4D
....................                 text_buffer[0] = '\0'; 
0A58:  CLRF   37
....................                 morse_index = 0; 
0A59:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0A5A:  CLRF   2D
....................                 update_lcd(); 
0A5B:  BCF    0A.3
0A5C:  CALL   48B
0A5D:  BSF    0A.3
....................                 while (!input(BTN_RESET)) 
0A5E:  BSF    03.5
0A5F:  BSF    06.3
0A60:  BCF    03.5
0A61:  BTFSC  06.3
0A62:  GOTO   265
....................                     restart_wdt(); 
0A63:  CLRWDT
0A64:  GOTO   25E
0A65:  BSF    03.5
....................             } 
....................         } 
0A66:  BCF    03.5
0A67:  GOTO   0A9
....................     } 
.................... } 
0A68:  SLEEP

Configuration Fuses:
   Word  1: 2CC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
