CCS PCM C Compiler, Version 5.007, 61971               30-Ara-25 08:25

               Filename:   C:\Users\Alihan\Desktop\Pic_Telegraph\src\main.lst

               ROM used:   2786 words (34%)
                           Largest free fragment is 2048
               RAM used:   126 (34%) at main() level
                           151 (41%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   0B4
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   038
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.0
0020:  GOTO   023
0021:  BTFSC  0C.0
0022:  GOTO   03B
0023:  BTFSS  0B.5
0024:  GOTO   027
0025:  BTFSC  0B.2
0026:  GOTO   03E
0027:  MOVF   22,W
0028:  MOVWF  04
0029:  MOVF   23,W
002A:  MOVWF  77
002B:  MOVF   24,W
002C:  MOVWF  78
002D:  MOVF   25,W
002E:  MOVWF  79
002F:  MOVF   26,W
0030:  MOVWF  7A
0031:  MOVF   20,W
0032:  MOVWF  0A
0033:  SWAPF  21,W
0034:  MOVWF  03
0035:  SWAPF  7F,F
0036:  SWAPF  7F,W
0037:  RETFIE
0038:  BCF    0A.3
0039:  BCF    0A.4
003A:  GOTO   0DC
003B:  BCF    0A.3
003C:  BCF    0A.4
003D:  GOTO   106
003E:  BCF    0A.3
003F:  BCF    0A.4
0040:  GOTO   171
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
0041:  BCF    0A.0
0042:  BCF    0A.1
0043:  BCF    0A.2
0044:  ADDWF  02,F
0045:  RETLW  28
0046:  RETLW  0C
0047:  RETLW  01
0048:  RETLW  06
0049:  BCF    0A.0
004A:  BCF    0A.1
004B:  BCF    0A.2
004C:  ADDWF  02,F
004D:  RETLW  00
004E:  RETLW  00
004F:  RETLW  45
0050:  RETLW  54
0051:  RETLW  49
0052:  RETLW  41
0053:  RETLW  4E
0054:  RETLW  4D
0055:  RETLW  53
0056:  RETLW  55
0057:  RETLW  52
0058:  RETLW  57
0059:  RETLW  44
005A:  RETLW  4B
005B:  RETLW  47
005C:  RETLW  4F
005D:  RETLW  48
005E:  RETLW  56
005F:  RETLW  46
0060:  RETLW  00
0061:  RETLW  4C
0062:  RETLW  00
0063:  RETLW  50
0064:  RETLW  4A
0065:  RETLW  42
0066:  RETLW  58
0067:  RETLW  43
0068:  RETLW  59
0069:  RETLW  5A
006A:  RETLW  51
006B:  RETLW  00
006C:  RETLW  00
006D:  RETLW  35
006E:  RETLW  34
006F:  RETLW  00
0070:  RETLW  33
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  00
0074:  RETLW  32
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  00
007B:  RETLW  00
007C:  RETLW  31
007D:  RETLW  36
007E:  RETLW  00
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  00
0082:  RETLW  00
0083:  RETLW  00
0084:  RETLW  00
0085:  RETLW  37
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  00
0089:  RETLW  38
008A:  RETLW  00
008B:  RETLW  39
008C:  RETLW  30
008D:  BCF    0A.0
008E:  BCF    0A.1
008F:  BCF    0A.2
0090:  ADDWF  02,F
0091:  RETLW  46
0092:  RETLW  4F
0093:  RETLW  52
0094:  RETLW  4D
0095:  RETLW  41
0096:  RETLW  54
0097:  RETLW  20
0098:  RETLW  48
0099:  RETLW  41
009A:  RETLW  54
009B:  RETLW  41
009C:  RETLW  53
009D:  RETLW  49
009E:  RETLW  00
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 00,00
00AA:  DATA CD,27
00AB:  DATA 44,1D
00AC:  DATA A0,26
00AD:  DATA C5,29
00AE:  DATA 41,25
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 00,01
00B5:  DATA CD,27
00B6:  DATA 44,1D
00B7:  DATA A0,25
00B8:  DATA CF,26
00B9:  DATA 55,2A
00BA:  DATA 20,10
00BB:  DATA 20,10
00BC:  DATA 20,10
00BD:  DATA 20,10
00BE:  DATA 20,10
00BF:  DATA 00,01
00C0:  DATA 20,10
00C1:  DATA 00,01
00C2:  DATA 20,10
00C3:  DATA 20,10
00C4:  DATA 20,10
00C5:  DATA 20,10
00C6:  DATA 20,10
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,10
00CB:  DATA 20,10
00CC:  DATA 00,00
00CD:  DATA D5,2C
00CE:  DATA CB,2A
00CF:  DATA A0,26
00D0:  DATA 4F,22
00D1:  DATA 55,17
00D2:  DATA 2E,17
00D3:  DATA 00,00
00D4:  DATA C8,22
00D5:  DATA D0,29
00D6:  DATA 49,10
00D7:  DATA D3,24
00D8:  DATA CC,24
00D9:  DATA CE,24
00DA:  DATA D9,27
00DB:  DATA 52,00
*
017C:  DATA CD,37
017D:  DATA F2,39
017E:  DATA 20,2A
017F:  DATA 65,36
0180:  DATA 67,39
0181:  DATA 61,33
0182:  DATA 00,01
0183:  DATA D6,22
0184:  DATA D2,24
0185:  DATA A0,23
0186:  DATA 4F,27
0187:  DATA C4,22
0188:  DATA D2,24
0189:  DATA 4C,22
018A:  DATA 49,00
*
0396:  MOVF   0B,W
0397:  BSF    03.5
0398:  MOVWF  45
0399:  BCF    03.5
039A:  BCF    0B.7
039B:  BSF    03.5
039C:  BSF    03.6
039D:  BSF    0C.7
039E:  BSF    0C.0
039F:  NOP
03A0:  NOP
03A1:  BCF    03.5
03A2:  MOVF   0C,W
03A3:  ANDLW  7F
03A4:  BTFSC  03.2
03A5:  GOTO   3F3
03A6:  BSF    03.5
03A7:  BCF    03.6
03A8:  MOVWF  46
03A9:  BCF    03.5
03AA:  BSF    03.6
03AB:  MOVF   0D,W
03AC:  BSF    03.5
03AD:  BCF    03.6
03AE:  MOVWF  47
03AF:  BCF    03.5
03B0:  BSF    03.6
03B1:  MOVF   0F,W
03B2:  BSF    03.5
03B3:  BCF    03.6
03B4:  MOVWF  48
03B5:  MOVF   46,W
03B6:  MOVWF  49
03B7:  BCF    03.5
03B8:  CALL   35C
03B9:  BSF    03.5
03BA:  MOVF   47,W
03BB:  BCF    03.5
03BC:  BSF    03.6
03BD:  MOVWF  0D
03BE:  BSF    03.5
03BF:  BCF    03.6
03C0:  MOVF   48,W
03C1:  BCF    03.5
03C2:  BSF    03.6
03C3:  MOVWF  0F
03C4:  BSF    03.5
03C5:  BSF    0C.7
03C6:  BSF    0C.0
03C7:  NOP
03C8:  NOP
03C9:  BCF    03.5
03CA:  RLF    0C,W
03CB:  RLF    0E,W
03CC:  ANDLW  7F
03CD:  BTFSC  03.2
03CE:  GOTO   3F3
03CF:  BSF    03.5
03D0:  BCF    03.6
03D1:  MOVWF  46
03D2:  BCF    03.5
03D3:  BSF    03.6
03D4:  MOVF   0D,W
03D5:  BSF    03.5
03D6:  BCF    03.6
03D7:  MOVWF  47
03D8:  BCF    03.5
03D9:  BSF    03.6
03DA:  MOVF   0F,W
03DB:  BSF    03.5
03DC:  BCF    03.6
03DD:  MOVWF  48
03DE:  MOVF   46,W
03DF:  MOVWF  49
03E0:  BCF    03.5
03E1:  CALL   35C
03E2:  BSF    03.5
03E3:  MOVF   47,W
03E4:  BCF    03.5
03E5:  BSF    03.6
03E6:  MOVWF  0D
03E7:  BSF    03.5
03E8:  BCF    03.6
03E9:  MOVF   48,W
03EA:  BCF    03.5
03EB:  BSF    03.6
03EC:  MOVWF  0F
03ED:  INCF   0D,F
03EE:  BTFSC  03.2
03EF:  INCF   0F,F
03F0:  BCF    03.6
03F1:  GOTO   39B
03F2:  BSF    03.6
03F3:  BSF    03.5
03F4:  BCF    03.6
03F5:  BTFSS  45.7
03F6:  GOTO   3FA
03F7:  BCF    03.5
03F8:  BSF    0B.7
03F9:  BSF    03.5
03FA:  BCF    03.5
03FB:  RETURN
03FC:  MOVF   00,F
03FD:  BTFSC  03.2
03FE:  GOTO   418
03FF:  BSF    03.5
0400:  CLRF   45
0401:  MOVF   04,W
0402:  MOVWF  44
0403:  BCF    45.0
0404:  BTFSC  03.7
0405:  BSF    45.0
0406:  MOVF   00,W
0407:  MOVWF  49
0408:  BCF    03.5
0409:  CALL   35C
040A:  BSF    03.5
040B:  MOVF   44,W
040C:  MOVWF  04
040D:  BCF    03.7
040E:  BTFSC  45.0
040F:  BSF    03.7
0410:  INCF   04,F
0411:  BTFSS  03.2
0412:  GOTO   416
0413:  BCF    03.5
0414:  INCF   05,F
0415:  BSF    03.5
0416:  BCF    03.5
0417:  GOTO   3FC
0418:  RETURN
*
0540:  MOVF   48,W
0541:  CLRF   78
0542:  SUBWF  47,W
0543:  BTFSC  03.0
0544:  GOTO   548
0545:  MOVF   47,W
0546:  MOVWF  77
0547:  GOTO   554
0548:  CLRF   77
0549:  MOVLW  08
054A:  MOVWF  49
054B:  RLF    47,F
054C:  RLF    77,F
054D:  MOVF   48,W
054E:  SUBWF  77,W
054F:  BTFSC  03.0
0550:  MOVWF  77
0551:  RLF    78,F
0552:  DECFSZ 49,F
0553:  GOTO   54B
*
0794:  BTFSC  47.7
0795:  GOTO   7A9
0796:  MOVLW  0F
0797:  MOVWF  77
0798:  SWAPF  46,W
0799:  ANDWF  77,F
079A:  MOVLW  0A
079B:  SUBWF  77,W
079C:  BTFSC  03.0
079D:  GOTO   7A1
079E:  MOVLW  30
079F:  ADDWF  77,F
07A0:  GOTO   7A3
07A1:  MOVF   47,W
07A2:  ADDWF  77,F
07A3:  MOVF   77,W
07A4:  BCF    03.5
07A5:  BTFSS  0C.4
07A6:  GOTO   7A5
07A7:  MOVWF  19
07A8:  BSF    03.5
07A9:  MOVLW  0F
07AA:  ANDWF  46,F
07AB:  MOVLW  0A
07AC:  SUBWF  46,W
07AD:  BTFSC  03.0
07AE:  GOTO   7B1
07AF:  MOVLW  30
07B0:  GOTO   7B3
07B1:  BCF    47.7
07B2:  MOVF   47,W
07B3:  ADDWF  46,F
07B4:  MOVF   46,W
07B5:  BCF    03.5
07B6:  BTFSS  0C.4
07B7:  GOTO   7B6
07B8:  MOVWF  19
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOWDT, NOPROTECT, NOLVP, NOBROWNOUT, PUT, NOMCLR 
.................... #use delay(clock = 8000000) 
*
018B:  MOVLW  CA
018C:  MOVWF  04
018D:  BCF    03.7
018E:  MOVF   00,W
018F:  BTFSC  03.2
0190:  GOTO   19E
0191:  MOVLW  02
0192:  MOVWF  78
0193:  CLRF   77
0194:  DECFSZ 77,F
0195:  GOTO   194
0196:  DECFSZ 78,F
0197:  GOTO   193
0198:  MOVLW  97
0199:  MOVWF  77
019A:  DECFSZ 77,F
019B:  GOTO   19A
019C:  DECFSZ 00,F
019D:  GOTO   191
019E:  RETURN
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = BT_MODUL) 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0594:  BSF    03.5
0595:  MOVF   49,W
0596:  MOVWF  4F
0597:  MOVF   48,W
0598:  MOVWF  4E
0599:  MOVF   4C,F
059A:  BTFSS  03.2
059B:  GOTO   59F
059C:  MOVF   4D,F
059D:  BTFSC  03.2
059E:  GOTO   5CA
059F:  MOVF   4B,W
05A0:  MOVWF  7A
05A1:  MOVF   4A,W
05A2:  MOVWF  04
05A3:  BCF    03.7
05A4:  BTFSC  7A.0
05A5:  BSF    03.7
05A6:  MOVF   00,F
05A7:  BTFSC  03.2
05A8:  GOTO   5CA
....................      *s++ = *s2++; 
05A9:  MOVF   4F,W
05AA:  MOVWF  7A
05AB:  MOVF   4E,W
05AC:  INCF   4E,F
05AD:  BTFSC  03.2
05AE:  INCF   4F,F
05AF:  MOVWF  50
05B0:  MOVF   7A,W
05B1:  MOVWF  51
05B2:  MOVF   4B,W
05B3:  MOVWF  7A
05B4:  MOVF   4A,W
05B5:  INCF   4A,F
05B6:  BTFSC  03.2
05B7:  INCF   4B,F
05B8:  MOVWF  04
05B9:  BCF    03.7
05BA:  BTFSC  7A.0
05BB:  BSF    03.7
05BC:  MOVF   00,W
05BD:  MOVWF  52
05BE:  MOVF   50,W
05BF:  MOVWF  04
05C0:  BCF    03.7
05C1:  BTFSC  51.0
05C2:  BSF    03.7
05C3:  MOVF   52,W
05C4:  MOVWF  00
05C5:  MOVF   4C,W
05C6:  BTFSC  03.2
05C7:  DECF   4D,F
05C8:  DECF   4C,F
05C9:  GOTO   599
....................   for (; n > 0; n--) 
05CA:  MOVF   4C,F
05CB:  BTFSS  03.2
05CC:  GOTO   5D0
05CD:  MOVF   4D,F
05CE:  BTFSC  03.2
05CF:  GOTO   5E0
....................      *s++ = '\0'; 
05D0:  MOVF   4F,W
05D1:  MOVWF  7A
05D2:  MOVF   4E,W
05D3:  INCF   4E,F
05D4:  BTFSC  03.2
05D5:  INCF   4F,F
05D6:  MOVWF  04
05D7:  BCF    03.7
05D8:  BTFSC  7A.0
05D9:  BSF    03.7
05DA:  CLRF   00
05DB:  MOVF   4C,W
05DC:  BTFSC  03.2
05DD:  DECF   4D,F
05DE:  DECF   4C,F
05DF:  GOTO   5CA
....................  
....................   return(s1); 
05E0:  MOVF   48,W
05E1:  MOVWF  78
05E2:  MOVF   49,W
05E3:  MOVWF  79
05E4:  BCF    03.5
05E5:  RETURN
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0570:  BSF    03.5
0571:  MOVF   47,W
0572:  MOVWF  7A
0573:  MOVF   46,W
0574:  MOVWF  04
0575:  BCF    03.7
0576:  BTFSC  7A.0
0577:  BSF    03.7
0578:  MOVF   48,W
0579:  SUBWF  00,W
057A:  BTFSC  03.2
057B:  GOTO   58E
....................       if (*s == '\0') 
057C:  MOVF   47,W
057D:  MOVWF  7A
057E:  MOVF   46,W
057F:  MOVWF  04
0580:  BCF    03.7
0581:  BTFSC  7A.0
0582:  BSF    03.7
0583:  MOVF   00,F
0584:  BTFSS  03.2
0585:  GOTO   58A
....................          return(0); 
0586:  MOVLW  00
0587:  MOVWF  78
0588:  MOVWF  79
0589:  GOTO   592
058A:  INCF   46,F
058B:  BTFSC  03.2
058C:  INCF   47,F
058D:  GOTO   571
....................    return(s); 
058E:  MOVF   46,W
058F:  MOVWF  78
0590:  MOVF   47,W
0591:  MOVWF  79
0592:  BCF    03.5
0593:  RETURN
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
08E2:  BCF    03.6
08E3:  CLRF   27
08E4:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0419:  BSF    03.5
041A:  MOVF   4A,W
041B:  MOVWF  4C
041C:  MOVF   49,W
041D:  MOVWF  4B
041E:  MOVF   4C,W
041F:  MOVWF  7A
0420:  MOVF   4B,W
0421:  MOVWF  04
0422:  BCF    03.7
0423:  BTFSC  7A.0
0424:  BSF    03.7
0425:  MOVF   00,F
0426:  BTFSC  03.2
0427:  GOTO   42C
0428:  INCF   4B,F
0429:  BTFSC  03.2
042A:  INCF   4C,F
042B:  GOTO   41E
....................    return(sc - s); 
042C:  MOVF   49,W
042D:  SUBWF  4B,W
042E:  MOVWF  77
042F:  MOVF   4C,W
0430:  MOVWF  7A
0431:  MOVF   4A,W
0432:  BTFSS  03.0
0433:  INCFSZ 4A,W
0434:  SUBWF  7A,F
0435:  MOVF   77,W
0436:  MOVWF  78
0437:  BCF    03.5
0438:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LCD_RS_PIN PIN_D1 
.................... #define LCD_RW_PIN PIN_D2 
.................... #define LCD_ENABLE_PIN PIN_D3 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... #include <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0210:  BSF    08.4
....................    output_float(LCD_DATA5); 
0211:  BSF    08.5
....................    output_float(LCD_DATA6); 
0212:  BSF    08.6
....................    output_float(LCD_DATA7); 
0213:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0214:  BCF    03.5
0215:  BSF    08.2
0216:  BSF    03.5
0217:  BCF    08.2
....................    delay_cycles(1); 
0218:  NOP
....................    lcd_output_enable(1); 
0219:  BCF    03.5
021A:  BSF    08.3
021B:  BSF    03.5
021C:  BCF    08.3
....................    delay_cycles(1); 
021D:  NOP
....................    high = lcd_read_nibble(); 
021E:  BCF    03.5
021F:  CALL   1D5
0220:  MOVF   78,W
0221:  BSF    03.5
0222:  MOVWF  51
....................        
....................    lcd_output_enable(0); 
0223:  BCF    03.5
0224:  BCF    08.3
0225:  BSF    03.5
0226:  BCF    08.3
....................    delay_cycles(1); 
0227:  NOP
....................    lcd_output_enable(1); 
0228:  BCF    03.5
0229:  BSF    08.3
022A:  BSF    03.5
022B:  BCF    08.3
....................    delay_us(1); 
022C:  GOTO   22D
....................    low = lcd_read_nibble(); 
022D:  BCF    03.5
022E:  CALL   1D5
022F:  MOVF   78,W
0230:  BSF    03.5
0231:  MOVWF  50
....................        
....................    lcd_output_enable(0); 
0232:  BCF    03.5
0233:  BCF    08.3
0234:  BSF    03.5
0235:  BCF    08.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0236:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0237:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0238:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0239:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
023A:  SWAPF  51,W
023B:  MOVWF  77
023C:  MOVLW  F0
023D:  ANDWF  77,F
023E:  MOVF   77,W
023F:  IORWF  50,W
0240:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01D5:  BSF    03.5
01D6:  CLRF   52
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01D7:  BSF    08.4
01D8:  MOVLW  00
01D9:  BCF    03.5
01DA:  BTFSC  08.4
01DB:  MOVLW  01
01DC:  BSF    03.5
01DD:  IORWF  52,F
....................    n |= input(LCD_DATA5) << 1; 
01DE:  BSF    08.5
01DF:  MOVLW  00
01E0:  BCF    03.5
01E1:  BTFSC  08.5
01E2:  MOVLW  01
01E3:  MOVWF  77
01E4:  BCF    03.0
01E5:  RLF    77,F
01E6:  MOVF   77,W
01E7:  BSF    03.5
01E8:  IORWF  52,F
....................    n |= input(LCD_DATA6) << 2; 
01E9:  BSF    08.6
01EA:  MOVLW  00
01EB:  BCF    03.5
01EC:  BTFSC  08.6
01ED:  MOVLW  01
01EE:  MOVWF  77
01EF:  RLF    77,F
01F0:  RLF    77,F
01F1:  MOVLW  FC
01F2:  ANDWF  77,F
01F3:  MOVF   77,W
01F4:  BSF    03.5
01F5:  IORWF  52,F
....................    n |= input(LCD_DATA7) << 3; 
01F6:  BSF    08.7
01F7:  MOVLW  00
01F8:  BCF    03.5
01F9:  BTFSC  08.7
01FA:  MOVLW  01
01FB:  MOVWF  77
01FC:  RLF    77,F
01FD:  RLF    77,F
01FE:  RLF    77,F
01FF:  MOVLW  F8
0200:  ANDWF  77,F
0201:  MOVF   77,W
0202:  BSF    03.5
0203:  IORWF  52,F
....................     
....................    return(n); 
0204:  MOVF   52,W
0205:  MOVWF  78
....................   #else 
0206:  BCF    03.5
0207:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
019F:  BSF    03.5
01A0:  BTFSC  51.0
01A1:  GOTO   1A6
01A2:  BCF    03.5
01A3:  BCF    08.4
01A4:  GOTO   1A8
01A5:  BSF    03.5
01A6:  BCF    03.5
01A7:  BSF    08.4
01A8:  BSF    03.5
01A9:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
01AA:  BTFSC  51.1
01AB:  GOTO   1B0
01AC:  BCF    03.5
01AD:  BCF    08.5
01AE:  GOTO   1B2
01AF:  BSF    03.5
01B0:  BCF    03.5
01B1:  BSF    08.5
01B2:  BSF    03.5
01B3:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
01B4:  BTFSC  51.2
01B5:  GOTO   1BA
01B6:  BCF    03.5
01B7:  BCF    08.6
01B8:  GOTO   1BC
01B9:  BSF    03.5
01BA:  BCF    03.5
01BB:  BSF    08.6
01BC:  BSF    03.5
01BD:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01BE:  BTFSC  51.3
01BF:  GOTO   1C4
01C0:  BCF    03.5
01C1:  BCF    08.7
01C2:  GOTO   1C6
01C3:  BSF    03.5
01C4:  BCF    03.5
01C5:  BSF    08.7
01C6:  BSF    03.5
01C7:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01C8:  NOP
....................    lcd_output_enable(1); 
01C9:  BCF    03.5
01CA:  BSF    08.3
01CB:  BSF    03.5
01CC:  BCF    08.3
....................    delay_us(2); 
01CD:  GOTO   1CE
01CE:  GOTO   1CF
....................    lcd_output_enable(0); 
01CF:  BCF    03.5
01D0:  BCF    08.3
01D1:  BSF    03.5
01D2:  BCF    08.3
01D3:  BCF    03.5
01D4:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0208:  BSF    03.5
0209:  BCF    08.3
....................    lcd_rs_tris(); 
020A:  BCF    08.1
....................    lcd_rw_tris(); 
020B:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
020C:  BCF    03.5
020D:  BCF    08.1
020E:  BSF    03.5
020F:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0241:  MOVF   78,W
0242:  MOVWF  50
0243:  BTFSC  50.7
0244:  GOTO   210
....................    lcd_output_rs(address); 
0245:  MOVF   4E,F
0246:  BTFSS  03.2
0247:  GOTO   24C
0248:  BCF    03.5
0249:  BCF    08.1
024A:  GOTO   24E
024B:  BSF    03.5
024C:  BCF    03.5
024D:  BSF    08.1
024E:  BSF    03.5
024F:  BCF    08.1
....................    delay_cycles(1); 
0250:  NOP
....................    lcd_output_rw(0); 
0251:  BCF    03.5
0252:  BCF    08.2
0253:  BSF    03.5
0254:  BCF    08.2
....................    delay_cycles(1); 
0255:  NOP
....................    lcd_output_enable(0); 
0256:  BCF    03.5
0257:  BCF    08.3
0258:  BSF    03.5
0259:  BCF    08.3
....................    lcd_send_nibble(n >> 4); 
025A:  SWAPF  4F,W
025B:  MOVWF  50
025C:  MOVLW  0F
025D:  ANDWF  50,F
025E:  MOVF   50,W
025F:  MOVWF  51
0260:  BCF    03.5
0261:  CALL   19F
....................    lcd_send_nibble(n & 0xf); 
0262:  BSF    03.5
0263:  MOVF   4F,W
0264:  ANDLW  0F
0265:  MOVWF  50
0266:  MOVWF  51
0267:  BCF    03.5
0268:  CALL   19F
0269:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
026A:  BSF    03.5
026B:  BCF    08.4
....................    output_drive(LCD_DATA5); 
026C:  BCF    08.5
....................    output_drive(LCD_DATA6); 
026D:  BCF    08.6
....................    output_drive(LCD_DATA7); 
026E:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
026F:  BCF    08.3
....................    lcd_rs_tris(); 
0270:  BCF    08.1
....................    lcd_rw_tris(); 
0271:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0272:  BCF    03.5
0273:  BCF    08.1
0274:  BSF    03.5
0275:  BCF    08.1
....................    lcd_output_rw(0); 
0276:  BCF    03.5
0277:  BCF    08.2
0278:  BSF    03.5
0279:  BCF    08.2
....................    lcd_output_enable(0); 
027A:  BCF    03.5
027B:  BCF    08.3
027C:  BSF    03.5
027D:  BCF    08.3
....................      
....................    delay_ms(15); 
027E:  MOVLW  0F
027F:  MOVWF  4A
0280:  BCF    03.5
0281:  CALL   18B
....................    for(i=1;i<=3;++i) 
0282:  MOVLW  01
0283:  BSF    03.5
0284:  MOVWF  41
0285:  MOVF   41,W
0286:  SUBLW  03
0287:  BTFSS  03.0
0288:  GOTO   295
....................    { 
....................        lcd_send_nibble(3); 
0289:  MOVLW  03
028A:  MOVWF  51
028B:  BCF    03.5
028C:  CALL   19F
....................        delay_ms(5); 
028D:  MOVLW  05
028E:  BSF    03.5
028F:  MOVWF  4A
0290:  BCF    03.5
0291:  CALL   18B
0292:  BSF    03.5
0293:  INCF   41,F
0294:  GOTO   285
....................    } 
....................     
....................    lcd_send_nibble(2); 
0295:  MOVLW  02
0296:  MOVWF  51
0297:  BCF    03.5
0298:  CALL   19F
....................    delay_ms(5); 
0299:  MOVLW  05
029A:  BSF    03.5
029B:  MOVWF  4A
029C:  BCF    03.5
029D:  CALL   18B
....................    for(i=0;i<=3;++i) 
029E:  BSF    03.5
029F:  CLRF   41
02A0:  MOVF   41,W
02A1:  SUBLW  03
02A2:  BTFSS  03.0
02A3:  GOTO   2B1
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02A4:  MOVF   41,W
02A5:  BCF    03.5
02A6:  CALL   041
02A7:  BSF    03.5
02A8:  MOVWF  42
02A9:  CLRF   4E
02AA:  MOVF   42,W
02AB:  MOVWF  4F
02AC:  BCF    03.5
02AD:  CALL   208
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02AE:  BSF    03.5
02AF:  INCF   41,F
02B0:  GOTO   2A0
02B1:  BCF    03.5
02B2:  RETURN
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0348:  BSF    03.5
0349:  DECFSZ 4B,W
034A:  GOTO   34C
034B:  GOTO   34F
....................       address=LCD_LINE_TWO; 
034C:  MOVLW  40
034D:  MOVWF  4C
034E:  GOTO   350
....................    else 
....................       address=0; 
034F:  CLRF   4C
....................       
....................    address+=x-1; 
0350:  MOVLW  01
0351:  SUBWF  4A,W
0352:  ADDWF  4C,F
....................    lcd_send_byte(0,0x80|address); 
0353:  MOVF   4C,W
0354:  IORLW  80
0355:  MOVWF  4D
0356:  CLRF   4E
0357:  MOVF   4D,W
0358:  MOVWF  4F
0359:  BCF    03.5
035A:  CALL   208
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
035B:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
035C:  BSF    03.5
035D:  MOVF   49,W
035E:  XORLW  07
035F:  BCF    03.5
0360:  BTFSC  03.2
0361:  GOTO   36C
0362:  XORLW  0B
0363:  BTFSC  03.2
0364:  GOTO   373
0365:  XORLW  06
0366:  BTFSC  03.2
0367:  GOTO   37F
0368:  XORLW  02
0369:  BTFSC  03.2
036A:  GOTO   387
036B:  GOTO   38E
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
036C:  MOVLW  01
036D:  BSF    03.5
036E:  MOVWF  4A
036F:  MOVWF  4B
0370:  BCF    03.5
0371:  CALL   348
0372:  GOTO   395
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0373:  BSF    03.5
0374:  CLRF   4E
0375:  MOVLW  01
0376:  MOVWF  4F
0377:  BCF    03.5
0378:  CALL   208
....................                      delay_ms(2); 
0379:  MOVLW  02
037A:  BSF    03.5
037B:  MOVWF  4A
037C:  BCF    03.5
037D:  CALL   18B
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
037E:  GOTO   395
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
037F:  MOVLW  01
0380:  BSF    03.5
0381:  MOVWF  4A
0382:  MOVLW  02
0383:  MOVWF  4B
0384:  BCF    03.5
0385:  CALL   348
0386:  GOTO   395
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0387:  BSF    03.5
0388:  CLRF   4E
0389:  MOVLW  10
038A:  MOVWF  4F
038B:  BCF    03.5
038C:  CALL   208
038D:  GOTO   395
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
038E:  MOVLW  01
038F:  BSF    03.5
0390:  MOVWF  4E
0391:  MOVF   49,W
0392:  MOVWF  4F
0393:  BCF    03.5
0394:  CALL   208
....................      #endif 
....................    } 
0395:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define LED_PIN PIN_A0 
.................... #define BUZZER_PIN PIN_A1 
....................  
.................... #define BTN_SIGNAL PIN_B0 
.................... #define BTN_UPLOAD PIN_B1 
.................... #define BTN_DELETE PIN_B2 
.................... #define BTN_RESET PIN_B3 
.................... #define BTN_MODE PIN_B4 
....................  
.................... char morse_buffer[10]; 
.................... char text_buffer[21]; 
.................... int8 morse_index = 0; 
.................... int8 text_index = 0; 
....................  
.................... char rx_temp_buffer[40]; 
.................... char rx_display_buffer[25]; 
.................... int8 rx_temp_index = 0; 
.................... int1 rx_data_ready = 0; 
....................  
.................... volatile int16 press_counter = 0; 
.................... volatile int16 idle_counter = 0; 
.................... #define SLEEP_TIMEOUT 3000 
....................  
.................... int1 btn_prev_state = 0; 
.................... int1 update_needed = 0; 
....................  
.................... volatile int8 scroll_tick = 0; 
.................... int1 scroll_now = 0; 
.................... int8 scroll_pos = 0; 
....................  
.................... int1 app_mode = 0; 
....................  
.................... const char morse_tree[64] = { 
....................     0, 0, 'E', 'T', 'I', 'A', 'N', 'M', 'S', 'U', 'R', 'W', 'D', 'K', 'G', 'O', 
....................     'H', 'V', 'F', 0, 'L', 0, 'P', 'J', 'B', 'X', 'C', 'Y', 'Z', 'Q', 0, 0, 
....................     '5', '4', 0, '3', 0, 0, 0, '2', 0, 0, 0, 0, 0, 0, 0, '1', 
....................     '6', 0, 0, 0, 0, 0, 0, 0, '7', 0, 0, 0, '8', 0, '9', '0'}; 
....................  
.................... void wdt_delay_ms(int16 time) 
.................... { 
....................     int16 i; 
....................     for (i = 0; i < time; i++) 
*
06C8:  BSF    03.5
06C9:  CLRF   44
06CA:  CLRF   43
06CB:  MOVF   44,W
06CC:  SUBWF  42,W
06CD:  BTFSS  03.0
06CE:  GOTO   6DF
06CF:  BTFSS  03.2
06D0:  GOTO   6D5
06D1:  MOVF   41,W
06D2:  SUBWF  43,W
06D3:  BTFSC  03.0
06D4:  GOTO   6DF
....................     { 
....................         delay_ms(1); 
06D5:  MOVLW  01
06D6:  MOVWF  4A
06D7:  BCF    03.5
06D8:  CALL   18B
....................         restart_wdt(); 
06D9:  CLRWDT
06DA:  BSF    03.5
06DB:  INCF   43,F
06DC:  BTFSC  03.2
06DD:  INCF   44,F
06DE:  GOTO   6CB
....................     } 
06DF:  BCF    03.5
06E0:  RETURN
.................... } 
....................  
.................... void save_text_to_eeprom() 
.................... { 
....................     int8 i; 
....................     write_eeprom(0, text_index); 
*
0800:  MOVF   0B,W
0801:  MOVWF  77
0802:  BCF    0B.7
0803:  BSF    03.6
0804:  CLRF   0D
0805:  BCF    03.6
0806:  MOVF   4D,W
0807:  BSF    03.6
0808:  MOVWF  0C
0809:  BSF    03.5
080A:  BCF    0C.7
080B:  BSF    0C.2
080C:  MOVLW  55
080D:  MOVWF  0D
080E:  MOVLW  AA
080F:  MOVWF  0D
0810:  BSF    0C.1
0811:  BTFSC  0C.1
0812:  GOTO   011
0813:  BCF    0C.2
0814:  MOVF   77,W
0815:  BCF    03.5
0816:  BCF    03.6
0817:  IORWF  0B,F
....................     for (i = 0; i < text_index; i++) 
0818:  BSF    03.5
0819:  CLRF   41
081A:  BCF    03.5
081B:  MOVF   4D,W
081C:  BSF    03.5
081D:  SUBWF  41,W
081E:  BTFSC  03.0
081F:  GOTO   04B
....................     { 
....................         write_eeprom(i + 1, text_buffer[i]); 
0820:  MOVLW  01
0821:  ADDWF  41,W
0822:  MOVWF  42
0823:  MOVLW  37
0824:  ADDWF  41,W
0825:  MOVWF  04
0826:  BCF    03.7
0827:  MOVF   00,W
0828:  MOVWF  43
0829:  BCF    03.5
082A:  MOVF   0B,W
082B:  MOVWF  77
082C:  BCF    0B.7
082D:  BSF    03.5
082E:  MOVF   42,W
082F:  BCF    03.5
0830:  BSF    03.6
0831:  MOVWF  0D
0832:  BSF    03.5
0833:  BCF    03.6
0834:  MOVF   43,W
0835:  BCF    03.5
0836:  BSF    03.6
0837:  MOVWF  0C
0838:  BSF    03.5
0839:  BCF    0C.7
083A:  BSF    0C.2
083B:  MOVLW  55
083C:  MOVWF  0D
083D:  MOVLW  AA
083E:  MOVWF  0D
083F:  BSF    0C.1
0840:  BTFSC  0C.1
0841:  GOTO   040
0842:  BCF    0C.2
0843:  MOVF   77,W
0844:  BCF    03.5
0845:  BCF    03.6
0846:  IORWF  0B,F
....................         restart_wdt(); 
0847:  CLRWDT
0848:  BSF    03.5
0849:  INCF   41,F
084A:  GOTO   01A
....................     } 
084B:  BCF    03.5
084C:  RETURN
.................... } 
....................  
.................... void load_text_from_eeprom() 
.................... { 
....................     int8 i; 
....................     text_index = read_eeprom(0); 
*
02B3:  BSF    03.6
02B4:  CLRF   0D
02B5:  BSF    03.5
02B6:  BCF    0C.7
02B7:  BSF    0C.0
02B8:  BCF    03.5
02B9:  MOVF   0C,W
02BA:  BCF    03.6
02BB:  MOVWF  4D
....................     if (text_index > 20) 
02BC:  MOVF   4D,W
02BD:  SUBLW  14
02BE:  BTFSS  03.0
....................         text_index = 0; 
02BF:  CLRF   4D
....................     for (i = 0; i < text_index; i++) 
02C0:  BSF    03.5
02C1:  CLRF   41
02C2:  BCF    03.5
02C3:  MOVF   4D,W
02C4:  BSF    03.5
02C5:  SUBWF  41,W
02C6:  BTFSC  03.0
02C7:  GOTO   2DE
....................     { 
....................         text_buffer[i] = read_eeprom(i + 1); 
02C8:  MOVLW  37
02C9:  ADDWF  41,W
02CA:  MOVWF  04
02CB:  BCF    03.7
02CC:  MOVLW  01
02CD:  ADDWF  41,W
02CE:  MOVWF  44
02CF:  MOVF   44,W
02D0:  BCF    03.5
02D1:  BSF    03.6
02D2:  MOVWF  0D
02D3:  BSF    03.5
02D4:  BCF    0C.7
02D5:  BSF    0C.0
02D6:  BCF    03.5
02D7:  MOVF   0C,W
02D8:  MOVWF  00
....................         restart_wdt(); 
02D9:  CLRWDT
02DA:  BSF    03.5
02DB:  BCF    03.6
02DC:  INCF   41,F
02DD:  GOTO   2C2
....................     } 
....................     text_buffer[text_index] = '\0'; 
02DE:  MOVLW  37
02DF:  BCF    03.5
02E0:  ADDWF  4D,W
02E1:  MOVWF  04
02E2:  BCF    03.7
02E3:  CLRF   00
02E4:  BSF    0A.3
02E5:  BCF    0A.4
02E6:  GOTO   10A (RETURN)
.................... } 
....................  
.................... void save_bt_to_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = strlen(rx_display_buffer); 
*
066E:  BSF    03.5
066F:  CLRF   4A
0670:  MOVLW  A0
0671:  MOVWF  49
0672:  BCF    03.5
0673:  CALL   419
0674:  MOVF   78,W
0675:  BSF    03.5
0676:  MOVWF  42
....................     write_eeprom(50, len); 
0677:  BCF    03.5
0678:  MOVF   0B,W
0679:  MOVWF  77
067A:  BCF    0B.7
067B:  MOVLW  32
067C:  BSF    03.6
067D:  MOVWF  0D
067E:  BSF    03.5
067F:  BCF    03.6
0680:  MOVF   42,W
0681:  BCF    03.5
0682:  BSF    03.6
0683:  MOVWF  0C
0684:  BSF    03.5
0685:  BCF    0C.7
0686:  BSF    0C.2
0687:  MOVLW  55
0688:  MOVWF  0D
0689:  MOVLW  AA
068A:  MOVWF  0D
068B:  BSF    0C.1
068C:  BTFSC  0C.1
068D:  GOTO   68C
068E:  BCF    0C.2
068F:  MOVF   77,W
0690:  BCF    03.5
0691:  BCF    03.6
0692:  IORWF  0B,F
....................     for (i = 0; i < len; i++) 
0693:  BSF    03.5
0694:  CLRF   41
0695:  MOVF   42,W
0696:  SUBWF  41,W
0697:  BTFSC  03.0
0698:  GOTO   6C4
....................     { 
....................         write_eeprom(51 + i, rx_display_buffer[i]); 
0699:  MOVLW  33
069A:  ADDWF  41,W
069B:  MOVWF  43
069C:  MOVLW  A0
069D:  ADDWF  41,W
069E:  MOVWF  04
069F:  BCF    03.7
06A0:  MOVF   00,W
06A1:  MOVWF  44
06A2:  BCF    03.5
06A3:  MOVF   0B,W
06A4:  MOVWF  77
06A5:  BCF    0B.7
06A6:  BSF    03.5
06A7:  MOVF   43,W
06A8:  BCF    03.5
06A9:  BSF    03.6
06AA:  MOVWF  0D
06AB:  BSF    03.5
06AC:  BCF    03.6
06AD:  MOVF   44,W
06AE:  BCF    03.5
06AF:  BSF    03.6
06B0:  MOVWF  0C
06B1:  BSF    03.5
06B2:  BCF    0C.7
06B3:  BSF    0C.2
06B4:  MOVLW  55
06B5:  MOVWF  0D
06B6:  MOVLW  AA
06B7:  MOVWF  0D
06B8:  BSF    0C.1
06B9:  BTFSC  0C.1
06BA:  GOTO   6B9
06BB:  BCF    0C.2
06BC:  MOVF   77,W
06BD:  BCF    03.5
06BE:  BCF    03.6
06BF:  IORWF  0B,F
....................         restart_wdt(); 
06C0:  CLRWDT
06C1:  BSF    03.5
06C2:  INCF   41,F
06C3:  GOTO   695
....................     } 
06C4:  BCF    03.5
06C5:  BSF    0A.3
06C6:  BCF    0A.4
06C7:  GOTO   173 (RETURN)
.................... } 
....................  
.................... void load_bt_from_eeprom() 
.................... { 
....................     int8 i, len; 
....................     len = read_eeprom(50); 
*
02E7:  MOVLW  32
02E8:  BSF    03.6
02E9:  MOVWF  0D
02EA:  BSF    03.5
02EB:  BCF    0C.7
02EC:  BSF    0C.0
02ED:  BCF    03.5
02EE:  MOVF   0C,W
02EF:  BSF    03.5
02F0:  BCF    03.6
02F1:  MOVWF  42
....................     if (len > 20) 
02F2:  MOVF   42,W
02F3:  SUBLW  14
02F4:  BTFSS  03.0
....................         len = 0; 
02F5:  CLRF   42
....................  
....................     for (i = 0; i < len; i++) 
02F6:  CLRF   41
02F7:  MOVF   42,W
02F8:  SUBWF  41,W
02F9:  BTFSC  03.0
02FA:  GOTO   311
....................     { 
....................         rx_display_buffer[i] = read_eeprom(51 + i); 
02FB:  MOVLW  A0
02FC:  ADDWF  41,W
02FD:  MOVWF  04
02FE:  BCF    03.7
02FF:  MOVLW  33
0300:  ADDWF  41,W
0301:  MOVWF  45
0302:  MOVF   45,W
0303:  BCF    03.5
0304:  BSF    03.6
0305:  MOVWF  0D
0306:  BSF    03.5
0307:  BCF    0C.7
0308:  BSF    0C.0
0309:  BCF    03.5
030A:  MOVF   0C,W
030B:  MOVWF  00
....................         restart_wdt(); 
030C:  CLRWDT
030D:  BSF    03.5
030E:  BCF    03.6
030F:  INCF   41,F
0310:  GOTO   2F7
....................     } 
....................     rx_display_buffer[len] = '\0'; 
0311:  MOVLW  A0
0312:  ADDWF  42,W
0313:  MOVWF  04
0314:  BCF    03.7
0315:  CLRF   00
0316:  BCF    03.5
0317:  BSF    0A.3
0318:  BCF    0A.4
0319:  GOTO   10D (RETURN)
.................... } 
....................  
.................... char decode_morse(char *code) 
*
0439:  MOVLW  01
043A:  BSF    03.5
043B:  MOVWF  48
.................... { 
....................     int8 i, len; 
....................     int8 index = 1; 
....................     len = strlen(code); 
043C:  MOVF   45,W
043D:  MOVWF  4A
043E:  MOVF   44,W
043F:  MOVWF  49
0440:  BCF    03.5
0441:  CALL   419
0442:  MOVF   78,W
0443:  BSF    03.5
0444:  MOVWF  47
....................     if (len == 0) 
0445:  MOVF   47,F
0446:  BTFSS  03.2
0447:  GOTO   44B
....................         return ' '; 
0448:  MOVLW  20
0449:  MOVWF  78
044A:  GOTO   477
....................  
....................     for (i = 0; i < len; i++) 
044B:  CLRF   46
044C:  MOVF   47,W
044D:  SUBWF  46,W
044E:  BTFSC  03.0
044F:  GOTO   465
....................     { 
....................         index = index << 1; 
0450:  BCF    03.0
0451:  RLF    48,F
....................         if (code[i] == '-') 
0452:  MOVF   46,W
0453:  ADDWF  44,W
0454:  MOVWF  04
0455:  BCF    03.7
0456:  BTFSC  45.0
0457:  BSF    03.7
0458:  MOVF   00,W
0459:  SUBLW  2D
045A:  BTFSC  03.2
....................             index |= 1; 
045B:  BSF    48.0
....................         if (index >= 64) 
045C:  MOVF   48,W
045D:  SUBLW  3F
045E:  BTFSC  03.0
045F:  GOTO   463
....................             return '?'; 
0460:  MOVLW  3F
0461:  MOVWF  78
0462:  GOTO   477
0463:  INCF   46,F
0464:  GOTO   44C
....................     } 
....................     if (morse_tree[index] == 0) 
0465:  MOVF   48,W
0466:  BCF    03.5
0467:  CALL   049
0468:  XORLW  00
0469:  BTFSS  03.2
046A:  GOTO   470
....................         return '?'; 
046B:  MOVLW  3F
046C:  MOVWF  78
046D:  BSF    03.5
046E:  GOTO   477
046F:  BCF    03.5
....................     return morse_tree[index]; 
0470:  BSF    03.5
0471:  MOVF   48,W
0472:  BCF    03.5
0473:  CALL   049
0474:  MOVWF  78
0475:  MOVWF  78
0476:  BSF    03.5
0477:  BCF    03.5
0478:  RETURN
.................... } 
....................  
.................... void lcd_locate(int8 x, int8 y) 
.................... { 
....................     int8 address; 
....................     switch (y) 
*
031A:  BSF    03.5
031B:  MOVF   46,W
031C:  XORLW  01
031D:  BCF    03.5
031E:  BTFSC  03.2
031F:  GOTO   32A
0320:  XORLW  03
0321:  BTFSC  03.2
0322:  GOTO   32D
0323:  XORLW  01
0324:  BTFSC  03.2
0325:  GOTO   331
0326:  XORLW  07
0327:  BTFSC  03.2
0328:  GOTO   335
0329:  GOTO   33A
....................     { 
....................     case 1: 
....................         address = 0x00; 
032A:  BSF    03.5
032B:  CLRF   47
....................         break; 
032C:  GOTO   33C
....................     case 2: 
....................         address = 0x40; 
032D:  MOVLW  40
032E:  BSF    03.5
032F:  MOVWF  47
....................         break; 
0330:  GOTO   33C
....................     case 3: 
....................         address = 0x14; 
0331:  MOVLW  14
0332:  BSF    03.5
0333:  MOVWF  47
....................         break; 
0334:  GOTO   33C
....................     case 4: 
....................         address = 0x54; 
0335:  MOVLW  54
0336:  BSF    03.5
0337:  MOVWF  47
....................         break; 
0338:  GOTO   33C
0339:  BCF    03.5
....................     default: 
....................         address = 0x00; 
033A:  BSF    03.5
033B:  CLRF   47
....................         break; 
....................     } 
....................     address += x - 1; 
033C:  MOVLW  01
033D:  SUBWF  45,W
033E:  ADDWF  47,F
....................     lcd_send_byte(0, 0x80 | address); 
033F:  MOVF   47,W
0340:  IORLW  80
0341:  MOVWF  48
0342:  CLRF   4E
0343:  MOVF   48,W
0344:  MOVWF  4F
0345:  BCF    03.5
0346:  CALL   208
0347:  RETURN
.................... } 
....................  
.................... void update_scroll_line() 
*
050D:  MOVLW  04
050E:  BSF    03.5
050F:  MOVWF  44
.................... { 
....................     int8 len, i, current_char_idx; 
....................     int8 gap_size = 4; 
....................  
....................     if (rx_display_buffer[0] == '\0') 
0510:  MOVF   20,F
0511:  BTFSS  03.2
0512:  GOTO   522
....................     { 
....................         lcd_locate(1, 4); 
0513:  MOVLW  01
0514:  MOVWF  45
0515:  MOVLW  04
0516:  MOVWF  46
0517:  BCF    03.5
0518:  CALL   31A
....................         printf(lcd_putc, "                    "); 
0519:  MOVLW  9F
051A:  BSF    03.6
051B:  MOVWF  0D
051C:  MOVLW  00
051D:  MOVWF  0F
051E:  BCF    03.6
051F:  CALL   396
....................         return; 
0520:  GOTO   56D
0521:  BSF    03.5
....................     } 
....................  
....................     len = strlen(rx_display_buffer); 
0522:  CLRF   4A
0523:  MOVLW  A0
0524:  MOVWF  49
0525:  BCF    03.5
0526:  CALL   419
0527:  MOVF   78,W
0528:  BSF    03.5
0529:  MOVWF  41
....................     lcd_locate(1, 4); 
052A:  MOVLW  01
052B:  MOVWF  45
052C:  MOVLW  04
052D:  MOVWF  46
052E:  BCF    03.5
052F:  CALL   31A
....................  
....................     for (i = 0; i < 20; i++) 
0530:  BSF    03.5
0531:  CLRF   42
0532:  MOVF   42,W
0533:  SUBLW  13
0534:  BTFSS  03.0
0535:  GOTO   56C
....................     { 
....................         current_char_idx = (scroll_pos + i) % (len + gap_size); 
0536:  MOVF   42,W
0537:  ADDWF  3B,W
0538:  MOVWF  45
0539:  MOVF   44,W
053A:  ADDWF  41,W
053B:  MOVWF  46
053C:  MOVF   45,W
053D:  MOVWF  47
053E:  MOVF   46,W
053F:  MOVWF  48
*
0554:  MOVF   77,W
0555:  MOVWF  43
....................         if (current_char_idx < len) 
0556:  MOVF   41,W
0557:  SUBWF  43,W
0558:  BTFSC  03.0
0559:  GOTO   565
....................             lcd_putc(rx_display_buffer[current_char_idx]); 
055A:  MOVLW  A0
055B:  ADDWF  43,W
055C:  MOVWF  04
055D:  BCF    03.7
055E:  MOVF   00,W
055F:  MOVWF  45
0560:  MOVWF  49
0561:  BCF    03.5
0562:  CALL   35C
0563:  GOTO   569
0564:  BSF    03.5
....................         else 
....................             lcd_putc(' '); 
0565:  MOVLW  20
0566:  MOVWF  49
0567:  BCF    03.5
0568:  CALL   35C
0569:  BSF    03.5
056A:  INCF   42,F
056B:  GOTO   532
056C:  BCF    03.5
....................     } 
056D:  BSF    0A.3
056E:  BCF    0A.4
056F:  GOTO   169 (RETURN)
.................... } 
....................  
.................... void update_lcd() 
.................... { 
....................     int8 i, len; 
....................     char preview_char; 
....................  
....................     lcd_locate(1, 1); 
*
0479:  MOVLW  01
047A:  BSF    03.5
047B:  MOVWF  45
047C:  MOVWF  46
047D:  BCF    03.5
047E:  CALL   31A
....................     if (app_mode == 0) 
047F:  BTFSC  7B.4
0480:  GOTO   489
....................         printf(lcd_putc, "MOD: MESAJ          "); 
0481:  MOVLW  AA
0482:  BSF    03.6
0483:  MOVWF  0D
0484:  MOVLW  00
0485:  MOVWF  0F
0486:  BCF    03.6
0487:  CALL   396
0488:  GOTO   490
....................     else 
....................         printf(lcd_putc, "MOD: KOMUT          "); 
0489:  MOVLW  B5
048A:  BSF    03.6
048B:  MOVWF  0D
048C:  MOVLW  00
048D:  MOVWF  0F
048E:  BCF    03.6
048F:  CALL   396
....................  
....................     lcd_locate(1, 2); 
0490:  MOVLW  01
0491:  BSF    03.5
0492:  MOVWF  45
0493:  MOVLW  02
0494:  MOVWF  46
0495:  BCF    03.5
0496:  CALL   31A
....................     printf(lcd_putc, "%s", text_buffer); 
0497:  MOVLW  37
0498:  MOVWF  04
0499:  BCF    03.7
049A:  CALL   3FC
....................  
....................     if (morse_index > 0) 
049B:  MOVF   4C,F
049C:  BTFSC  03.2
049D:  GOTO   4B1
....................     { 
....................         preview_char = decode_morse(morse_buffer); 
049E:  BSF    03.5
049F:  CLRF   45
04A0:  MOVLW  2D
04A1:  MOVWF  44
04A2:  BCF    03.5
04A3:  CALL   439
04A4:  MOVF   78,W
04A5:  BSF    03.5
04A6:  MOVWF  43
....................         lcd_putc(preview_char); 
04A7:  MOVF   43,W
04A8:  MOVWF  49
04A9:  BCF    03.5
04AA:  CALL   35C
....................         lcd_putc('<'); 
04AB:  MOVLW  3C
04AC:  BSF    03.5
04AD:  MOVWF  49
04AE:  BCF    03.5
04AF:  CALL   35C
....................     } 
04B0:  GOTO   4B8
....................     else 
....................     { 
....................         lcd_putc("  "); 
04B1:  MOVLW  C0
04B2:  BSF    03.6
04B3:  MOVWF  0D
04B4:  MOVLW  00
04B5:  MOVWF  0F
04B6:  BCF    03.6
04B7:  CALL   396
....................     } 
....................  
....................     len = strlen(text_buffer) + (morse_index > 0 ? 2 : 0); 
04B8:  BSF    03.5
04B9:  CLRF   4A
04BA:  MOVLW  37
04BB:  MOVWF  49
04BC:  BCF    03.5
04BD:  CALL   419
04BE:  MOVF   78,W
04BF:  BSF    03.5
04C0:  MOVWF  44
04C1:  BCF    03.5
04C2:  MOVF   4C,F
04C3:  BTFSC  03.2
04C4:  GOTO   4C8
04C5:  CLRF   7A
04C6:  MOVLW  02
04C7:  GOTO   4CA
04C8:  CLRF   7A
04C9:  MOVLW  00
04CA:  BSF    03.5
04CB:  ADDWF  44,W
04CC:  MOVWF  42
....................     for (i = len; i < 20; i++) 
04CD:  MOVF   42,W
04CE:  MOVWF  41
04CF:  MOVF   41,W
04D0:  SUBLW  13
04D1:  BTFSS  03.0
04D2:  GOTO   4DA
....................         lcd_putc(' '); 
04D3:  MOVLW  20
04D4:  MOVWF  49
04D5:  BCF    03.5
04D6:  CALL   35C
04D7:  BSF    03.5
04D8:  INCF   41,F
04D9:  GOTO   4CF
....................  
....................     lcd_locate(1, 3); 
04DA:  MOVLW  01
04DB:  MOVWF  45
04DC:  MOVLW  03
04DD:  MOVWF  46
04DE:  BCF    03.5
04DF:  CALL   31A
....................     printf(lcd_putc, "%s", morse_buffer); 
04E0:  MOVLW  2D
04E1:  MOVWF  04
04E2:  BCF    03.7
04E3:  CALL   3FC
....................     len = strlen(morse_buffer); 
04E4:  BSF    03.5
04E5:  CLRF   4A
04E6:  MOVLW  2D
04E7:  MOVWF  49
04E8:  BCF    03.5
04E9:  CALL   419
04EA:  MOVF   78,W
04EB:  BSF    03.5
04EC:  MOVWF  42
....................     for (i = len; i < 20; i++) 
04ED:  MOVF   42,W
04EE:  MOVWF  41
04EF:  MOVF   41,W
04F0:  SUBLW  13
04F1:  BTFSS  03.0
04F2:  GOTO   4FA
....................         lcd_putc(' '); 
04F3:  MOVLW  20
04F4:  MOVWF  49
04F5:  BCF    03.5
04F6:  CALL   35C
04F7:  BSF    03.5
04F8:  INCF   41,F
04F9:  GOTO   4EF
....................  
....................     if (rx_display_buffer[0] == '\0') 
04FA:  MOVF   20,F
04FB:  BTFSS  03.2
04FC:  GOTO   50B
....................     { 
....................         lcd_locate(1, 4); 
04FD:  MOVLW  01
04FE:  MOVWF  45
04FF:  MOVLW  04
0500:  MOVWF  46
0501:  BCF    03.5
0502:  CALL   31A
....................         printf(lcd_putc, "                    "); 
0503:  MOVLW  C2
0504:  BSF    03.6
0505:  MOVWF  0D
0506:  MOVLW  00
0507:  MOVWF  0F
0508:  BCF    03.6
0509:  CALL   396
050A:  BSF    03.5
....................     } 
050B:  BCF    03.5
050C:  RETURN
.................... } 
....................  
.................... void send_nmea_packet() 
*
0749:  BSF    03.5
074A:  CLRF   42
.................... { 
....................     char type_char; 
....................     int8 checksum = 0; 
....................     int8 i, len; 
....................     char char_to_send; 
....................  
....................     if (app_mode == 0) 
074B:  BTFSC  7B.4
074C:  GOTO   750
....................         type_char = 'M'; 
074D:  MOVLW  4D
074E:  MOVWF  41
074F:  GOTO   752
....................     else 
....................         type_char = 'K'; 
0750:  MOVLW  4B
0751:  MOVWF  41
....................  
....................     fprintf(BT_MODUL, "$%c,", type_char); 
0752:  MOVLW  24
0753:  BCF    03.5
0754:  BTFSS  0C.4
0755:  GOTO   754
0756:  MOVWF  19
0757:  BSF    03.5
0758:  MOVF   41,W
0759:  BCF    03.5
075A:  BTFSS  0C.4
075B:  GOTO   75A
075C:  MOVWF  19
075D:  MOVLW  2C
075E:  BTFSS  0C.4
075F:  GOTO   75E
0760:  MOVWF  19
....................     checksum = type_char ^ ','; 
0761:  BSF    03.5
0762:  MOVF   41,W
0763:  XORLW  2C
0764:  MOVWF  42
....................  
....................     len = strlen(text_buffer); 
0765:  CLRF   4A
0766:  MOVLW  37
0767:  MOVWF  49
0768:  BCF    03.5
0769:  CALL   419
076A:  MOVF   78,W
076B:  BSF    03.5
076C:  MOVWF  44
....................     for (i = 0; i < len; i++) 
076D:  CLRF   43
076E:  MOVF   44,W
076F:  SUBWF  43,W
0770:  BTFSC  03.0
0771:  GOTO   78A
....................     { 
....................         char_to_send = text_buffer[i]; 
0772:  MOVLW  37
0773:  ADDWF  43,W
0774:  MOVWF  04
0775:  BCF    03.7
0776:  MOVF   00,W
0777:  MOVWF  45
....................         if (app_mode == 1 && char_to_send == ' ') 
0778:  BTFSS  7B.4
0779:  GOTO   780
077A:  MOVF   45,W
077B:  SUBLW  20
077C:  BTFSS  03.2
077D:  GOTO   780
....................             char_to_send = ','; 
077E:  MOVLW  2C
077F:  MOVWF  45
....................         fputc(char_to_send, BT_MODUL); 
0780:  MOVF   45,W
0781:  BCF    03.5
0782:  BTFSS  0C.4
0783:  GOTO   782
0784:  MOVWF  19
....................         checksum ^= char_to_send; 
0785:  BSF    03.5
0786:  MOVF   45,W
0787:  XORWF  42,F
0788:  INCF   43,F
0789:  GOTO   76E
....................     } 
....................     fprintf(BT_MODUL, "*%02X\r\n", checksum); 
078A:  MOVLW  2A
078B:  BCF    03.5
078C:  BTFSS  0C.4
078D:  GOTO   78C
078E:  MOVWF  19
078F:  BSF    03.5
0790:  MOVF   42,W
0791:  MOVWF  46
0792:  MOVLW  37
0793:  MOVWF  47
*
07B9:  MOVLW  0D
07BA:  BTFSS  0C.4
07BB:  GOTO   7BA
07BC:  MOVWF  19
07BD:  MOVLW  0A
07BE:  BTFSS  0C.4
07BF:  GOTO   7BE
07C0:  MOVWF  19
07C1:  BSF    0A.3
07C2:  BCF    0A.4
07C3:  GOTO   215 (RETURN)
.................... } 
....................  
.................... void process_incoming_nmea() 
.................... { 
....................     char *ptr_start; 
....................     char *ptr_end; 
....................     int8 len; 
....................  
....................     if (rx_temp_buffer[0] == '$') 
*
05E6:  MOVF   4E,W
05E7:  SUBLW  24
05E8:  BTFSS  03.2
05E9:  GOTO   659
....................     { 
....................         ptr_start = strchr(rx_temp_buffer, ','); 
05EA:  BSF    03.5
05EB:  CLRF   47
05EC:  MOVLW  4E
05ED:  MOVWF  46
05EE:  MOVLW  2C
05EF:  MOVWF  48
05F0:  BCF    03.5
05F1:  CALL   570
05F2:  MOVF   79,W
05F3:  BSF    03.5
05F4:  MOVWF  42
05F5:  MOVF   78,W
05F6:  MOVWF  41
....................         ptr_end = strchr(rx_temp_buffer, '*'); 
05F7:  CLRF   47
05F8:  MOVLW  4E
05F9:  MOVWF  46
05FA:  MOVLW  2A
05FB:  MOVWF  48
05FC:  BCF    03.5
05FD:  CALL   570
05FE:  MOVF   79,W
05FF:  BSF    03.5
0600:  MOVWF  44
0601:  MOVF   78,W
0602:  MOVWF  43
....................  
....................         if (ptr_start != 0 && ptr_end != 0 && ptr_end > ptr_start) 
0603:  MOVF   41,F
0604:  BTFSS  03.2
0605:  GOTO   609
0606:  MOVF   42,F
0607:  BTFSC  03.2
0608:  GOTO   645
0609:  MOVF   43,F
060A:  BTFSS  03.2
060B:  GOTO   60F
060C:  MOVF   44,F
060D:  BTFSC  03.2
060E:  GOTO   645
060F:  MOVF   42,W
0610:  SUBWF  44,W
0611:  BTFSS  03.0
0612:  GOTO   645
0613:  BTFSS  03.2
0614:  GOTO   619
0615:  MOVF   43,W
0616:  SUBWF  41,W
0617:  BTFSC  03.0
0618:  GOTO   645
....................         { 
....................             len = (int8)(ptr_end - ptr_start) - 1; 
0619:  MOVF   41,W
061A:  SUBWF  43,W
061B:  MOVWF  77
061C:  MOVF   44,W
061D:  MOVWF  7A
061E:  MOVF   42,W
061F:  BTFSS  03.0
0620:  INCFSZ 42,W
0621:  SUBWF  7A,F
0622:  MOVF   77,W
0623:  ADDLW  FF
0624:  MOVWF  45
....................             if (len > 20) 
0625:  MOVF   45,W
0626:  SUBLW  14
0627:  BTFSC  03.0
0628:  GOTO   62B
....................                 len = 20; 
0629:  MOVLW  14
062A:  MOVWF  45
....................  
....................             strncpy(rx_display_buffer, ptr_start + 1, len); 
062B:  MOVLW  01
062C:  ADDWF  41,W
062D:  MOVWF  46
062E:  MOVF   42,W
062F:  MOVWF  47
0630:  BTFSC  03.0
0631:  INCF   47,F
0632:  CLRF   49
0633:  MOVLW  A0
0634:  MOVWF  48
0635:  MOVF   47,W
0636:  MOVWF  4B
0637:  MOVF   46,W
0638:  MOVWF  4A
0639:  CLRF   4D
063A:  MOVF   45,W
063B:  MOVWF  4C
063C:  BCF    03.5
063D:  CALL   594
....................             rx_display_buffer[len] = '\0'; 
063E:  MOVLW  A0
063F:  BSF    03.5
0640:  ADDWF  45,W
0641:  MOVWF  04
0642:  BCF    03.7
0643:  CLRF   00
....................         } 
0644:  GOTO   657
....................         else 
....................         { 
....................             strcpy(rx_display_buffer, "FORMAT HATASI"); 
0645:  CLRF   46
0646:  CLRF   47
0647:  MOVLW  A0
0648:  MOVWF  04
0649:  BCF    03.7
064A:  MOVF   46,W
064B:  ADDWF  04,F
064C:  MOVF   47,W
064D:  BCF    03.5
064E:  CALL   08D
064F:  MOVWF  00
0650:  IORLW  00
0651:  BTFSC  03.2
0652:  GOTO   658
0653:  BSF    03.5
0654:  INCF   47,F
0655:  INCF   46,F
0656:  GOTO   647
0657:  BCF    03.5
....................         } 
....................     } 
0658:  GOTO   668
....................     else 
....................     { 
....................         strncpy(rx_display_buffer, rx_temp_buffer, 20); 
0659:  BSF    03.5
065A:  CLRF   49
065B:  MOVLW  A0
065C:  MOVWF  48
065D:  CLRF   4B
065E:  MOVLW  4E
065F:  MOVWF  4A
0660:  CLRF   4D
0661:  MOVLW  14
0662:  MOVWF  4C
0663:  BCF    03.5
0664:  CALL   594
....................         rx_display_buffer[20] = '\0'; 
0665:  BSF    03.5
0666:  CLRF   34
0667:  BCF    03.5
....................     } 
....................     scroll_pos = 0; 
0668:  BSF    03.5
0669:  CLRF   3B
066A:  BCF    03.5
066B:  BSF    0A.3
066C:  BCF    0A.4
066D:  GOTO   170 (RETURN)
.................... } 
....................  
.................... void enter_sleep_mode() 
.................... { 
....................     lcd_putc('\f'); 
*
06E1:  MOVLW  0C
06E2:  BSF    03.5
06E3:  MOVWF  49
06E4:  BCF    03.5
06E5:  CALL   35C
....................     lcd_locate(1, 1); 
06E6:  MOVLW  01
06E7:  BSF    03.5
06E8:  MOVWF  45
06E9:  MOVWF  46
06EA:  BCF    03.5
06EB:  CALL   31A
....................     printf(lcd_putc, "UYKU MODU..."); 
06EC:  MOVLW  CD
06ED:  BSF    03.6
06EE:  MOVWF  0D
06EF:  MOVLW  00
06F0:  MOVWF  0F
06F1:  BCF    03.6
06F2:  CALL   396
....................     wdt_delay_ms(500); 
06F3:  MOVLW  01
06F4:  BSF    03.5
06F5:  MOVWF  42
06F6:  MOVLW  F4
06F7:  MOVWF  41
06F8:  BCF    03.5
06F9:  CALL   6C8
....................     lcd_send_byte(0, 0x08); 
06FA:  BSF    03.5
06FB:  CLRF   4E
06FC:  MOVLW  08
06FD:  MOVWF  4F
06FE:  BCF    03.5
06FF:  CALL   208
....................  
....................     output_low(LED_PIN); 
0700:  BSF    03.5
0701:  BCF    05.0
0702:  BCF    03.5
0703:  BCF    05.0
....................     output_low(BUZZER_PIN); 
0704:  BSF    03.5
0705:  BCF    05.1
0706:  BCF    03.5
0707:  BCF    05.1
....................  
....................     while (TRUE) 
....................     { 
....................         restart_wdt(); 
0708:  CLRWDT
....................         sleep(); 
0709:  SLEEP
....................  
....................         if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_MODE)) 
070A:  BSF    03.5
070B:  BSF    06.0
070C:  BCF    03.5
070D:  BTFSS  06.0
070E:  GOTO   723
070F:  BSF    03.5
0710:  BSF    06.1
0711:  BCF    03.5
0712:  BTFSS  06.1
0713:  GOTO   723
0714:  BSF    03.5
0715:  BSF    06.2
0716:  BCF    03.5
0717:  BTFSS  06.2
0718:  GOTO   723
0719:  BSF    03.5
071A:  BSF    06.3
071B:  BCF    03.5
071C:  BTFSS  06.3
071D:  GOTO   723
071E:  BSF    03.5
071F:  BSF    06.4
0720:  BCF    03.5
0721:  BTFSC  06.4
0722:  GOTO   741
....................         { 
....................             delay_ms(20); 
0723:  MOVLW  14
0724:  BSF    03.5
0725:  MOVWF  4A
0726:  BCF    03.5
0727:  CALL   18B
....................             if (!input(BTN_SIGNAL) || !input(BTN_UPLOAD) || !input(BTN_DELETE) || !input(BTN_RESET) || !input(BTN_MODE)) 
0728:  BSF    03.5
0729:  BSF    06.0
072A:  BCF    03.5
072B:  BTFSS  06.0
072C:  GOTO   740
072D:  BSF    03.5
072E:  BSF    06.1
072F:  BCF    03.5
0730:  BTFSS  06.1
0731:  GOTO   740
0732:  BSF    03.5
0733:  BSF    06.2
0734:  BCF    03.5
0735:  BTFSS  06.2
0736:  GOTO   740
0737:  BSF    03.5
0738:  BSF    06.3
0739:  BCF    03.5
073A:  BTFSS  06.3
073B:  GOTO   740
073C:  BSF    03.5
073D:  BSF    06.4
073E:  BCF    03.5
073F:  BTFSS  06.4
....................             { 
....................                 break; 
0740:  GOTO   742
....................             } 
....................         } 
0741:  GOTO   708
....................     } 
....................  
....................     lcd_init(); 
0742:  CALL   26A
....................     update_lcd(); 
0743:  CALL   479
....................     idle_counter = 0; 
0744:  BSF    03.5
0745:  CLRF   3A
0746:  CLRF   39
0747:  BCF    03.5
0748:  RETURN
.................... } 
....................  
.................... void full_wipe_reset() 
.................... { 
....................     lcd_putc('\f'); 
*
084D:  MOVLW  0C
084E:  BSF    03.5
084F:  MOVWF  49
0850:  BCF    0A.3
0851:  BCF    03.5
0852:  CALL   35C
0853:  BSF    0A.3
....................     lcd_locate(1, 1); 
0854:  MOVLW  01
0855:  BSF    03.5
0856:  MOVWF  45
0857:  MOVWF  46
0858:  BCF    0A.3
0859:  BCF    03.5
085A:  CALL   31A
085B:  BSF    0A.3
....................     printf(lcd_putc, "HEPSI SILINIYOR"); 
085C:  MOVLW  D4
085D:  BSF    03.6
085E:  MOVWF  0D
085F:  MOVLW  00
0860:  MOVWF  0F
0861:  BCF    0A.3
0862:  BCF    03.6
0863:  CALL   396
0864:  BSF    0A.3
....................     output_high(BUZZER_PIN); 
0865:  BSF    03.5
0866:  BCF    05.1
0867:  BCF    03.5
0868:  BSF    05.1
....................     wdt_delay_ms(500); 
0869:  MOVLW  01
086A:  BSF    03.5
086B:  MOVWF  42
086C:  MOVLW  F4
086D:  MOVWF  41
086E:  BCF    0A.3
086F:  BCF    03.5
0870:  CALL   6C8
0871:  BSF    0A.3
....................     output_low(BUZZER_PIN); 
0872:  BSF    03.5
0873:  BCF    05.1
0874:  BCF    03.5
0875:  BCF    05.1
....................  
....................     write_eeprom(0, 0); 
0876:  MOVF   0B,W
0877:  MOVWF  77
0878:  BCF    0B.7
0879:  BSF    03.6
087A:  CLRF   0D
087B:  CLRF   0C
087C:  BSF    03.5
087D:  BCF    0C.7
087E:  BSF    0C.2
087F:  MOVLW  55
0880:  MOVWF  0D
0881:  MOVLW  AA
0882:  MOVWF  0D
0883:  BSF    0C.1
0884:  BTFSC  0C.1
0885:  GOTO   084
0886:  BCF    0C.2
0887:  MOVF   77,W
0888:  BCF    03.5
0889:  BCF    03.6
088A:  IORWF  0B,F
....................     write_eeprom(50, 0); 
088B:  MOVF   0B,W
088C:  MOVWF  77
088D:  BCF    0B.7
088E:  MOVLW  32
088F:  BSF    03.6
0890:  MOVWF  0D
0891:  CLRF   0C
0892:  BSF    03.5
0893:  BCF    0C.7
0894:  BSF    0C.2
0895:  MOVLW  55
0896:  MOVWF  0D
0897:  MOVLW  AA
0898:  MOVWF  0D
0899:  BSF    0C.1
089A:  BTFSC  0C.1
089B:  GOTO   09A
089C:  BCF    0C.2
089D:  MOVF   77,W
089E:  BCF    03.5
089F:  BCF    03.6
08A0:  IORWF  0B,F
....................  
....................     text_index = 0; 
08A1:  CLRF   4D
....................     text_buffer[0] = '\0'; 
08A2:  CLRF   37
....................  
....................     morse_index = 0; 
08A3:  CLRF   4C
....................     morse_buffer[0] = '\0'; 
08A4:  CLRF   2D
....................  
....................     rx_display_buffer[0] = '\0'; 
08A5:  BSF    03.5
08A6:  CLRF   20
....................     scroll_pos = 0; 
08A7:  CLRF   3B
....................  
....................     lcd_putc('\f'); 
08A8:  MOVLW  0C
08A9:  MOVWF  49
08AA:  BCF    0A.3
08AB:  BCF    03.5
08AC:  CALL   35C
08AD:  BSF    0A.3
....................     update_lcd(); 
08AE:  BCF    0A.3
08AF:  CALL   479
08B0:  BSF    0A.3
08B1:  BSF    0A.3
08B2:  BCF    0A.4
08B3:  GOTO   2F1 (RETURN)
.................... } 
....................  
.................... #INT_RDA 
.................... void serial_isr() 
.................... { 
....................     char incoming; 
....................     if (kbhit(BT_MODUL)) 
*
00DC:  BTFSS  0C.5
00DD:  GOTO   102
....................     { 
....................         incoming = fgetc(BT_MODUL); 
00DE:  BTFSS  0C.5
00DF:  GOTO   0DE
00E0:  MOVF   1A,W
00E1:  BSF    03.5
00E2:  MOVWF  54
....................  
....................         if (incoming == '$') 
00E3:  MOVF   54,W
00E4:  SUBLW  24
00E5:  BTFSC  03.2
....................         { 
....................             rx_temp_index = 0; 
00E6:  CLRF   76
....................         } 
....................  
....................         if (incoming == '\n' || incoming == '\r') 
00E7:  MOVF   54,W
00E8:  SUBLW  0A
00E9:  BTFSC  03.2
00EA:  GOTO   0EF
00EB:  MOVF   54,W
00EC:  SUBLW  0D
00ED:  BTFSS  03.2
00EE:  GOTO   0F6
....................         { 
....................             rx_temp_buffer[rx_temp_index] = '\0'; 
00EF:  MOVLW  4E
00F0:  ADDWF  76,W
00F1:  MOVWF  04
00F2:  BCF    03.7
00F3:  CLRF   00
....................             rx_data_ready = 1; 
00F4:  BSF    7B.0
....................         } 
00F5:  GOTO   101
....................         else 
....................         { 
....................             if (rx_temp_index < 38) 
00F6:  MOVF   76,W
00F7:  SUBLW  25
00F8:  BTFSS  03.0
00F9:  GOTO   101
....................                 rx_temp_buffer[rx_temp_index++] = incoming; 
00FA:  MOVF   76,W
00FB:  INCF   76,F
00FC:  ADDLW  4E
00FD:  MOVWF  04
00FE:  BCF    03.7
00FF:  MOVF   54,W
0100:  MOVWF  00
0101:  BCF    03.5
....................         } 
....................     } 
.................... } 
....................  
0102:  BCF    0C.5
0103:  BCF    0A.3
0104:  BCF    0A.4
0105:  GOTO   027
.................... #INT_TIMER1 
.................... void timer1_isr() 
.................... { 
....................     set_timer1(63036); 
0106:  CLRF   0E
0107:  MOVLW  F6
0108:  MOVWF  0F
0109:  MOVLW  3C
010A:  MOVWF  0E
....................     if (idle_counter < 32000) 
010B:  BSF    03.5
010C:  MOVF   3A,W
010D:  SUBLW  7C
010E:  BTFSS  03.0
010F:  GOTO   113
....................         idle_counter++; 
0110:  INCF   39,F
0111:  BTFSC  03.2
0112:  INCF   3A,F
....................  
....................     int1 btn_current = !input(BTN_SIGNAL); 
0113:  BSF    06.0
0114:  BCF    54.0
0115:  BCF    03.5
0116:  BTFSC  06.0
0117:  GOTO   11B
0118:  BSF    03.5
0119:  BSF    54.0
011A:  BCF    03.5
....................  
....................     if (btn_current) 
011B:  BSF    03.5
011C:  BTFSS  54.0
011D:  GOTO   12C
....................     { 
....................         idle_counter = 0; 
011E:  CLRF   3A
011F:  CLRF   39
....................         press_counter++; 
0120:  INCF   7C,F
0121:  BTFSC  03.2
0122:  INCF   7D,F
....................         output_high(LED_PIN); 
0123:  BCF    05.0
0124:  BCF    03.5
0125:  BSF    05.0
....................         output_high(BUZZER_PIN); 
0126:  BSF    03.5
0127:  BCF    05.1
0128:  BCF    03.5
0129:  BSF    05.1
....................     } 
012A:  GOTO   168
012B:  BSF    03.5
....................     else 
....................     { 
....................         output_low(LED_PIN); 
012C:  BCF    05.0
012D:  BCF    03.5
012E:  BCF    05.0
....................         output_low(BUZZER_PIN); 
012F:  BSF    03.5
0130:  BCF    05.1
0131:  BCF    03.5
0132:  BCF    05.1
....................         if (btn_prev_state == 1) 
0133:  BTFSS  7B.1
0134:  GOTO   168
....................         { 
....................             idle_counter = 0; 
0135:  BSF    03.5
0136:  CLRF   3A
0137:  CLRF   39
....................             if (press_counter > 2) 
0138:  MOVF   7D,F
0139:  BTFSS  03.2
013A:  GOTO   13F
013B:  MOVF   7C,W
013C:  SUBLW  02
013D:  BTFSC  03.0
013E:  GOTO   165
....................             { 
....................                 if (press_counter < 30) 
013F:  MOVF   7D,F
0140:  BTFSS  03.2
0141:  GOTO   150
0142:  MOVF   7C,W
0143:  SUBLW  1D
0144:  BTFSS  03.0
0145:  GOTO   150
....................                     morse_buffer[morse_index++] = '.'; 
0146:  BCF    03.5
0147:  MOVF   4C,W
0148:  INCF   4C,F
0149:  ADDLW  2D
014A:  MOVWF  04
014B:  BCF    03.7
014C:  MOVLW  2E
014D:  MOVWF  00
014E:  GOTO   158
014F:  BSF    03.5
....................                 else 
....................                     morse_buffer[morse_index++] = '-'; 
0150:  BCF    03.5
0151:  MOVF   4C,W
0152:  INCF   4C,F
0153:  ADDLW  2D
0154:  MOVWF  04
0155:  BCF    03.7
0156:  MOVLW  2D
0157:  MOVWF  00
....................  
....................                 if (morse_index > 9) 
0158:  MOVF   4C,W
0159:  SUBLW  09
015A:  BTFSC  03.0
015B:  GOTO   15E
....................                     morse_index = 9; 
015C:  MOVLW  09
015D:  MOVWF  4C
....................  
....................                 morse_buffer[morse_index] = '\0'; 
015E:  MOVLW  2D
015F:  ADDWF  4C,W
0160:  MOVWF  04
0161:  BCF    03.7
0162:  CLRF   00
....................                 update_needed = 1; 
0163:  BSF    7B.2
0164:  BSF    03.5
....................             } 
....................             press_counter = 0; 
0165:  CLRF   7D
0166:  CLRF   7C
0167:  BCF    03.5
....................         } 
....................     } 
....................     btn_prev_state = btn_current; 
0168:  BCF    7B.1
0169:  BSF    03.5
016A:  BTFSC  54.0
016B:  BSF    7B.1
.................... } 
....................  
016C:  BCF    03.5
016D:  BCF    0C.0
016E:  BCF    0A.3
016F:  BCF    0A.4
0170:  GOTO   027
.................... #INT_TIMER0 
.................... void timer0_isr() 
.................... { 
....................     scroll_tick++; 
0171:  INCF   7E,F
....................     if (scroll_tick > 60) 
0172:  MOVF   7E,W
0173:  SUBLW  3C
0174:  BTFSC  03.0
0175:  GOTO   178
....................     { 
....................         scroll_tick = 0; 
0176:  CLRF   7E
....................         scroll_now = 1; 
0177:  BSF    7B.3
....................     } 
0178:  BCF    0B.2
0179:  BCF    0A.3
017A:  BCF    0A.4
017B:  GOTO   027
.................... } 
....................  
.................... void main() 
*
08B4:  MOVLW  71
08B5:  BSF    03.5
08B6:  MOVWF  0F
08B7:  MOVF   0F,W
08B8:  BSF    03.6
08B9:  BCF    07.3
08BA:  MOVLW  0C
08BB:  BCF    03.6
08BC:  MOVWF  19
08BD:  MOVLW  A2
08BE:  MOVWF  18
08BF:  MOVLW  90
08C0:  BCF    03.5
08C1:  MOVWF  18
08C2:  CLRF   4C
08C3:  CLRF   4D
08C4:  CLRF   76
08C5:  BCF    7B.0
08C6:  CLRF   7D
08C7:  CLRF   7C
08C8:  BSF    03.5
08C9:  CLRF   3A
08CA:  CLRF   39
08CB:  BCF    7B.1
08CC:  BCF    7B.2
08CD:  CLRF   7E
08CE:  BCF    7B.3
08CF:  CLRF   3B
08D0:  BCF    7B.4
08D1:  BSF    03.6
08D2:  MOVF   09,W
08D3:  ANDLW  C0
08D4:  MOVWF  09
08D5:  BCF    03.6
08D6:  BCF    1F.4
08D7:  BCF    1F.5
08D8:  MOVLW  00
08D9:  BSF    03.6
08DA:  MOVWF  08
08DB:  BCF    03.5
08DC:  CLRF   07
08DD:  CLRF   08
08DE:  CLRF   09
08DF:  BCF    03.7
08E0:  MOVLW  1F
08E1:  ANDWF  03,F
.................... { 
....................     setup_wdt(WDT_OFF); 
*
08E5:  BSF    03.6
08E6:  BCF    05.0
....................  
....................     set_tris_b(0xFF); 
08E7:  MOVLW  FF
08E8:  BSF    03.5
08E9:  BCF    03.6
08EA:  MOVWF  06
....................     port_b_pullups(TRUE); 
08EB:  MOVLW  01
08EC:  MOVWF  15
08ED:  BCF    01.7
....................     output_drive(LED_PIN); 
08EE:  BCF    05.0
....................     output_drive(BUZZER_PIN); 
08EF:  BCF    05.1
....................  
....................     output_high(BUZZER_PIN); 
08F0:  BCF    05.1
08F1:  BCF    03.5
08F2:  BSF    05.1
....................     delay_ms(50); 
08F3:  MOVLW  32
08F4:  BSF    03.5
08F5:  MOVWF  4A
08F6:  BCF    0A.3
08F7:  BCF    03.5
08F8:  CALL   18B
08F9:  BSF    0A.3
....................     output_low(BUZZER_PIN); 
08FA:  BSF    03.5
08FB:  BCF    05.1
08FC:  BCF    03.5
08FD:  BCF    05.1
....................  
....................     lcd_init(); 
08FE:  BCF    0A.3
08FF:  CALL   26A
0900:  BSF    0A.3
....................     delay_ms(100); 
0901:  MOVLW  64
0902:  BSF    03.5
0903:  MOVWF  4A
0904:  BCF    0A.3
0905:  BCF    03.5
0906:  CALL   18B
0907:  BSF    0A.3
....................  
....................     load_text_from_eeprom(); 
0908:  BCF    0A.3
0909:  GOTO   2B3
090A:  BSF    0A.3
....................     load_bt_from_eeprom(); 
090B:  BCF    0A.3
090C:  GOTO   2E7
090D:  BSF    0A.3
....................  
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
090E:  MOVLW  35
090F:  MOVWF  10
....................     set_timer1(63036); 
0910:  CLRF   0E
0911:  MOVLW  F6
0912:  MOVWF  0F
0913:  MOVLW  3C
0914:  MOVWF  0E
....................     setup_timer_0(T0_INTERNAL | T0_DIV_256); 
0915:  BSF    03.5
0916:  MOVF   01,W
0917:  ANDLW  C0
0918:  IORLW  07
0919:  MOVWF  01
....................  
....................     enable_interrupts(INT_TIMER1); 
091A:  BSF    0C.0
....................     enable_interrupts(INT_TIMER0); 
091B:  BCF    03.5
091C:  BSF    0B.5
....................     enable_interrupts(INT_RDA); 
091D:  BSF    03.5
091E:  BSF    0C.5
....................     enable_interrupts(GLOBAL); 
091F:  MOVLW  C0
0920:  BCF    03.5
0921:  IORWF  0B,F
....................  
....................     lcd_locate(1, 1); 
0922:  MOVLW  01
0923:  BSF    03.5
0924:  MOVWF  45
0925:  MOVWF  46
0926:  BCF    0A.3
0927:  BCF    03.5
0928:  CALL   31A
0929:  BSF    0A.3
....................     printf(lcd_putc, "Mors Telgraf"); 
092A:  MOVLW  7C
092B:  BSF    03.6
092C:  MOVWF  0D
092D:  MOVLW  01
092E:  MOVWF  0F
092F:  BCF    0A.3
0930:  BCF    03.6
0931:  CALL   396
0932:  BSF    0A.3
....................     delay_ms(1000); 
0933:  MOVLW  04
0934:  BSF    03.5
0935:  MOVWF  41
0936:  MOVLW  FA
0937:  MOVWF  4A
0938:  BCF    0A.3
0939:  BCF    03.5
093A:  CALL   18B
093B:  BSF    0A.3
093C:  BSF    03.5
093D:  DECFSZ 41,F
093E:  GOTO   136
....................  
....................     lcd_putc('\f'); 
093F:  MOVLW  0C
0940:  MOVWF  49
0941:  BCF    0A.3
0942:  BCF    03.5
0943:  CALL   35C
0944:  BSF    0A.3
....................     update_lcd(); 
0945:  BCF    0A.3
0946:  CALL   479
0947:  BSF    0A.3
....................  
....................     setup_wdt(WDT_2304MS); 
0948:  MOVLW  09
0949:  BSF    03.6
094A:  MOVWF  05
094B:  MOVLW  0F
094C:  MOVWF  77
094D:  BCF    03.6
094E:  CLRF   01
094F:  MOVLW  81
0950:  MOVWF  04
0951:  BCF    03.7
0952:  MOVF   00,W
0953:  ANDLW  F0
0954:  IORLW  07
0955:  MOVWF  00
0956:  CLRWDT
0957:  MOVF   00,W
0958:  ANDLW  F7
0959:  BTFSC  77.3
095A:  ANDLW  F0
095B:  IORWF  77,W
095C:  MOVWF  00
....................  
....................     while (TRUE) 
....................     { 
....................         restart_wdt(); 
095D:  CLRWDT
....................  
....................         if (scroll_now) 
095E:  BTFSS  7B.3
095F:  GOTO   16A
....................         { 
....................             scroll_now = 0; 
0960:  BCF    7B.3
....................             if (rx_display_buffer[0] != '\0') 
0961:  BSF    03.5
0962:  MOVF   20,F
0963:  BTFSC  03.2
0964:  GOTO   16B
....................             { 
....................                 scroll_pos++; 
0965:  INCF   3B,F
....................                 update_scroll_line(); 
0966:  BCF    0A.3
0967:  BCF    03.5
0968:  GOTO   50D
0969:  BSF    0A.3
096A:  BSF    03.5
....................             } 
....................         } 
....................  
....................         if (rx_data_ready) 
096B:  BTFSS  7B.0
096C:  GOTO   17B
....................         { 
....................             process_incoming_nmea(); 
096D:  BCF    0A.3
096E:  BCF    03.5
096F:  GOTO   5E6
0970:  BSF    0A.3
....................             save_bt_to_eeprom(); 
0971:  BCF    0A.3
0972:  GOTO   66E
0973:  BSF    0A.3
....................             rx_data_ready = 0; 
0974:  BCF    7B.0
....................             update_lcd(); 
0975:  BCF    0A.3
0976:  CALL   479
0977:  BSF    0A.3
....................             idle_counter = 0; 
0978:  BSF    03.5
0979:  CLRF   3A
097A:  CLRF   39
....................         } 
....................  
....................         if (idle_counter > SLEEP_TIMEOUT) 
097B:  MOVF   3A,W
097C:  SUBLW  0A
097D:  BTFSC  03.0
097E:  GOTO   18B
097F:  XORLW  FF
0980:  BTFSS  03.2
0981:  GOTO   186
0982:  MOVF   39,W
0983:  SUBLW  B8
0984:  BTFSC  03.0
0985:  GOTO   18B
....................         { 
....................             enter_sleep_mode(); 
0986:  BCF    0A.3
0987:  BCF    03.5
0988:  CALL   6E1
0989:  BSF    0A.3
098A:  BSF    03.5
....................         } 
....................  
....................         if (update_needed) 
098B:  BTFSS  7B.2
098C:  GOTO   193
....................         { 
....................             update_lcd(); 
098D:  BCF    0A.3
098E:  BCF    03.5
098F:  CALL   479
0990:  BSF    0A.3
....................             update_needed = 0; 
0991:  BCF    7B.2
0992:  BSF    03.5
....................         } 
....................  
....................         if (!input(BTN_MODE) && !input(BTN_RESET)) 
0993:  BSF    06.4
0994:  BCF    03.5
0995:  BTFSC  06.4
0996:  GOTO   1BC
0997:  BSF    03.5
0998:  BSF    06.3
0999:  BCF    03.5
099A:  BTFSC  06.3
099B:  GOTO   1BC
....................         { 
....................             delay_ms(50); 
099C:  MOVLW  32
099D:  BSF    03.5
099E:  MOVWF  4A
099F:  BCF    0A.3
09A0:  BCF    03.5
09A1:  CALL   18B
09A2:  BSF    0A.3
....................             if (!input(BTN_MODE) && !input(BTN_RESET)) 
09A3:  BSF    03.5
09A4:  BSF    06.4
09A5:  BCF    03.5
09A6:  BTFSC  06.4
09A7:  GOTO   1BC
09A8:  BSF    03.5
09A9:  BSF    06.3
09AA:  BCF    03.5
09AB:  BTFSC  06.3
09AC:  GOTO   1BC
....................             { 
....................                 enter_sleep_mode(); 
09AD:  BCF    0A.3
09AE:  CALL   6E1
09AF:  BSF    0A.3
....................                 while (!input(BTN_MODE) || !input(BTN_RESET)) 
09B0:  BSF    03.5
09B1:  BSF    06.4
09B2:  BCF    03.5
09B3:  BTFSS  06.4
09B4:  GOTO   1BA
09B5:  BSF    03.5
09B6:  BSF    06.3
09B7:  BCF    03.5
09B8:  BTFSC  06.3
09B9:  GOTO   1BC
....................                     restart_wdt(); 
09BA:  CLRWDT
09BB:  GOTO   1B0
....................             } 
....................         } 
....................  
....................         if (!input(BTN_MODE) && input(BTN_RESET)) 
09BC:  BSF    03.5
09BD:  BSF    06.4
09BE:  BCF    03.5
09BF:  BTFSC  06.4
09C0:  GOTO   1E0
09C1:  BSF    03.5
09C2:  BSF    06.3
09C3:  BCF    03.5
09C4:  BTFSS  06.3
09C5:  GOTO   1E0
....................         { 
....................             idle_counter = 0; 
09C6:  BSF    03.5
09C7:  CLRF   3A
09C8:  CLRF   39
....................             delay_ms(50); 
09C9:  MOVLW  32
09CA:  MOVWF  4A
09CB:  BCF    0A.3
09CC:  BCF    03.5
09CD:  CALL   18B
09CE:  BSF    0A.3
....................             if (!input(BTN_MODE)) 
09CF:  BSF    03.5
09D0:  BSF    06.4
09D1:  BCF    03.5
09D2:  BTFSC  06.4
09D3:  GOTO   1E0
....................             { 
....................                 app_mode = !app_mode; 
09D4:  MOVLW  10
09D5:  XORWF  7B,F
....................                 update_lcd(); 
09D6:  BCF    0A.3
09D7:  CALL   479
09D8:  BSF    0A.3
....................                 while (!input(BTN_MODE)) 
09D9:  BSF    03.5
09DA:  BSF    06.4
09DB:  BCF    03.5
09DC:  BTFSC  06.4
09DD:  GOTO   1E0
....................                     restart_wdt(); 
09DE:  CLRWDT
09DF:  GOTO   1D9
....................             } 
....................         } 
....................  
....................         if (!input(BTN_UPLOAD)) 
09E0:  BSF    03.5
09E1:  BSF    06.1
09E2:  BCF    03.5
09E3:  BTFSC  06.1
09E4:  GOTO   296
....................         { 
....................             idle_counter = 0; 
09E5:  BSF    03.5
09E6:  CLRF   3A
09E7:  CLRF   39
....................             int16 hold_counter = 0; 
09E8:  CLRF   3D
09E9:  CLRF   3C
....................  
....................             while (!input(BTN_UPLOAD) && hold_counter < 50) 
09EA:  BSF    06.1
09EB:  BCF    03.5
09EC:  BTFSC  06.1
09ED:  GOTO   207
09EE:  BSF    03.5
09EF:  MOVF   3D,F
09F0:  BTFSC  03.2
09F1:  GOTO   1F4
09F2:  BCF    03.5
09F3:  GOTO   207
09F4:  MOVF   3C,W
09F5:  SUBLW  31
09F6:  BTFSC  03.0
09F7:  GOTO   1FA
09F8:  BCF    03.5
09F9:  GOTO   207
....................             { 
....................                 delay_ms(10); 
09FA:  MOVLW  0A
09FB:  MOVWF  4A
09FC:  BCF    0A.3
09FD:  BCF    03.5
09FE:  CALL   18B
09FF:  BSF    0A.3
....................                 restart_wdt(); 
0A00:  CLRWDT
....................                 hold_counter++; 
0A01:  BSF    03.5
0A02:  INCF   3C,F
0A03:  BTFSC  03.2
0A04:  INCF   3D,F
0A05:  GOTO   1EA
0A06:  BCF    03.5
....................             } 
....................  
....................             if (hold_counter >= 50) 
0A07:  BSF    03.5
0A08:  MOVF   3D,F
0A09:  BTFSS  03.2
0A0A:  GOTO   20F
0A0B:  MOVF   3C,W
0A0C:  SUBLW  31
0A0D:  BTFSC  03.0
0A0E:  GOTO   25F
....................             { 
....................                 if (text_index > 0) 
0A0F:  BCF    03.5
0A10:  MOVF   4D,F
0A11:  BTFSC  03.2
0A12:  GOTO   226
....................                 { 
....................                     send_nmea_packet(); 
0A13:  BCF    0A.3
0A14:  GOTO   749
0A15:  BSF    0A.3
....................                     output_high(BUZZER_PIN); 
0A16:  BSF    03.5
0A17:  BCF    05.1
0A18:  BCF    03.5
0A19:  BSF    05.1
....................                     wdt_delay_ms(100); 
0A1A:  BSF    03.5
0A1B:  CLRF   42
0A1C:  MOVLW  64
0A1D:  MOVWF  41
0A1E:  BCF    0A.3
0A1F:  BCF    03.5
0A20:  CALL   6C8
0A21:  BSF    0A.3
....................                     output_low(BUZZER_PIN); 
0A22:  BSF    03.5
0A23:  BCF    05.1
0A24:  BCF    03.5
0A25:  BCF    05.1
....................                 } 
....................                 while (!input(BTN_UPLOAD)) 
0A26:  BSF    03.5
0A27:  BSF    06.1
0A28:  BCF    03.5
0A29:  BTFSC  06.1
0A2A:  GOTO   22D
....................                     restart_wdt(); 
0A2B:  CLRWDT
0A2C:  GOTO   226
....................  
....................                 text_index = 0; 
0A2D:  CLRF   4D
....................                 text_buffer[0] = '\0'; 
0A2E:  CLRF   37
....................                 morse_index = 0; 
0A2F:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0A30:  CLRF   2D
....................                 save_text_to_eeprom(); 
0A31:  CALL   000
....................  
....................                 lcd_putc('\f'); 
0A32:  MOVLW  0C
0A33:  BSF    03.5
0A34:  MOVWF  49
0A35:  BCF    0A.3
0A36:  BCF    03.5
0A37:  CALL   35C
0A38:  BSF    0A.3
....................                 lcd_locate(1, 1); 
0A39:  MOVLW  01
0A3A:  BSF    03.5
0A3B:  MOVWF  45
0A3C:  MOVWF  46
0A3D:  BCF    0A.3
0A3E:  BCF    03.5
0A3F:  CALL   31A
0A40:  BSF    0A.3
....................                 printf(lcd_putc, "VERI GONDERILDI"); 
0A41:  MOVLW  83
0A42:  BSF    03.6
0A43:  MOVWF  0D
0A44:  MOVLW  01
0A45:  MOVWF  0F
0A46:  BCF    0A.3
0A47:  BCF    03.6
0A48:  CALL   396
0A49:  BSF    0A.3
....................                 wdt_delay_ms(1000); 
0A4A:  MOVLW  03
0A4B:  BSF    03.5
0A4C:  MOVWF  42
0A4D:  MOVLW  E8
0A4E:  MOVWF  41
0A4F:  BCF    0A.3
0A50:  BCF    03.5
0A51:  CALL   6C8
0A52:  BSF    0A.3
....................                 lcd_putc('\f'); 
0A53:  MOVLW  0C
0A54:  BSF    03.5
0A55:  MOVWF  49
0A56:  BCF    0A.3
0A57:  BCF    03.5
0A58:  CALL   35C
0A59:  BSF    0A.3
....................                 update_lcd(); 
0A5A:  BCF    0A.3
0A5B:  CALL   479
0A5C:  BSF    0A.3
....................             } 
0A5D:  GOTO   296
0A5E:  BSF    03.5
....................             else 
....................             { 
....................                 while (!input(BTN_UPLOAD)) 
0A5F:  BSF    06.1
0A60:  BCF    03.5
0A61:  BTFSC  06.1
0A62:  GOTO   267
....................                     restart_wdt(); 
0A63:  CLRWDT
0A64:  BSF    03.5
0A65:  GOTO   25F
0A66:  BCF    03.5
....................                 if (morse_index > 0) 
0A67:  MOVF   4C,F
0A68:  BTFSC  03.2
0A69:  GOTO   296
....................                 { 
....................                     char final_char = decode_morse(morse_buffer); 
0A6A:  BSF    03.5
0A6B:  CLRF   45
0A6C:  MOVLW  2D
0A6D:  MOVWF  44
0A6E:  BCF    0A.3
0A6F:  BCF    03.5
0A70:  CALL   439
0A71:  BSF    0A.3
0A72:  MOVF   78,W
0A73:  BSF    03.5
0A74:  MOVWF  3E
....................                     if (text_index < 20 && final_char != '?') 
0A75:  BCF    03.5
0A76:  MOVF   4D,W
0A77:  SUBLW  13
0A78:  BTFSS  03.0
0A79:  GOTO   291
0A7A:  BSF    03.5
0A7B:  MOVF   3E,W
0A7C:  SUBLW  3F
0A7D:  BTFSS  03.2
0A7E:  GOTO   281
0A7F:  BCF    03.5
0A80:  GOTO   291
....................                     { 
....................                         text_buffer[text_index++] = final_char; 
0A81:  BCF    03.5
0A82:  MOVF   4D,W
0A83:  INCF   4D,F
0A84:  ADDLW  37
0A85:  MOVWF  04
0A86:  BCF    03.7
0A87:  BSF    03.5
0A88:  MOVF   3E,W
0A89:  MOVWF  00
....................                         text_buffer[text_index] = '\0'; 
0A8A:  MOVLW  37
0A8B:  BCF    03.5
0A8C:  ADDWF  4D,W
0A8D:  MOVWF  04
0A8E:  BCF    03.7
0A8F:  CLRF   00
....................                         save_text_to_eeprom(); 
0A90:  CALL   000
....................                     } 
....................                     morse_index = 0; 
0A91:  CLRF   4C
....................                     morse_buffer[0] = '\0'; 
0A92:  CLRF   2D
....................                     update_lcd(); 
0A93:  BCF    0A.3
0A94:  CALL   479
0A95:  BSF    0A.3
....................                 } 
....................             } 
....................         } 
....................  
....................         if (!input(BTN_DELETE)) 
0A96:  BSF    03.5
0A97:  BSF    06.2
0A98:  BCF    03.5
0A99:  BTFSC  06.2
0A9A:  GOTO   2C9
....................         { 
....................             delay_ms(20); 
0A9B:  MOVLW  14
0A9C:  BSF    03.5
0A9D:  MOVWF  4A
0A9E:  BCF    0A.3
0A9F:  BCF    03.5
0AA0:  CALL   18B
0AA1:  BSF    0A.3
....................             if (!input(BTN_DELETE)) 
0AA2:  BSF    03.5
0AA3:  BSF    06.2
0AA4:  BCF    03.5
0AA5:  BTFSC  06.2
0AA6:  GOTO   2C9
....................             { 
....................                 idle_counter = 0; 
0AA7:  BSF    03.5
0AA8:  CLRF   3A
0AA9:  CLRF   39
....................                 if (morse_index > 0) 
0AAA:  BCF    03.5
0AAB:  MOVF   4C,F
0AAC:  BTFSC  03.2
0AAD:  GOTO   2B5
....................                     morse_buffer[--morse_index] = '\0'; 
0AAE:  DECF   4C,F
0AAF:  MOVLW  2D
0AB0:  ADDWF  4C,W
0AB1:  MOVWF  04
0AB2:  BCF    03.7
0AB3:  CLRF   00
0AB4:  GOTO   2BF
....................                 else if (text_index > 0) 
0AB5:  MOVF   4D,F
0AB6:  BTFSC  03.2
0AB7:  GOTO   2BF
....................                 { 
....................                     text_buffer[--text_index] = '\0'; 
0AB8:  DECF   4D,F
0AB9:  MOVLW  37
0ABA:  ADDWF  4D,W
0ABB:  MOVWF  04
0ABC:  BCF    03.7
0ABD:  CLRF   00
....................                     save_text_to_eeprom(); 
0ABE:  CALL   000
....................                 } 
....................                 update_lcd(); 
0ABF:  BCF    0A.3
0AC0:  CALL   479
0AC1:  BSF    0A.3
....................                 while (!input(BTN_DELETE)) 
0AC2:  BSF    03.5
0AC3:  BSF    06.2
0AC4:  BCF    03.5
0AC5:  BTFSC  06.2
0AC6:  GOTO   2C9
....................                     restart_wdt(); 
0AC7:  CLRWDT
0AC8:  GOTO   2C2
....................             } 
....................         } 
....................  
....................         if (!input(BTN_RESET) && input(BTN_MODE)) 
0AC9:  BSF    03.5
0ACA:  BSF    06.3
0ACB:  BCF    03.5
0ACC:  BTFSC  06.3
0ACD:  GOTO   31A
0ACE:  BSF    03.5
0ACF:  BSF    06.4
0AD0:  BCF    03.5
0AD1:  BTFSS  06.4
0AD2:  GOTO   31A
....................         { 
....................             idle_counter = 0; 
0AD3:  BSF    03.5
0AD4:  CLRF   3A
0AD5:  CLRF   39
....................             int16 reset_hold = 0; 
0AD6:  CLRF   40
0AD7:  CLRF   3F
....................  
....................             while (!input(BTN_RESET)) 
0AD8:  BSF    06.3
0AD9:  BCF    03.5
0ADA:  BTFSC  06.3
0ADB:  GOTO   2FC
....................             { 
....................                 delay_ms(10); 
0ADC:  MOVLW  0A
0ADD:  BSF    03.5
0ADE:  MOVWF  4A
0ADF:  BCF    0A.3
0AE0:  BCF    03.5
0AE1:  CALL   18B
0AE2:  BSF    0A.3
....................                 restart_wdt(); 
0AE3:  CLRWDT
....................                 reset_hold++; 
0AE4:  BSF    03.5
0AE5:  INCF   3F,F
0AE6:  BTFSC  03.2
0AE7:  INCF   40,F
....................  
....................                 if (reset_hold > 200) 
0AE8:  MOVF   40,F
0AE9:  BTFSS  03.2
0AEA:  GOTO   2EF
0AEB:  MOVF   3F,W
0AEC:  SUBLW  C8
0AED:  BTFSC  03.0
0AEE:  GOTO   2FA
....................                 { 
....................                     full_wipe_reset(); 
0AEF:  BCF    03.5
0AF0:  GOTO   04D
....................                     while (!input(BTN_RESET)) 
0AF1:  BSF    03.5
0AF2:  BSF    06.3
0AF3:  BCF    03.5
0AF4:  BTFSC  06.3
0AF5:  GOTO   2F8
....................                         restart_wdt(); 
0AF6:  CLRWDT
0AF7:  GOTO   2F1
....................                     break; 
0AF8:  GOTO   2FC
0AF9:  BSF    03.5
....................                 } 
0AFA:  GOTO   2D8
0AFB:  BCF    03.5
....................             } 
....................  
....................             if (reset_hold > 5 && reset_hold <= 200) 
0AFC:  BSF    03.5
0AFD:  MOVF   40,F
0AFE:  BTFSS  03.2
0AFF:  GOTO   304
0B00:  MOVF   3F,W
0B01:  SUBLW  05
0B02:  BTFSC  03.0
0B03:  GOTO   31B
0B04:  MOVF   40,F
0B05:  BTFSS  03.2
0B06:  GOTO   31B
0B07:  MOVF   3F,W
0B08:  SUBLW  C8
0B09:  BTFSS  03.0
0B0A:  GOTO   31B
....................             { 
....................                 text_index = 0; 
0B0B:  BCF    03.5
0B0C:  CLRF   4D
....................                 text_buffer[0] = '\0'; 
0B0D:  CLRF   37
....................                 morse_index = 0; 
0B0E:  CLRF   4C
....................                 morse_buffer[0] = '\0'; 
0B0F:  CLRF   2D
....................                 update_lcd(); 
0B10:  BCF    0A.3
0B11:  CALL   479
0B12:  BSF    0A.3
....................                 while (!input(BTN_RESET)) 
0B13:  BSF    03.5
0B14:  BSF    06.3
0B15:  BCF    03.5
0B16:  BTFSC  06.3
0B17:  GOTO   31A
....................                     restart_wdt(); 
0B18:  CLRWDT
0B19:  GOTO   313
0B1A:  BSF    03.5
....................             } 
....................         } 
0B1B:  BCF    03.5
0B1C:  GOTO   15D
....................     } 
.................... } 
0B1D:  SLEEP

Configuration Fuses:
   Word  1: 2CC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
